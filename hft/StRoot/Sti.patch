From f8249086700912d85938789d1374154a298aa279 Mon Sep 17 00:00:00 2001
From: Dmitri Smirnov <d.s@plexoos.com>
Date: Wed, 16 Apr 2014 16:43:39 -0400
Subject: [PATCH 01/11] Converted CRLF line terminators to linux style

---
 Sti/StiGenericDetectorGroup.cxx | 138 ++++++++++++++++++++--------------------
 1 file changed, 69 insertions(+), 69 deletions(-)

diff --git a/Sti/StiGenericDetectorGroup.cxx b/Sti/StiGenericDetectorGroup.cxx
index 1bbcb4b..fd18c92 100644
--- a/Sti/StiGenericDetectorGroup.cxx
+++ b/Sti/StiGenericDetectorGroup.cxx
@@ -1,69 +1,69 @@
-// $Id$
-// Author: Valeri Fine, Dec 2006
-
-#include <stdexcept>
-#include "StiGenericDetectorGroup.h"
-#include "Sti/StiDetectorBuilder.h"
-
-//_____________________________________________________________________________
-StiGenericDetectorGroup::StiGenericDetectorGroup(const string & name)
-  : Named(name),
-     _detectorBuilder(0),
-     _elossCalculator(0),
-     _groupId(-1)
-{
-  
-}
-
-//_____________________________________________________________________________
-StiGenericDetectorGroup::StiGenericDetectorGroup(const string & name,
-		   StiDetectorBuilder * detectorBuilder,
-		   StiElossCalculator * elossCalculator)
-    :  Named(name),
-     _detectorBuilder(detectorBuilder),
-     _elossCalculator(elossCalculator),
-     _groupId(-1)
-{
-}
-
-//_____________________________________________________________________________
-StiGenericDetectorGroup::~StiGenericDetectorGroup()
-{
-  delete _detectorBuilder;
-}
-//_____________________________________________________________________________
-StiDetectorBuilder *StiGenericDetectorGroup::getDetectorBuilder()
-{
-  if (_detectorBuilder==0)
-    {
-      string message = "StiDetectorGroup::getDetectorBuilder() - ERROR - builder == 0 for detector:";
-      message += getName();
-      throw logic_error(message.c_str());
-    }
-  return _detectorBuilder; 
-}
-
-//_____________________________________________________________________________
-StiElossCalculator *StiGenericDetectorGroup::getElossCalculator()
-{
-   if (_elossCalculator==0)
-   {
-      string message = "StiDetectorGroup::getElossCalculator() - ERROR - elossCalculator == 0 for detector:";
-      message += getName();
-      throw logic_error(message.c_str());
-   }
-   return _elossCalculator; 
-}
-
-//_____________________________________________________________________________
-void StiGenericDetectorGroup::setGroupId(int id)
-{
-  if (_detectorBuilder) _detectorBuilder->setGroupId(id);
-  _groupId = id;
-}
-
-//_____________________________________________________________________________
-int  StiGenericDetectorGroup::getGroupId() const
-{
-  return _groupId;
-}
+// $Id$
+// Author: Valeri Fine, Dec 2006
+
+#include <stdexcept>
+#include "StiGenericDetectorGroup.h"
+#include "Sti/StiDetectorBuilder.h"
+
+//_____________________________________________________________________________
+StiGenericDetectorGroup::StiGenericDetectorGroup(const string & name)
+  : Named(name),
+     _detectorBuilder(0),
+     _elossCalculator(0),
+     _groupId(-1)
+{
+  
+}
+
+//_____________________________________________________________________________
+StiGenericDetectorGroup::StiGenericDetectorGroup(const string & name,
+		   StiDetectorBuilder * detectorBuilder,
+		   StiElossCalculator * elossCalculator)
+    :  Named(name),
+     _detectorBuilder(detectorBuilder),
+     _elossCalculator(elossCalculator),
+     _groupId(-1)
+{
+}
+
+//_____________________________________________________________________________
+StiGenericDetectorGroup::~StiGenericDetectorGroup()
+{
+  delete _detectorBuilder;
+}
+//_____________________________________________________________________________
+StiDetectorBuilder *StiGenericDetectorGroup::getDetectorBuilder()
+{
+  if (_detectorBuilder==0)
+    {
+      string message = "StiDetectorGroup::getDetectorBuilder() - ERROR - builder == 0 for detector:";
+      message += getName();
+      throw logic_error(message.c_str());
+    }
+  return _detectorBuilder; 
+}
+
+//_____________________________________________________________________________
+StiElossCalculator *StiGenericDetectorGroup::getElossCalculator()
+{
+   if (_elossCalculator==0)
+   {
+      string message = "StiDetectorGroup::getElossCalculator() - ERROR - elossCalculator == 0 for detector:";
+      message += getName();
+      throw logic_error(message.c_str());
+   }
+   return _elossCalculator; 
+}
+
+//_____________________________________________________________________________
+void StiGenericDetectorGroup::setGroupId(int id)
+{
+  if (_detectorBuilder) _detectorBuilder->setGroupId(id);
+  _groupId = id;
+}
+
+//_____________________________________________________________________________
+int  StiGenericDetectorGroup::getGroupId() const
+{
+  return _groupId;
+}
-- 
1.8.2.GIT


From bf2221ae68e8dd5963ecc44a072d1cc9f12dec60 Mon Sep 17 00:00:00 2001
From: Dmitri Smirnov <d.s@plexoos.com>
Date: Wed, 16 Apr 2014 17:59:53 -0400
Subject: [PATCH 02/11] Added a set method to replace the default
 StiDetectorBuilder

---
 Sti/StiGenericDetectorGroup.cxx | 21 +++++++++++++++++++++
 Sti/StiGenericDetectorGroup.h   |  1 +
 2 files changed, 22 insertions(+)

diff --git a/Sti/StiGenericDetectorGroup.cxx b/Sti/StiGenericDetectorGroup.cxx
index fd18c92..9df42a1 100644
--- a/Sti/StiGenericDetectorGroup.cxx
+++ b/Sti/StiGenericDetectorGroup.cxx
@@ -43,6 +43,27 @@ StiDetectorBuilder *StiGenericDetectorGroup::getDetectorBuilder()
   return _detectorBuilder; 
 }
 
+
+/**
+ * Replaces the existing detector builder with a new one. Returns the old
+ * detector builder. The ownership is transfered to this class.
+ */
+void StiGenericDetectorGroup::setDetectorBuilder(StiDetectorBuilder* detBuilder)
+{
+  if (!detBuilder)
+  {
+     string message = "StiGenericDetectorGroup::setDetectorBuilder() - ERROR - Non-existing detector builder was provided for detector: ";
+     //message += getName();
+     //throw logic_error(message.c_str());
+  }
+
+  // Delete the existing detector builder
+  delete _detectorBuilder;
+
+  _detectorBuilder = detBuilder;
+}
+
+
 //_____________________________________________________________________________
 StiElossCalculator *StiGenericDetectorGroup::getElossCalculator()
 {
diff --git a/Sti/StiGenericDetectorGroup.h b/Sti/StiGenericDetectorGroup.h
index 126011a..0c11d74 100644
--- a/Sti/StiGenericDetectorGroup.h
+++ b/Sti/StiGenericDetectorGroup.h
@@ -26,6 +26,7 @@ class StiGenericDetectorGroup  : public Named
      virtual void initialize(){} ; // FIXME:  this method must be abstract = 0;
     /// Get a detector builder appropriate for this detector group
     virtual StiDetectorBuilder * getDetectorBuilder();
+    virtual void setDetectorBuilder(StiDetectorBuilder* detBuilder);
 
     /// Get a pid calculator appropriate for this detector group
     /// A dedx calculator is used after the track are fitted
-- 
1.8.2.GIT


From 30621ebc2f4580e79288a6f5804f7acd5e471697 Mon Sep 17 00:00:00 2001
From: Dmitri Smirnov <d.s@plexoos.com>
Date: Tue, 25 Mar 2014 16:04:17 -0400
Subject: [PATCH 03/11] Fixed style with astyle -s3 -p -H -A3 -k3 -O -o -y -Y
 -f

---
 Sti/StiKalmanTrackFinder.cxx | 1635 +++++++++++++-----------
 Sti/StiKalmanTrackFinder.h   |  204 +--
 Sti/StiKalmanTrackFitter.cxx |  211 ++--
 Sti/StiKalmanTrackFitter.h   |   34 +-
 Sti/StiKalmanTrackNode.cxx   | 2877 +++++++++++++++++++++++-------------------
 Sti/StiKalmanTrackNode.h     |  673 +++++-----
 6 files changed, 3072 insertions(+), 2562 deletions(-)

diff --git a/Sti/StiKalmanTrackFinder.cxx b/Sti/StiKalmanTrackFinder.cxx
index 9e3eb30..e12a041 100644
--- a/Sti/StiKalmanTrackFinder.cxx
+++ b/Sti/StiKalmanTrackFinder.cxx
@@ -53,57 +53,59 @@ using namespace std;
 #ifdef DO_TPCCATRACKER
 #include "StiTPCCATrackerInterface.h"
 #endif /* DO_TPCCATRACKER */
-enum {kSeedTimg,kTrakTimg,kPrimTimg};
-enum {kMaxTrackPerm = 10000,kMaxEventPerm=10000000};
+enum {kSeedTimg, kTrakTimg, kPrimTimg};
+enum {kMaxTrackPerm = 10000, kMaxEventPerm = 10000000};
 
-static const double kRMinTpc =55;
+static const double kRMinTpc = 55;
 int StiKalmanTrackFinder::_debug = 0;
-ostream& operator<<(ostream&, const StiTrack&);
+ostream &operator<<(ostream &, const StiTrack &);
 int gLevelOfFind = 0;
 //______________________________________________________________________________
 void StiKalmanTrackFinder::initialize()
 {
-  cout << "StiKalmanTrackFinder::initialize() -I- Started"<<endl;
-  _toolkit = StiToolkit::instance();
-  _trackNodeFactory  = _toolkit->getTrackNodeFactory();
-  _detectorContainer = _toolkit->getDetectorContainer();
-  _detectorContainer->reset();
-  _trackSeedFinder   = _toolkit->getTrackSeedFinder();
-  _hitContainer      = _toolkit->getHitContainer();
-  _trackContainer    = _toolkit->getTrackContainer();
-  /*
-  StiDefaultTrackFilter * trackFilter = new StiDefaultTrackFilter("FinderTrackFilter","Reconstructed Track Filter");
-  trackFilter->add( new EditableParameter("nPtsUsed","Use nPts", 1., 1., 0., 1., 1.,
-                                          Parameter::Boolean, StiTrack::kPointCount) );
-  trackFilter->add( new EditableParameter("nPtsMin", "Minimum nPts", 10., 10., 0., 100.,1.,
-                                          Parameter::Integer,StiTrack::kPointCount) );
-  trackFilter->add( new EditableParameter("nPtsMax", "Maximum nPts", 60., 60., 0., 100.,1.,
-                                          Parameter::Integer,StiTrack::kPointCount) );
-  trackFilter->add(new EditableParameter("lengthUsed","Use Length", 1., 1., 0.,1.,1.,Parameter::Boolean, StiTrack::kTrackLength));
-  trackFilter->add(new EditableParameter("lengthMin", "Min Length", 0., 0., -300.,   300.,2,Parameter::Double, StiTrack::kTrackLength));
-  trackFilter->add(new EditableParameter("lengthMax", "Max Length", 300.,  300., -300.,   300.,2,Parameter::Double, StiTrack::kTrackLength));
-  _trackFilter = trackFilter;
-  */
-  _trackFilter = new StiTrackFinderFilter();
-  //_toolkit->setFinderTrackFilter(_trackFilter);
-  cout << "StiKalmanTrackFinder::initialize() -I- Done"<<endl;
+   cout << "StiKalmanTrackFinder::initialize() -I- Started" << endl;
+   _toolkit = StiToolkit::instance();
+   _trackNodeFactory  = _toolkit->getTrackNodeFactory();
+   _detectorContainer = _toolkit->getDetectorContainer();
+   _detectorContainer->reset();
+   _trackSeedFinder   = _toolkit->getTrackSeedFinder();
+   _hitContainer      = _toolkit->getHitContainer();
+   _trackContainer    = _toolkit->getTrackContainer();
+   /*
+   StiDefaultTrackFilter * trackFilter = new StiDefaultTrackFilter("FinderTrackFilter","Reconstructed Track Filter");
+   trackFilter->add( new EditableParameter("nPtsUsed","Use nPts", 1., 1., 0., 1., 1.,
+                                           Parameter::Boolean, StiTrack::kPointCount) );
+   trackFilter->add( new EditableParameter("nPtsMin", "Minimum nPts", 10., 10., 0., 100.,1.,
+                                           Parameter::Integer,StiTrack::kPointCount) );
+   trackFilter->add( new EditableParameter("nPtsMax", "Maximum nPts", 60., 60., 0., 100.,1.,
+                                           Parameter::Integer,StiTrack::kPointCount) );
+   trackFilter->add(new EditableParameter("lengthUsed","Use Length", 1., 1., 0.,1.,1.,Parameter::Boolean, StiTrack::kTrackLength));
+   trackFilter->add(new EditableParameter("lengthMin", "Min Length", 0., 0., -300.,   300.,2,Parameter::Double, StiTrack::kTrackLength));
+   trackFilter->add(new EditableParameter("lengthMax", "Max Length", 300.,  300., -300.,   300.,2,Parameter::Double, StiTrack::kTrackLength));
+   _trackFilter = trackFilter;
+   */
+   _trackFilter = new StiTrackFinderFilter();
+   //_toolkit->setFinderTrackFilter(_trackFilter);
+   cout << "StiKalmanTrackFinder::initialize() -I- Done" << endl;
 }
 
-StiKalmanTrackFinder::StiKalmanTrackFinder(StiToolkit*toolkit)
-:
-_toolkit(toolkit),
-_trackFilter(0),
-_trackSeedFinder(0),
-_trackNodeFactory(0),
-_detectorContainer(0),
-_hitContainer(0),
-_trackContainer(0)
+StiKalmanTrackFinder::StiKalmanTrackFinder(StiToolkit *toolkit)
+   :
+   _toolkit(toolkit),
+   _trackFilter(0),
+   _trackSeedFinder(0),
+   _trackNodeFactory(0),
+   _detectorContainer(0),
+   _hitContainer(0),
+   _trackContainer(0)
 {
-  cout << "StiKalmanTrackFinder::StiKalmanTrackFinder() - Started"<<endl;
-memset(mTimg,0,sizeof(mTimg));
-  if (!_toolkit)
-    throw runtime_error("StiKalmanTrackFinder::StiKalmanTrackFinder(...) - FATAL - toolkit==0");
-  cout << "StiKalmanTrackFinder::StiKalmanTrackFinder() - Done"<<endl;
+   cout << "StiKalmanTrackFinder::StiKalmanTrackFinder() - Started" << endl;
+   memset(mTimg, 0, sizeof(mTimg));
+
+   if (!_toolkit)
+      throw runtime_error("StiKalmanTrackFinder::StiKalmanTrackFinder(...) - FATAL - toolkit==0");
+
+   cout << "StiKalmanTrackFinder::StiKalmanTrackFinder() - Done" << endl;
 }
 //______________________________________________________________________________
 /*!
@@ -116,13 +118,13 @@ Reset the state of the finder  to "event not tracked"
 //______________________________________________________________________________
 void StiKalmanTrackFinder::reset()
 {
-  //cout << "StiKalmanTrackFinder::reset() -I- Starting" <<endl;
-  _detectorContainer->reset();
-  _trackContainer->clear();
-  _trackNodeFactory->reset();
-  _hitContainer->reset();
-  _trackSeedFinder->reset();
-  //cout << "StiKalmanTrackFinder::reset() -I- Done" <<endl;
+   //cout << "StiKalmanTrackFinder::reset() -I- Starting" <<endl;
+   _detectorContainer->reset();
+   _trackContainer->clear();
+   _trackNodeFactory->reset();
+   _hitContainer->reset();
+   _trackSeedFinder->reset();
+   //cout << "StiKalmanTrackFinder::reset() -I- Done" <<endl;
 }
 
 //______________________________________________________________________________
@@ -137,10 +139,10 @@ Reset the state of the finder  to "no event loaded"
 //______________________________________________________________________________
 void StiKalmanTrackFinder::clear()
 {
-  //cout << "StiKalmanTrackFinder::clear() -I- Starting" <<endl;
-  _hitContainer->clear();
-  reset();
-  //cout << "StiKalmanTrackFinder::clear() -I- Done" <<endl;
+   //cout << "StiKalmanTrackFinder::clear() -I- Starting" <<endl;
+   _hitContainer->clear();
+   reset();
+   //cout << "StiKalmanTrackFinder::clear() -I- Done" <<endl;
 }
 
 //______________________________________________________________________________
@@ -155,194 +157,237 @@ filter is set or if they satisfy the track filter requirements.
 //______________________________________________________________________________
 void StiKalmanTrackFinder::findTracks()
 {
-  mEventPerm = kMaxEventPerm;
-
-  assert(_trackContainer );
-  assert(_trackSeedFinder);
-  _trackSeedFinder->reset();
-  _trackContainer->clear();
-  if (_trackFilter) _trackFilter->reset();
-#ifdef DO_TPCCATRACKER 
-  StiTPCCATrackerInterface& caTrackerInt = StiTPCCATrackerInterface::Instance();
-  caTrackerInt.SetNewEvent();
-  findTpcTracks(caTrackerInt); // find track starting with TPC (CA seed finder)
-#endif /* DO_TPCCATRACKER */  
-  findAllTracks(); // find track left
-#ifdef DO_TPCCATRACKER 
-  caTrackerInt.SetStiTracks(_trackContainer);
-  caTrackerInt.RunPerformance();
+   mEventPerm = kMaxEventPerm;
+
+   assert(_trackContainer );
+   assert(_trackSeedFinder);
+   _trackSeedFinder->reset();
+   _trackContainer->clear();
+
+   if (_trackFilter) _trackFilter->reset();
+
+#ifdef DO_TPCCATRACKER
+   StiTPCCATrackerInterface &caTrackerInt = StiTPCCATrackerInterface::Instance();
+   caTrackerInt.SetNewEvent();
+   findTpcTracks(caTrackerInt); // find track starting with TPC (CA seed finder)
+#endif /* DO_TPCCATRACKER */
+   findAllTracks(); // find track left
+#ifdef DO_TPCCATRACKER
+   caTrackerInt.SetStiTracks(_trackContainer);
+   caTrackerInt.RunPerformance();
 #endif /* DO_TPCCATRACKER */
 }
 #ifdef DO_TPCCATRACKER
 //________________________________________________________________________________
-void StiKalmanTrackFinder::findTpcTracks(StiTPCCATrackerInterface &caTrackerInt) {
-  StiTpcSeedFinder::findTpcTracks(caTrackerInt);
+void StiKalmanTrackFinder::findTpcTracks(StiTPCCATrackerInterface &caTrackerInt)
+{
+   StiTpcSeedFinder::findTpcTracks(caTrackerInt);
 }
 #endif /* DO_TPCCATRACKER */
 //________________________________________________________________________________
-void StiKalmanTrackFinder::findAllTracks() {
-  
-  
-//  extendSeeds (0.);
+void StiKalmanTrackFinder::findAllTracks()
+{
 
 
-  extendSeeds (0.);
-//  _trackContainer->sort();
-//  extendTracks( 0.);
+   //  extendSeeds (0.);
+
+
+   extendSeeds (0.);
+   //  _trackContainer->sort();
+   //  extendTracks( 0.);
 }
 //________________________________________________________________________________
-Int_t StiKalmanTrackFinder::Fit(StiKalmanTrack *track, Double_t rMin) {
-  int errType = kNoErrors; // no err by default
+Int_t StiKalmanTrackFinder::Fit(StiKalmanTrack *track, Double_t rMin)
+{
+   int errType = kNoErrors; // no err by default
 
-  Int_t nTSeed=0,nTAdd=0,nTFail=0,nTFilt=0,status = kNoErrors;
-  Int_t nTpcHits=0,nSvtHits=0,nSsdHits=0,nIstHits=0,nPxlHits=0;
+   Int_t nTSeed = 0, nTAdd = 0, nTFail = 0, nTFilt = 0, status = kNoErrors;
+   Int_t nTpcHits = 0, nSvtHits = 0, nSsdHits = 0, nIstHits = 0, nPxlHits = 0;
 
-  do { //technical do
-    track->setFlag(-1);
+   do { //technical do
+      track->setFlag(-1);
 #ifndef DO_TPCCATRACKER
-    status = track->approx(0); // should be filled by track->initialize()
-    if (status) 	{nTSeed++; errType = abs(status)*100 + kApproxFail; break;}
+      status = track->approx(0); // should be filled by track->initialize()
+
+      if (status) 	{nTSeed++; errType = abs(status) * 100 + kApproxFail; break;}
+
 #endif /* !DO_TPCCATRACKER */
-    status = track->fit(kOutsideIn);
-    if (status) 	{nTSeed++; errType = abs(status)*100 + kFitFail; break;}
-    status = extendTrack(track,rMin); // 0 - can't extend. 1 - can extend and refit -1 - can extend and can't refit. 
+      status = track->fit(kOutsideIn);
+
+      if (status) 	{nTSeed++; errType = abs(status) * 100 + kFitFail; break;}
+
+      status = extendTrack(track, rMin); // 0 - can't extend. 1 - can extend and refit -1 - can extend and can't refit.
 #ifndef DO_TPCCATRACKER
-    if (status != kExtended)                               {nTFail++; errType = abs(status)*100 + kExtendFail; break;}
+
+      if (status != kExtended)                               {nTFail++; errType = abs(status) * 100 + kExtendFail; break;}
+
 #else /* DO_TPCCATRACKER */
-    if ((status != kExtended) && (status != kNotExtended)) {nTFail++; errType = abs(status)*100 + kExtendFail; break;}
+
+      if ((status != kExtended) && (status != kNotExtended)) {nTFail++; errType = abs(status) * 100 + kExtendFail; break;}
+
 #endif /* !DO_TPCCATRACKER */
-    if (_trackFilter){
-      status = _trackFilter->filter(track);
-      if (status) {nTFilt++; errType = abs(status)*100 + kCheckFail; break;}
-    }
-    //cout << "  ++++++++++++++++++++++++++++++ Adding Track"<<endl;
-    //		Add DCA node
-    StiHit dcaHit; dcaHit.makeDca();
-    StiTrackNode *extenDca = track->extendToVertex(&dcaHit);
-    if (extenDca) {
-      track->add(extenDca,kOutsideIn);
-      if (debug() >= 1) StiKalmanTrackNode::PrintStep();
-    }
-    //		End DCA node
-    track->reduce();
-    nTAdd++;
-    track->setFlag(1);
-    _trackContainer->push_back(track);
-    track->setId(_trackContainer->size());
-    track->reserveHits();
-    nTpcHits+=track->getFitPointCount(kTpcId);
-    nSvtHits+=track->getFitPointCount(kSvtId);
-    nSsdHits+=track->getFitPointCount(kSsdId);
-    nIstHits+=track->getFitPointCount(kIstId);
-    nPxlHits+=track->getFitPointCount(kPxlId);
-    //cout << "  ++++++++++++++++++++++++++++++ Added Track"<<endl;
-    LOG_DEBUG << Form("StiKalmanTrackFinder::Fit:nbSeed=%d nTFail=%d nTFilt=%d nTAdd=%d", 
-		      nTSeed,nTFail,nTFilt,nTAdd) << endm;
-    LOG_DEBUG << Form("StiKalmanTrackFinder::Fit:nTpcHits=%d nSvtHits=%d  nSsdHits=%d nPxlHits=%d nIstHits=%d",
-		      nTpcHits,nSvtHits,nSsdHits,nPxlHits,nIstHits)
-	      << endm;
-  } while(0);
-  return errType;
+
+      if (_trackFilter) {
+         status = _trackFilter->filter(track);
+
+         if (status) {nTFilt++; errType = abs(status) * 100 + kCheckFail; break;}
+      }
+
+      //cout << "  ++++++++++++++++++++++++++++++ Adding Track"<<endl;
+      //		Add DCA node
+      StiHit dcaHit; dcaHit.makeDca();
+      StiTrackNode *extenDca = track->extendToVertex(&dcaHit);
+
+      if (extenDca) {
+         track->add(extenDca, kOutsideIn);
+
+         if (debug() >= 1) StiKalmanTrackNode::PrintStep();
+      }
+
+      //		End DCA node
+      track->reduce();
+      nTAdd++;
+      track->setFlag(1);
+      _trackContainer->push_back(track);
+      track->setId(_trackContainer->size());
+      track->reserveHits();
+      nTpcHits += track->getFitPointCount(kTpcId);
+      nSvtHits += track->getFitPointCount(kSvtId);
+      nSsdHits += track->getFitPointCount(kSsdId);
+      nIstHits += track->getFitPointCount(kIstId);
+      nPxlHits += track->getFitPointCount(kPxlId);
+      //cout << "  ++++++++++++++++++++++++++++++ Added Track"<<endl;
+      LOG_DEBUG << Form("StiKalmanTrackFinder::Fit:nbSeed=%d nTFail=%d nTFilt=%d nTAdd=%d",
+                        nTSeed, nTFail, nTFilt, nTAdd) << endm;
+      LOG_DEBUG << Form("StiKalmanTrackFinder::Fit:nTpcHits=%d nSvtHits=%d  nSsdHits=%d nPxlHits=%d nIstHits=%d",
+                        nTpcHits, nSvtHits, nSsdHits, nPxlHits, nIstHits)
+                << endm;
+   }
+   while (0);
+
+   return errType;
 }
 //______________________________________________________________________________
 void StiKalmanTrackFinder::extendSeeds(double rMin)
 {
-  static int nCall=0;nCall++;
-  StiKalmanTrack *track;
-  Int_t nTTot=0;
-
-  while (true ){
-// 		obtain track seed from seed finder
-    
-    if (mTimg[kSeedTimg]) mTimg[kSeedTimg]->Start(0);
-
-    track = (StiKalmanTrack*)_trackSeedFinder->findTrack(rMin);
-
-    if (mTimg[kSeedTimg]) mTimg[kSeedTimg]->Stop();
-    if (!track) break; // no more seeds
-    nTTot++;
-    if (mTimg[kTrakTimg]) mTimg[kTrakTimg]->Start(0);
-    Int_t errType = Fit(track,rMin);
-    if (errType != kNoErrors) BFactory::Free(track);
-    if (mTimg[kTrakTimg]) mTimg[kTrakTimg]->Stop();
-  }
+   static int nCall = 0; nCall++;
+   StiKalmanTrack *track;
+   Int_t nTTot = 0;
+
+   while (true ) {
+      // 		obtain track seed from seed finder
+
+      if (mTimg[kSeedTimg]) mTimg[kSeedTimg]->Start(0);
+
+      track = (StiKalmanTrack *)_trackSeedFinder->findTrack(rMin);
+
+      if (mTimg[kSeedTimg]) mTimg[kSeedTimg]->Stop();
+
+      if (!track) break; // no more seeds
+
+      nTTot++;
+
+      if (mTimg[kTrakTimg]) mTimg[kTrakTimg]->Start(0);
+
+      Int_t errType = Fit(track, rMin);
+
+      if (errType != kNoErrors) BFactory::Free(track);
+
+      if (mTimg[kTrakTimg]) mTimg[kTrakTimg]->Stop();
+   }
 }
 //______________________________________________________________________________
 void StiKalmanTrackFinder::extendTracks(double rMin)
 {
-static int nCall=0;nCall++;
-
-  int nTKeep=0;
-  int ntr = _trackContainer->size();
-  int nTpcHits=0,nSvtHits=0,nSsdHits=0,nPxlHits=0,nIstHits=0, extended=0;
-  
-  for ( int itr=0;itr < ntr;itr++) {	//Track loop
-    StiKalmanTrack *track = (StiKalmanTrack*)(*_trackContainer)[itr];
-    if (track->getFlag()<=0) 	continue;
-
-    extended = extendTrack(track,rMin);
-    track->reduce();
-    if (extended<0 || track->getFlag()<=0) {
-      track->reduce(); continue;
-    } else {
-      StiHit dcaHit; dcaHit.makeDca();
-      StiTrackNode *extenDca = track->extendToVertex(&dcaHit);
-      if (extenDca) track->add(extenDca,kOutsideIn);
+   static int nCall = 0; nCall++;
+
+   int nTKeep = 0;
+   int ntr = _trackContainer->size();
+   int nTpcHits = 0, nSvtHits = 0, nSsdHits = 0, nPxlHits = 0, nIstHits = 0, extended = 0;
+
+   for ( int itr = 0; itr < ntr; itr++) {	//Track loop
+      StiKalmanTrack *track = (StiKalmanTrack *)(*_trackContainer)[itr];
+
+      if (track->getFlag() <= 0) 	continue;
+
+      extended = extendTrack(track, rMin);
       track->reduce();
-    }
-    nTKeep++;
-    nTpcHits+=track->getFitPointCount(kTpcId);
-    nSvtHits+=track->getFitPointCount(kSvtId);
-    nSsdHits+=track->getFitPointCount(kSsdId);
-    nPxlHits+=track->getFitPointCount(kPxlId);
-    nIstHits+=track->getFitPointCount(kIstId);
-    track->reserveHits();
-  }// end track loop
+
+      if (extended < 0 || track->getFlag() <= 0) {
+         track->reduce(); continue;
+      }
+      else {
+         StiHit dcaHit; dcaHit.makeDca();
+         StiTrackNode *extenDca = track->extendToVertex(&dcaHit);
+
+         if (extenDca) track->add(extenDca, kOutsideIn);
+
+         track->reduce();
+      }
+
+      nTKeep++;
+      nTpcHits += track->getFitPointCount(kTpcId);
+      nSvtHits += track->getFitPointCount(kSvtId);
+      nSsdHits += track->getFitPointCount(kSsdId);
+      nPxlHits += track->getFitPointCount(kPxlId);
+      nIstHits += track->getFitPointCount(kIstId);
+      track->reserveHits();
+   }// end track loop
+
    LOG_DEBUG << Form("***extendTracks***: nTKeep=%d", nTKeep) << endm;
    LOG_DEBUG << Form("***extendTracks***: nTpcHits=%d nSvtHits=%d nSsdHits=%d nPxlHits=%d nIstHits=%d",
-	nTpcHits,nSvtHits,nSsdHits,nPxlHits,nIstHits) << endm;
+                     nTpcHits, nSvtHits, nSsdHits, nPxlHits, nIstHits) << endm;
 }
 //______________________________________________________________________________
-int StiKalmanTrackFinder::extendTrack(StiKalmanTrack *track,double rMin)
+int StiKalmanTrackFinder::extendTrack(StiKalmanTrack *track, double rMin)
 {
-  static int nCall=0; nCall++;
-  StiDebug::Break(nCall);
-  int trackExtended   =0;  
-  int trackExtendedOut=0;
-  int status = 0;
-    // invoke tracker to find or extend this track
-    //cout <<"StiKalmanTrack::find(int) -I- Outside-in"<<endl;
-  {
-    if (debug()) cout << "StiKalmanTrack::find seed " << *((StiTrack *) track);
-    trackExtended = find(track,kOutsideIn,rMin);
-    if (trackExtended) {
-      status = 0;
-      if(status) return abs(status)*100 + kRefitInFail;
-    }	
-
-  }
-    // decide if an outward pass is needed.
-  const StiKalmanTrackNode * outerMostNode = track->getOuterMostNode(2);
-  if (!outerMostNode)
-  {
-    track->setFlag(-1);
-    return 0;
-  }
-  if (outerMostNode->getX()<185. )
-  {
-    trackExtendedOut= find(track,kInsideOut);
-    if (debug()) cout << "StiKalmanTrackFinder::extendTrack (track,kInsideOut)" << *((StiTrack *) track);
-  }
-  trackExtended |=trackExtendedOut;
-  if (trackExtended) {
-    status = track->approx(1);
+   static int nCall = 0; nCall++;
+   StiDebug::Break(nCall);
+   int trackExtended   = 0;
+   int trackExtendedOut = 0;
+   int status = 0;
+   // invoke tracker to find or extend this track
+   //cout <<"StiKalmanTrack::find(int) -I- Outside-in"<<endl;
+   {
+      if (debug()) cout << "StiKalmanTrack::find seed " << *((StiTrack *) track);
+
+      trackExtended = find(track, kOutsideIn, rMin);
+
+      if (trackExtended) {
+         status = 0;
+
+         if (status) return abs(status) * 100 + kRefitInFail;
+      }
+
+   }
+   // decide if an outward pass is needed.
+   const StiKalmanTrackNode *outerMostNode = track->getOuterMostNode(2);
+
+   if (!outerMostNode) {
+      track->setFlag(-1);
+      return 0;
+   }
+
+   if (outerMostNode->getX() < 185. ) {
+      trackExtendedOut = find(track, kInsideOut);
+
+      if (debug()) cout << "StiKalmanTrackFinder::extendTrack (track,kInsideOut)" << *((StiTrack *) track);
+   }
+
+   trackExtended |= trackExtendedOut;
+
+   if (trackExtended) {
+      status = track->approx(1);
       //    if (status) return -1;
-    status = track->refit();
-    if (status) return abs(status)*100 + kRefitOutFail;
-  }
-    //cout << " find track done" << endl;
-  if ( trackExtended ) return kExtended;
-  return kNotExtended;
+      status = track->refit();
+
+      if (status) return abs(status) * 100 + kRefitOutFail;
+   }
+
+   //cout << " find track done" << endl;
+   if ( trackExtended ) return kExtended;
+
+   return kNotExtended;
 }
 //______________________________________________________________________________
 /*
@@ -364,430 +409,542 @@ int StiKalmanTrackFinder::extendTrack(StiKalmanTrack *track,double rMin)
  caught here and reported with "cout".
  */
 //______________________________________________________________________________
-void StiKalmanTrackFinder::extendTracksToVertex(StiHit* vertex)
+void StiKalmanTrackFinder::extendTracksToVertex(StiHit *vertex)
 {
-  //cout << "SKTF::extendTracksToVertex() - vertex position " << vertex->x_g() << ", " << vertex->y_g() << ", " << vertex->z_g() << endl;
-
-  int rawCount = 0;
-  int goodCount= 0;
-  int plus=0;
-  int minus=0;
-  int ntr = _trackContainer->size();
-  for (int itr=0;itr<ntr;itr++) {
-      StiKalmanTrack* track = (StiKalmanTrack*)(*_trackContainer)[itr];
+   //cout << "SKTF::extendTracksToVertex() - vertex position " << vertex->x_g() << ", " << vertex->y_g() << ", " << vertex->z_g() << endl;
+
+   int rawCount = 0;
+   int goodCount = 0;
+   int plus = 0;
+   int minus = 0;
+   int ntr = _trackContainer->size();
+
+   for (int itr = 0; itr < ntr; itr++) {
+      StiKalmanTrack *track = (StiKalmanTrack *)(*_trackContainer)[itr];
       rawCount++;
       StiTrackNode *extended = track->extendToVertex(vertex);
+
       if (extended) {
-        track->add(extended,kOutsideIn);
-static int myRefit=0;
-        if (myRefit && track->refit()) 			extended=0;
-        if (extended && !extended->isValid()) 		extended=0;
-        if (extended && extended->getChi2()>1000) 	extended=0;
+         track->add(extended, kOutsideIn);
+         static int myRefit = 0;
+
+         if (myRefit && track->refit()) 			extended = 0;
+
+         if (extended && !extended->isValid()) 		extended = 0;
+
+         if (extended && extended->getChi2() > 1000) 	extended = 0;
       }
+
       track->reduce();
+
       // simple diagnostics
       if (extended) goodCount++;
-      if (track->getCharge()>0) plus++;else minus++;
+      if (track->getCharge() > 0) plus++; else minus++;
    }
-  cout << "SKTF::extendTracksToVertex(StiHit* vertex) -I- rawCount:"<<rawCount<<endl
-       << "                                          extendedCount:"<<goodCount<<endl
-       << "                                                   plus:"<<plus<<endl
-       << "                                                  minus:"<<minus<<endl;
+
+   cout << "SKTF::extendTracksToVertex(StiHit* vertex) -I- rawCount:" << rawCount << endl
+        << "                                          extendedCount:" << goodCount << endl
+        << "                                                   plus:" << plus << endl
+        << "                                                  minus:" << minus << endl;
 }
 //______________________________________________________________________________
-void StiKalmanTrackFinder::extendTracksToVertices(const std::vector<StiHit*> &vertices)
+void StiKalmanTrackFinder::extendTracksToVertices(const std::vector<StiHit *> &vertices)
 {
-  static const double RMAX2d=StiKalmanTrackFinderParameters::instance()->maxDca2dZeroXY();
-  static const double DMAX3d=StiKalmanTrackFinderParameters::instance()->maxDca3dVertex();
-
-  StiKalmanTrackNode *extended=0;
-  int goodCount= 0, plus=0, minus=0;
-  int nTracks = _trackContainer->size();
-  int nVertex =         vertices.size();  
-  if (!nVertex || !nTracks) return;
-
-  for (int iTrack=0;iTrack<nTracks;iTrack++)		{
-    StiKalmanTrack * track = (StiKalmanTrack*)(*_trackContainer)[iTrack];  
-StiDebug::tally("Tracks");
-
-    StiKalmanTrackNode *bestNode=0;  
-    int bestVertex=0;
-    StThreeVectorD nearBeam;
-    track->getNearBeam(&nearBeam);
-    if (nearBeam.perp2()>RMAX2d*RMAX2d) 		continue;
-    for (int iVertex=0;iVertex<nVertex;iVertex++) {
-      StiHit *vertex = vertices[iVertex];
-      if (fabs(track->getDca(vertex)) > DMAX3d)    	continue;
-StiDebug::tally("PrimCandidates");
-      if (mTimg[kPrimTimg]) mTimg[kPrimTimg]->Start(0);
-
-      extended = (StiKalmanTrackNode*)track->extendToVertex(vertex);
-      if (mTimg[kPrimTimg]) mTimg[kPrimTimg]->Stop();
-
-      if (!extended) 					continue;
-StiDebug::tally("PrimExtended");
-      if (!bestNode) {bestNode=extended;bestVertex=iVertex+1;continue;}
-      if (bestNode->getChi2()+log(bestNode->getDeterm())
-         <extended->getChi2()+log(extended->getDeterm()))continue;
-      BFactory::Free(bestNode);
-      bestNode = extended; bestVertex=iVertex+1;
-    }//End vertex loop
-    
-    if(!bestNode) 			continue;
-    track->add(bestNode,kOutsideIn);
-    track->setPrimary(bestVertex);
-StiDebug::tally("PrimAdded");
-    int         ifail = 0;
-static int REFIT=2005;
-    bestNode->setUntouched();
-if (REFIT) {
-    ifail = track->refit();
-    ifail |= (track->getInnerMostHitNode(3)!=bestNode);
-}
-    track->reduce();
-// something is wrong. It is not a primary
-    if (ifail) { track->removeLastNode(); track->setPrimary(0); continue;}
-    goodCount++;
-StiDebug::tally("PrimRefited");
-    if (track->getCharge()>0) plus++; else minus++;
-
-  }//End track loop 
-  _nPrimTracks = goodCount;
-  if (debug()) {
-    cout << "SKTF::extendTracksToVertices(...) -I- rawCount:"<<nTracks<<endl
-	 << "                                 extendedCount:"<<goodCount<<endl
-	 << "                                          plus:"<<plus<<endl
-	 << "                                         minus:"<<minus<<endl;
-  }
+   static const double RMAX2d = StiKalmanTrackFinderParameters::instance()->maxDca2dZeroXY();
+   static const double DMAX3d = StiKalmanTrackFinderParameters::instance()->maxDca3dVertex();
+
+   StiKalmanTrackNode *extended = 0;
+   int goodCount = 0, plus = 0, minus = 0;
+   int nTracks = _trackContainer->size();
+   int nVertex =         vertices.size();
+
+   if (!nVertex || !nTracks) return;
+
+   for (int iTrack = 0; iTrack < nTracks; iTrack++)		{
+      StiKalmanTrack *track = (StiKalmanTrack *)(*_trackContainer)[iTrack];
+      StiDebug::tally("Tracks");
+
+      StiKalmanTrackNode *bestNode = 0;
+      int bestVertex = 0;
+      StThreeVectorD nearBeam;
+      track->getNearBeam(&nearBeam);
+
+      if (nearBeam.perp2() > RMAX2d * RMAX2d) 		continue;
+
+      for (int iVertex = 0; iVertex < nVertex; iVertex++) {
+         StiHit *vertex = vertices[iVertex];
+
+         if (fabs(track->getDca(vertex)) > DMAX3d)    	continue;
+
+         StiDebug::tally("PrimCandidates");
+
+         if (mTimg[kPrimTimg]) mTimg[kPrimTimg]->Start(0);
+
+         extended = (StiKalmanTrackNode *)track->extendToVertex(vertex);
+
+         if (mTimg[kPrimTimg]) mTimg[kPrimTimg]->Stop();
+
+         if (!extended) 					continue;
+
+         StiDebug::tally("PrimExtended");
+
+         if (!bestNode) {bestNode = extended; bestVertex = iVertex + 1; continue;}
+
+         if (bestNode->getChi2() + log(bestNode->getDeterm())
+               < extended->getChi2() + log(extended->getDeterm()))continue;
+
+         BFactory::Free(bestNode);
+         bestNode = extended; bestVertex = iVertex + 1;
+      }//End vertex loop
+
+      if (!bestNode) 			continue;
+
+      track->add(bestNode, kOutsideIn);
+      track->setPrimary(bestVertex);
+      StiDebug::tally("PrimAdded");
+      int         ifail = 0;
+      static int REFIT = 2005;
+      bestNode->setUntouched();
+
+      if (REFIT) {
+         ifail = track->refit();
+         ifail |= (track->getInnerMostHitNode(3) != bestNode);
+      }
+
+      track->reduce();
+
+      // something is wrong. It is not a primary
+      if (ifail) { track->removeLastNode(); track->setPrimary(0); continue;}
+
+      goodCount++;
+      StiDebug::tally("PrimRefited");
+      if (track->getCharge() > 0) plus++; else minus++;
+
+   }//End track loop
+
+   _nPrimTracks = goodCount;
+
+   if (debug()) {
+      cout << "SKTF::extendTracksToVertices(...) -I- rawCount:" << nTracks << endl
+           << "                                 extendedCount:" << goodCount << endl
+           << "                                          plus:" << plus << endl
+           << "                                         minus:" << minus << endl;
+   }
 }
 
 /// Find extension (track) to the given track seed in the given direction
 /// Return Ok      if operation was successful
 //______________________________________________________________________________
-class StiKalmanTrackFinder::QAFind {
-public: 
-  double rmin;  //minimal radius allowed for search
-  double sum; 	//summ of chi2
-  int    hits;  //total number of hits
-  int    nits;  //total number of no hits
-  int    wits;  //total weight of precision hits
-  int    qa;	// quality flag for current level
-		//   qa =  1 == new hit accepted
-		//   qa =  0 == no hits was expected. dead material or edge
-		//   qa = -1 == hit expected but not found
-		//   qa = -2 == close to beam, stop processing of it
-		//   qa = -3 == fake track, stop processing of it
-		//   qa = -4 == track can not be continued, stop processing of it
-
-  	QAFind()		{reset();                  }
-void 	reset()			{rmin=0; sum=0; hits =0; nits=0; qa=0;wits=0;}
+class StiKalmanTrackFinder::QAFind
+{
+public:
+   double rmin;  //minimal radius allowed for search
+   double sum; 	//summ of chi2
+   int    hits;  //total number of hits
+   int    nits;  //total number of no hits
+   int    wits;  //total weight of precision hits
+   int    qa;	// quality flag for current level
+   //   qa =  1 == new hit accepted
+   //   qa =  0 == no hits was expected. dead material or edge
+   //   qa = -1 == hit expected but not found
+   //   qa = -2 == close to beam, stop processing of it
+   //   qa = -3 == fake track, stop processing of it
+   //   qa = -4 == track can not be continued, stop processing of it
+
+   QAFind()		{reset();                  }
+   void 	reset()			{rmin = 0; sum = 0; hits = 0; nits = 0; qa = 0; wits = 0;}
 };
 
 //______________________________________________________________________________
-bool StiKalmanTrackFinder::find(StiTrack * t, int direction,double rmin) // throws runtime_error, logic_error
+bool StiKalmanTrackFinder::find(StiTrack *t, int direction, double rmin) // throws runtime_error, logic_error
 {
-static int nCall=0; nCall++;
-  gLevelOfFind = 0;
-StiKalmanTrackNode::Break(nCall);
-  int nnBef,nnAft;
-  double lnBef,lnAft;
-  
-  if(direction) rmin=0; //no limitation to outside
-  StiKalmanTrack *track = dynamic_cast<StiKalmanTrack *> (t);
-  nnBef = track->getNNodes(3);
-  lnBef = track->getTrackLength();
-
-  StiKalmanTrackNode *leadNode = track->getInnOutMostNode(direction,2);
-  if (!leadNode) return 0;
-  leadNode->cutTail(direction);
-  assert(leadNode->isValid());
-  QAFind qa; qa.rmin = rmin;
-  mTrackPerm = kMaxTrackPerm;
-  mUseComb = useComb();
-  find(track,direction,leadNode,qa);
-
-  track->setFirstLastNode(leadNode);
-  nnAft = track->getNNodes(3);
-  lnAft = track->getTrackLength();
-  return (nnAft>nnBef || lnAft>(lnBef+0.5));
+   static int nCall = 0; nCall++;
+   gLevelOfFind = 0;
+   StiKalmanTrackNode::Break(nCall);
+   int nnBef, nnAft;
+   double lnBef, lnAft;
+
+   if (direction) rmin = 0; //no limitation to outside
+
+   StiKalmanTrack *track = dynamic_cast<StiKalmanTrack *> (t);
+   nnBef = track->getNNodes(3);
+   lnBef = track->getTrackLength();
+
+   StiKalmanTrackNode *leadNode = track->getInnOutMostNode(direction, 2);
+
+   if (!leadNode) return 0;
+
+   leadNode->cutTail(direction);
+   assert(leadNode->isValid());
+   QAFind qa; qa.rmin = rmin;
+   mTrackPerm = kMaxTrackPerm;
+   mUseComb = useComb();
+   find(track, direction, leadNode, qa);
+
+   track->setFirstLastNode(leadNode);
+   nnAft = track->getNNodes(3);
+   lnAft = track->getTrackLength();
+   return (nnAft > nnBef || lnAft > (lnBef + 0.5));
 }
 //______________________________________________________________________________
-void StiKalmanTrackFinder::find(StiKalmanTrack * track, int direction
-                              ,StiKalmanTrackNode *leadNode,QAFind &qa) 
+void StiKalmanTrackFinder::find(StiKalmanTrack *track, int direction
+                                , StiKalmanTrackNode *leadNode, QAFind &qa)
 {
-static int nCall=0; nCall++;
-StiKalmanTrackNode::Break(nCall);
-
-static const double degToRad = 3.1415927/180.;
-static const double radToDeg = 180./3.1415927;
-static const double ref1  = 50.*degToRad;
-//static  const double ref2  = 2.*3.1415927-ref1;
-static  const double ref1a  = 110.*degToRad;
-  //  const double ref2a  = 2.*3.1415927-ref1a;
-  gLevelOfFind++;
-  if (--mEventPerm <0) throw runtime_error("FATAL::TOO MANY permutations");
-  if (--mTrackPerm==0) { mUseComb = 0; }
-
-  StiDetector *tDet=0;
-  int status;
-  StiKalmanTrackNode testNode;
-  int position;
-  StiHit * stiHit;
-  double  leadAngle,leadRadius;
-
-  assert(leadNode->isValid());
-  const StiDetector *leadDet = leadNode->getDetector();
-  leadRadius = leadDet->getPlacement()->getNormalRadius();
-  assert(leadRadius>0 && leadRadius<1000);
-  if (leadRadius < qa.rmin) {gLevelOfFind--;return;}
-  leadAngle  = leadDet->getPlacement()->getNormalRefAngle();
-
-
-////  if ((!direction) && !nRefit && leadRadius <100 && track->getNNodes(3)>10) {
-////     nRefit++; track->refit(); if (!leadNode->isValid()) return 0;
-////  }
-  
-  
-  double xg = leadNode->x_g();
-  double yg = leadNode->y_g();
-  double projAngle = atan2(yg,xg);
-  if(debug() > 2)cout << "Projection Angle:"<<projAngle*180/3.1415<<endl;
-    
-  vector<StiDetectorNode*>::const_iterator layer;
-  vector<StiDetectorNode*>::const_reverse_iterator rlayer;
-
-  if ((!direction)) {
-    if (debug() > 2) cout <<endl<< "out-in"<<endl;
-    rlayer=_detectorContainer->rbeginRadial(leadDet); rlayer++;
-  } else {
-    if (debug() > 2) cout <<endl<< "in-out"<<endl;
-    layer=_detectorContainer->beginRadial(leadDet);    layer++;
-  }
-
-  if (debug() > 2) cout <<endl<< "lead node:" << *leadNode<<endl<<"lead det:"<<*leadDet<<endl;
-
-  
-  while (((!direction)? rlayer!=_detectorContainer->rendRadial() : layer!=_detectorContainer->endRadial()))
-  {do{//technical do
-    vector<StiDetectorNode*>::const_iterator sector;
-    vector<StiDetector*> detectors;
-    if (debug() > 2) cout << endl<<"lead node:" << *leadNode<<endl<<" lead det:"<<*leadDet;
-
-//#define PEREV
-
-      //find all relevant detectors to visit.
-    sector = (!direction)? _detectorContainer->beginPhi(rlayer):_detectorContainer->beginPhi(layer);
-    for ( ; (!direction)? sector!=_detectorContainer->endPhi(rlayer):sector!=_detectorContainer->endPhi(layer); ++sector)
-    {
-       StiDetector * detector = (*sector)->getData();
-       double angle  = detector->getPlacement()->getNormalRefAngle();
-       double radius = detector->getPlacement()->getNormalRadius();
-       assert(radius>0 && radius<1000);
-       if (radius < qa.rmin) {gLevelOfFind--;return;}
-       double diff = radius-leadRadius;if (!direction) diff = -diff;
-       if (diff<-1e-6 && debug()>3) {
-          LOG_DEBUG << Form("TrackFinder: Wrong order: (%s).(%g) and (%s).(%g)"
-	  ,leadDet->getName().c_str(),leadRadius 
-	  ,detector->getName().c_str(),radius) << endm;
-       }
-       
-       
-       Int_t shapeCode = detector->getShape()->getShapeCode();
-       Double_t OpenAngle = ref1;
-       if (shapeCode >= kCylindrical) {
-	 OpenAngle = ((StiCylindricalShape *) detector->getShape())->getOpeningAngle();
-       } else {
-	 if (radius <= 50 )  OpenAngle = ref1a;
-       }
-       diff = projAngle-angle;
-       if (diff >  M_PI) diff -= 2*M_PI;
-       if (diff < -M_PI) diff += 2*M_PI;
-       if (fabs(diff) > OpenAngle)	continue;
-       detectors.push_back(detector);
-    }
-
-    int nDets = detectors.size(); 
-    if (debug() > 2 && nDets==0) cout << "no detector of interest on this layer"<<endl;
-    if (!nDets) continue;
-    if (nDets>1) sort(detectors.begin(),detectors.end(),CloserAngle(projAngle) );
-    for (vector<StiDetector*>::const_iterator d=detectors.begin();d!=detectors.end();++d)
-    {
-      tDet = *d;
-      if (debug() > 2) {
-	cout << endl<< "target det:"<< *tDet;
-	cout << endl<< "lead angle:" << projAngle*radToDeg 
-	     <<" this angle:" << radToDeg*(*d)->getPlacement()->getNormalRefAngle()<<endl;
-      }
-      //begin tracking here...
-      testNode.reduce();testNode.reset();
-      testNode.setChi2(1e55);
-      position = testNode.propagate(leadNode,tDet,direction);
-      if (position == kEnded) { gLevelOfFind--; return;}
-      if (debug() > 2)  cout << "propagate returned:"<<position<<endl<< "testNode:"<<testNode;
-      if (position<0 || position>kEdgeZplus) { 
-	// not reaching this detector layer - stop track
-	if (debug() > 2) cout << "TRACK DOES NOT REACH CURRENT volume"<<endl;
-	if (debug() >= 1) StiKalmanTrackNode::PrintStep();
-	continue; // will try the next available volume on this layer
-      }
-      if (debug() > 2) cout << "position " << position << "<=kEdgeZplus";
-      assert(testNode.isValid());
-      testNode.setDetector(tDet);
-      int active = tDet->isActive(testNode.getY(),testNode.getZ());
-
-      if (debug() > 2) cout << " vol active:" << active<<endl;
-      double maxChi2 = tDet->getTrackingParameters()->getMaxChi2ForSelection();
-
-      StiHitContino hitCont;
-
-      if (active) {
-
-	if (debug() > 2)cout<<" search hits";
-	// active detector may have a hit
-	vector<StiHit*> & candidateHits = _hitContainer->getHits(testNode);//,true);
-	vector<StiHit*>::iterator hitIter;
-	if (debug() > 2) cout << " candidates:"<< candidateHits.size();
-        
-	for (hitIter=candidateHits.begin();hitIter!=candidateHits.end();++hitIter)
-	{
-	  stiHit = *hitIter;
-          if (stiHit->detector() && stiHit->detector()!=tDet) continue;
-          status = testNode.nudge(stiHit);
-          testNode.setReady();
-          if (status)		continue;
-	  chi2 = testNode.evaluateChi2(stiHit);
-	  if (debug() > 2)   cout<< " got chi2:"<< chi2 << " for hit:"<<*stiHit<<endl;
-	  if (chi2>maxChi2) 	continue;
-	  hitCont.add(stiHit,chi2,testNode.getDeterm());
-	  if (debug() > 2) cout << " hit selected"<<endl;
-	}// for (hitIter)
-      }//if(active)
-
-      int nHits = hitCont.getNHits();
-      assert(nHits<100);
-      testNode.setHitCand(nHits);
-      if (direction) {
-        nHits=1;
-      } else {
-        int flg = (testNode.getX()< kRMinTpc)? mUseComb &3:mUseComb>>2;
-        if ((flg&2) || !nHits) 	nHits++;
-        if ((flg&1)==0) 	nHits=1;
-        
-      }
+   static int nCall = 0; nCall++;
+   StiKalmanTrackNode::Break(nCall);
+
+   static const double degToRad = 3.1415927 / 180.;
+   static const double radToDeg = 180. / 3.1415927;
+   static const double ref1  = 50.*degToRad;
+   //static  const double ref2  = 2.*3.1415927-ref1;
+   static  const double ref1a  = 110.*degToRad;
+   //  const double ref2a  = 2.*3.1415927-ref1a;
+   gLevelOfFind++;
+
+   if (--mEventPerm < 0) throw runtime_error("FATAL::TOO MANY permutations");
+
+   if (--mTrackPerm == 0) { mUseComb = 0; }
+
+   StiDetector *tDet = 0;
+   int status;
+   StiKalmanTrackNode testNode;
+   int position;
+   StiHit *stiHit;
+   double  leadAngle, leadRadius;
+
+   assert(leadNode->isValid());
+   const StiDetector *leadDet = leadNode->getDetector();
+   leadRadius = leadDet->getPlacement()->getNormalRadius();
+   assert(leadRadius > 0 && leadRadius < 1000);
+
+   if (leadRadius < qa.rmin) {gLevelOfFind--; return;}
+
+   leadAngle  = leadDet->getPlacement()->getNormalRefAngle();
+
+
+   ////  if ((!direction) && !nRefit && leadRadius <100 && track->getNNodes(3)>10) {
+   ////     nRefit++; track->refit(); if (!leadNode->isValid()) return 0;
+   ////  }
+
+
+   double xg = leadNode->x_g();
+   double yg = leadNode->y_g();
+   double projAngle = atan2(yg, xg);
+
+   if (debug() > 2)cout << "Projection Angle:" << projAngle * 180 / 3.1415 << endl;
+
+   vector<StiDetectorNode *>::const_iterator layer;
+   vector<StiDetectorNode *>::const_reverse_iterator rlayer;
+
+   if ((!direction)) {
+      if (debug() > 2) cout << endl << "out-in" << endl;
+
+      rlayer = _detectorContainer->rbeginRadial(leadDet); rlayer++;
+   }
+   else {
+      if (debug() > 2) cout << endl << "in-out" << endl;
+
+      layer = _detectorContainer->beginRadial(leadDet);    layer++;
+   }
+
+   if (debug() > 2) cout << endl << "lead node:" << *leadNode << endl << "lead det:" << *leadDet << endl;
+
+
+   while (((!direction) ? rlayer != _detectorContainer->rendRadial() : layer != _detectorContainer->endRadial())) {
+      do {
+         //technical do
+         vector<StiDetectorNode *>::const_iterator sector;
+         vector<StiDetector *> detectors;
+
+         if (debug() > 2) cout << endl << "lead node:" << *leadNode << endl << " lead det:" << *leadDet;
+
+         //#define PEREV
+
+         //find all relevant detectors to visit.
+         sector = (!direction) ? _detectorContainer->beginPhi(rlayer) : _detectorContainer->beginPhi(layer);
+
+         for ( ; (!direction) ? sector != _detectorContainer->endPhi(rlayer) : sector != _detectorContainer->endPhi(layer); ++sector) {
+            StiDetector *detector = (*sector)->getData();
+            double angle  = detector->getPlacement()->getNormalRefAngle();
+            double radius = detector->getPlacement()->getNormalRadius();
+            assert(radius > 0 && radius < 1000);
+
+            if (radius < qa.rmin) {gLevelOfFind--; return;}
+
+            double diff = radius - leadRadius; if (!direction) diff = -diff;
+
+            if (diff < -1e-6 && debug() > 3) {
+               LOG_DEBUG << Form("TrackFinder: Wrong order: (%s).(%g) and (%s).(%g)"
+                                 , leadDet->getName().c_str(), leadRadius
+                                 , detector->getName().c_str(), radius) << endm;
+            }
+
 
-      QAFind qaBest,qaTry;
-      for (int jHit=0;jHit<nHits; jHit++)
-      {//Loop over Hits
-        stiHit = hitCont.getHit(jHit);
-	StiKalmanTrackNode * node = _trackNodeFactory->getInstance();
-	*node = testNode;
-        status = 0;
-        do {//fake do
-          if (!stiHit) break;
-          node->setIHitCand(jHit);
-          assert(node->getHitCand());
-          node->setHit(stiHit);
-          status = node->updateNode();
-          if (status)  break;
-          node->setChi2(hitCont.getChi2(jHit));
-          if (!direction && node->getX()< kRMinTpc) node->saveInfo(); //Save info for pulls 
-	  if (debug() > 0) {cout << Form("%5d ",status); StiKalmanTrackNode::PrintStep();}
-        }while(0);
-        if (status)  {_trackNodeFactory->free(node); continue;}
-
-        qaTry = qa;
-        nodeQA(node,position,active,qaTry);
-	leadNode->add(node,direction);
-        if (qaTry.qa>-2) find(track,direction,node,qaTry);
-        
-        if (jHit==0) { qaBest=qaTry; continue;}
-        int igor = compQA(qaBest,qaTry,maxChi2);
-        if (igor<0)  { leadNode->remove(0);}
-        else         { leadNode->remove(1);qaBest=qaTry;}
+            Int_t shapeCode = detector->getShape()->getShapeCode();
+            Double_t OpenAngle = ref1;
+
+            if (shapeCode >= kCylindrical) {
+               OpenAngle = ((StiCylindricalShape *) detector->getShape())->getOpeningAngle();
+            }
+            else {
+               if (radius <= 50 )  OpenAngle = ref1a;
+            }
+
+            diff = projAngle - angle;
+
+            if (diff >  M_PI) diff -= 2 * M_PI;
+
+            if (diff < -M_PI) diff += 2 * M_PI;
+
+            if (fabs(diff) > OpenAngle)	continue;
+
+            detectors.push_back(detector);
+         }
+
+         int nDets = detectors.size();
+
+         if (debug() > 2 && nDets == 0) cout << "no detector of interest on this layer" << endl;
+
+         if (!nDets) continue;
+
+         if (nDets > 1) sort(detectors.begin(), detectors.end(), CloserAngle(projAngle) );
+
+         for (vector<StiDetector *>::const_iterator d = detectors.begin(); d != detectors.end(); ++d) {
+            tDet = *d;
+
+            if (debug() > 2) {
+               cout << endl << "target det:" << *tDet;
+               cout << endl << "lead angle:" << projAngle *radToDeg
+                    << " this angle:" << radToDeg*(*d)->getPlacement()->getNormalRefAngle() << endl;
+            }
+
+            //begin tracking here...
+            testNode.reduce(); testNode.reset();
+            testNode.setChi2(1e55);
+            position = testNode.propagate(leadNode, tDet, direction);
+
+            if (position == kEnded) { gLevelOfFind--; return;}
+
+            if (debug() > 2)  cout << "propagate returned:" << position << endl << "testNode:" << testNode;
+
+            if (position < 0 || position > kEdgeZplus) {
+               // not reaching this detector layer - stop track
+               if (debug() > 2) cout << "TRACK DOES NOT REACH CURRENT volume" << endl;
+
+               if (debug() >= 1) StiKalmanTrackNode::PrintStep();
+
+               continue; // will try the next available volume on this layer
+            }
+
+            if (debug() > 2) cout << "position " << position << "<=kEdgeZplus";
+
+            assert(testNode.isValid());
+            testNode.setDetector(tDet);
+            int active = tDet->isActive(testNode.getY(), testNode.getZ());
+
+            if (debug() > 2) cout << " vol active:" << active << endl;
+
+            double maxChi2 = tDet->getTrackingParameters()->getMaxChi2ForSelection();
+
+            StiHitContino hitCont;
+
+            if (active) {
+
+               if (debug() > 2)cout << " search hits";
+
+               // active detector may have a hit
+               vector<StiHit *> &candidateHits = _hitContainer->getHits(testNode);//,true);
+               vector<StiHit *>::iterator hitIter;
+
+               if (debug() > 2) cout << " candidates:" << candidateHits.size();
+
+               for (hitIter = candidateHits.begin(); hitIter != candidateHits.end(); ++hitIter) {
+                  stiHit = *hitIter;
+
+                  if (stiHit->detector() && stiHit->detector() != tDet) continue;
+
+                  status = testNode.nudge(stiHit);
+                  testNode.setReady();
+
+                  if (status)		continue;
+
+                  chi2 = testNode.evaluateChi2(stiHit);
+
+                  if (debug() > 2)   cout << " got chi2:" << chi2 << " for hit:" << *stiHit << endl;
+
+                  if (chi2 > maxChi2) 	continue;
+
+                  hitCont.add(stiHit, chi2, testNode.getDeterm());
+
+                  if (debug() > 2) cout << " hit selected" << endl;
+               }// for (hitIter)
+            }//if(active)
+
+            int nHits = hitCont.getNHits();
+            assert(nHits < 100);
+            testNode.setHitCand(nHits);
+
+            if (direction) {
+               nHits = 1;
+            }
+            else {
+               int flg = (testNode.getX() < kRMinTpc) ? mUseComb & 3 : mUseComb >> 2;
+
+               if ((flg & 2) || !nHits) 	nHits++;
+
+               if ((flg & 1) == 0) 	nHits = 1;
+
+            }
+
+            QAFind qaBest, qaTry;
+
+            for (int jHit = 0; jHit < nHits; jHit++) {
+               //Loop over Hits
+               stiHit = hitCont.getHit(jHit);
+               StiKalmanTrackNode *node = _trackNodeFactory->getInstance();
+               *node = testNode;
+               status = 0;
+
+               do {//fake do
+                  if (!stiHit) break;
+
+                  node->setIHitCand(jHit);
+                  assert(node->getHitCand());
+                  node->setHit(stiHit);
+                  status = node->updateNode();
+
+                  if (status)  break;
+
+                  node->setChi2(hitCont.getChi2(jHit));
+
+                  if (!direction && node->getX() < kRMinTpc) node->saveInfo(); //Save info for pulls
+
+                  if (debug() > 0) {cout << Form("%5d ", status); StiKalmanTrackNode::PrintStep();}
+               }
+               while (0);
+
+               if (status)  {_trackNodeFactory->free(node); continue;}
+
+               qaTry = qa;
+               nodeQA(node, position, active, qaTry);
+               leadNode->add(node, direction);
+
+               if (qaTry.qa > -2) find(track, direction, node, qaTry);
+
+               if (jHit == 0) { qaBest = qaTry; continue;}
+
+               int igor = compQA(qaBest, qaTry, maxChi2);
+
+               if (igor < 0)  { leadNode->remove(0);}
+               else         { leadNode->remove(1); qaBest = qaTry;}
+            }
+
+            qa = qaBest; gLevelOfFind--; return;
+         }//End Detectors
       }
-      qa = qaBest; gLevelOfFind--; return;
-    }//End Detectors
-  }while(0);
-  if(!direction){++rlayer;}else{++layer;}}
-//end layers
-  gLevelOfFind--;
-  return;
+      while (0);
+
+      if (!direction) {++rlayer;}
+      else {++layer;}
+   }
+
+   //end layers
+   gLevelOfFind--;
+   return;
 }
 //______________________________________________________________________________
 void StiKalmanTrackFinder::nodeQA(StiKalmanTrackNode *node, int position
-                                 ,int active,QAFind &qa)
+                                  , int active, QAFind &qa)
 {
-  int maxNullCount           = StiKalmanTrackFinderParameters::instance()->maxNullCount()+3;
-  int maxContiguousNullCount = StiKalmanTrackFinderParameters::instance()->maxContiguousNullCount()+3;
-//		Check and count node
-  StiHit *hit = node->getHit();
-  if (hit) {
-    if (debug() > 2)cout << " got Hit! "<<endl ;
-//  const StiDetector *detector = hit->detector();
-    qa.sum += node->getChi2() + log(node->getDeterm());
-    qa.hits++; qa.qa=1;
-    if (node->getRxy() < kRMinTpc) {
-      qa.wits+=StiKalmanTrackFinderParameters::instance()->hitWeight((int)node->getRxy());
-    }
-    node->incHitCount();
-    node->incContigHitCount();
-
-    if (node->getContigHitCount()>StiKalmanTrackFinderParameters::instance()->minContiguousHitCountForNullReset())
-       node->setContigNullCount();
-
-  } else if (position>0 || !active) {// detectors edge - don't really expect a hit here
-    qa.qa=0;
-
-  } else {// there should have been a hit but we found none
-      if (debug() > 2) cout << " no hit but expected one"<<endl;
-      node->incNullCount(); 
+   int maxNullCount           = StiKalmanTrackFinderParameters::instance()->maxNullCount() + 3;
+   int maxContiguousNullCount = StiKalmanTrackFinderParameters::instance()->maxContiguousNullCount() + 3;
+   //		Check and count node
+   StiHit *hit = node->getHit();
+
+   if (hit) {
+      if (debug() > 2)cout << " got Hit! " << endl ;
+
+      //  const StiDetector *detector = hit->detector();
+      qa.sum += node->getChi2() + log(node->getDeterm());
+      qa.hits++; qa.qa = 1;
+
+      if (node->getRxy() < kRMinTpc) {
+         qa.wits += StiKalmanTrackFinderParameters::instance()->hitWeight((int)node->getRxy());
+      }
+
+      node->incHitCount();
+      node->incContigHitCount();
+
+      if (node->getContigHitCount() > StiKalmanTrackFinderParameters::instance()->minContiguousHitCountForNullReset())
+         node->setContigNullCount();
+
+   }
+   else if (position > 0 || !active) {// detectors edge - don't really expect a hit here
+      qa.qa = 0;
+
+   }
+   else {  // there should have been a hit but we found none
+      if (debug() > 2) cout << " no hit but expected one" << endl;
+
+      node->incNullCount();
       node->incContigNullCount();
       node->setContigHitCount();
-      qa.nits++; qa.qa=-1;
-      if (node->getNullCount()>maxNullCount) 			qa.qa= -3;
-      if (node->getContigNullCount()>maxContiguousNullCount)	qa.qa= -3;
-  }//node->getHit()
+      qa.nits++; qa.qa = -1;
+
+      if (node->getNullCount() > maxNullCount) 			qa.qa = -3;
 
-//  double xg = node->x_g();
-//  double yg = node->y_g();
-//VP??  if ((xg*xg + yg*yg) < 4.2*4.2) qa.qa= -2;
+      if (node->getContigNullCount() > maxContiguousNullCount)	qa.qa = -3;
+   }//node->getHit()
+
+   //  double xg = node->x_g();
+   //  double yg = node->y_g();
+   //VP??  if ((xg*xg + yg*yg) < 4.2*4.2) qa.qa= -2;
 
 }
 //______________________________________________________________________________
-int StiKalmanTrackFinder::compQA(QAFind &qaBest,QAFind &qaTry,double maxChi2)
+int StiKalmanTrackFinder::compQA(QAFind &qaBest, QAFind &qaTry, double maxChi2)
 {
    int ians;
-   ians = qaTry.wits-qaBest.wits;
-//	One SVT hit is worse than zero
+   ians = qaTry.wits - qaBest.wits;
+
+   //	One SVT hit is worse than zero
    if (!qaBest.wits &&  qaTry.wits &&  qaTry.wits < StiKalmanTrackFinderParameters::instance()->sumWeight()) return -1;
+
    if ( !qaTry.wits && qaBest.wits && qaBest.wits < StiKalmanTrackFinderParameters::instance()->sumWeight()) return  1;
-   				        if (ians)	return ians;
-   ians =  qaTry.hits-qaBest.hits;	if (ians)	return ians;
-   ians = qaBest.nits- qaTry.nits;	if (ians)	return ians;
+
+   if (ians)	return ians;
+
+   ians =  qaTry.hits - qaBest.hits;	if (ians)	return ians;
+
+   ians = qaBest.nits - qaTry.nits;	if (ians)	return ians;
+
    if (qaBest.sum  <= qaTry.sum ) 			return -1;
-   							return  1;
+
+   return  1;
 }
 
 //______________________________________________________________________________
-StiTrack * StiKalmanTrackFinder::findTrack(double rMin)
+StiTrack *StiKalmanTrackFinder::findTrack(double rMin)
 {
-assert(0);
-  StiTrack * track = 0;
-  try
-    {
+   assert(0);
+   StiTrack *track = 0;
+
+   try {
       if (!_trackSeedFinder) throw runtime_error("StiKalmanTrackFinder::findTrack() -E- No Track seed finder instance available");
+
       track = _trackSeedFinder->findTrack(rMin);
-      if (track)
-        {
-        track->find();
-        if (!_trackFilter || _trackFilter->filter(track) ) _trackContainer->push_back(track);
-        }
-    }
-  catch (runtime_error & rte)
-    {
-    cout << "StiKalmanTrackFinder::findTrack() - Run Time Error :\n" << rte.what() << endl;
-    }
-  return track;
+
+      if (track) {
+         track->find();
+
+         if (!_trackFilter || _trackFilter->filter(track) ) _trackContainer->push_back(track);
+      }
+   }
+   catch (runtime_error &rte) {
+      cout << "StiKalmanTrackFinder::findTrack() - Run Time Error :\n" << rte.what() << endl;
+   }
+
+   return track;
 }
 
 /*
@@ -813,170 +970,204 @@ assert(0);
 //______________________________________________________________________________
 void StiKalmanTrackFinder::setTiming()
 {
-  for (int it=0;it<(int)(sizeof(mTimg)/sizeof(mTimg[0]));it++){
-    mTimg[it]= new TStopwatch(); mTimg[it]->Stop();    } 
+   for (int it = 0; it < (int)(sizeof(mTimg) / sizeof(mTimg[0])); it++) {
+      mTimg[it] = new TStopwatch(); mTimg[it]->Stop();
+   }
 }
 //______________________________________________________________________________
 void StiKalmanTrackFinder::finish() const
 {
-static const char *timg[] = {"SeedFnd","TrakFnd","PrimFnd",0};
-  if (mTimg[0]) {
-    for (int i=0;timg[i];i++) {
-      Info("TrackFinder::Timing","%s(%d) \tCpuTime = %6.2f seconds,\tPerTrak = %g seconds"
-      ,timg[i],mTimg[i]->Counter(),mTimg[i]->CpuTime()
-      ,mTimg[i]->CpuTime()/mTimg[i]->Counter());    
-  } }
+   static const char *timg[] = {"SeedFnd", "TrakFnd", "PrimFnd", 0};
+
+   if (mTimg[0]) {
+      for (int i = 0; timg[i]; i++) {
+         Info("TrackFinder::Timing", "%s(%d) \tCpuTime = %6.2f seconds,\tPerTrak = %g seconds"
+              , timg[i], mTimg[i]->Counter(), mTimg[i]->CpuTime()
+              , mTimg[i]->CpuTime() / mTimg[i]->Counter());
+      }
+   }
 }
 //______________________________________________________________________________
-int StiKalmanTrackFinder::getNTracks() const 
+int StiKalmanTrackFinder::getNTracks() const
 { return _trackContainer->size();}
 
 //______________________________________________________________________________
 CloserAngle::CloserAngle(double refAngle)
-  : _refAngle(refAngle)
+   : _refAngle(refAngle)
 { }
 
 //______________________________________________________________________________
-bool CloserAngle::operator()(const StiDetector*lhs, const StiDetector* rhs)
+bool CloserAngle::operator()(const StiDetector *lhs, const StiDetector *rhs)
 {
-  double lhsa = lhs->getPlacement()->getNormalRefAngle();
-  double rhsa = rhs->getPlacement()->getNormalRefAngle();
-  double lhsda = fabs(lhsa-_refAngle); if (lhsda>3.1415) lhsda-=3.1415;
-  double rhsda = fabs(rhsa-_refAngle); if (rhsda>3.1415) rhsda-=3.1415;
-  return lhsda<rhsda;
+   double lhsa = lhs->getPlacement()->getNormalRefAngle();
+   double rhsa = rhs->getPlacement()->getNormalRefAngle();
+
+   double lhsda = fabs(lhsa - _refAngle); if (lhsda > 3.1415) lhsda -= 3.1415;
+
+   double rhsda = fabs(rhsa - _refAngle); if (rhsda > 3.1415) rhsda -= 3.1415;
+
+   return lhsda < rhsda;
 }
 #ifdef DO_TPCCATRACKER
-void StiKalmanTrackFinder::PrintFitStatus(const int status, const StiKalmanTrack* track) 
+void StiKalmanTrackFinder::PrintFitStatus(const int status, const StiKalmanTrack *track)
 {
-     // let's analyse the error
-   int status1 = status%100; // take only status of Fitter
-   int status1r = status/100;
+   // let's analyse the error
+   int status1 = status % 100; // take only status of Fitter
+   int status1r = status / 100;
+
    switch (status1) {
-     case StiKalmanTrackFinder::kNoErrors: {
-       if (track) cout << " fitted with " << track->getFitPointCount() << " hits."<< endl;
-       else cout << " fitted." << endl;
-     }
-       break;
-     case StiKalmanTrackFinder::kApproxFail: {
-       cout << " fit failed:" << endl;
-       cout << "      Initial approximation of track failed." << endl; 
-     }
-       break;
-     case StiKalmanTrackFinder::kFitFail: {
-       cout << " fit failed:" << endl;
-       cout << "      Track fit failed.";  
-       int status2 = status1r%100; // take only status of Fitter
-       switch (status2) {
-         case StiKalmanTrackFitter::kNoErrors: {
-           cout << " Check the code.";
-         }
-           break;
-         case StiKalmanTrackFitter::kShortTrackBeforeFit: {
-           cout << " Not enough hits in the track: ";
-         }
-           break;
-         case StiKalmanTrackFitter::kShortTrackAfterFit: {
-           if (track) cout << " Not enough hits can be fitted: " << track->getNNodes(3) << " .";
-           else cout << " Not enough hits can be fitted.";
+   case StiKalmanTrackFinder::kNoErrors: {
+      if (track) cout << " fitted with " << track->getFitPointCount() << " hits." << endl;
+      else cout << " fitted." << endl;
+   }
+   break;
+
+   case StiKalmanTrackFinder::kApproxFail: {
+      cout << " fit failed:" << endl;
+      cout << "      Initial approximation of track failed." << endl;
+   }
+   break;
+
+   case StiKalmanTrackFinder::kFitFail: {
+      cout << " fit failed:" << endl;
+      cout << "      Track fit failed.";
+      int status2 = status1r % 100; // take only status of Fitter
+
+      switch (status2) {
+      case StiKalmanTrackFitter::kNoErrors: {
+         cout << " Check the code.";
+      }
+      break;
+
+      case StiKalmanTrackFitter::kShortTrackBeforeFit: {
+         cout << " Not enough hits in the track: ";
+      }
+      break;
+
+      case StiKalmanTrackFitter::kShortTrackAfterFit: {
+         if (track) cout << " Not enough hits can be fitted: " << track->getNNodes(3) << " .";
+         else cout << " Not enough hits can be fitted.";
+      }
+      break;
+
+      case StiKalmanTrackFitter::kManyErrors: {
+         cout << " Too many problems with this track.";
+      }
+      break;
+      }
+
+      cout << endl;
+   }
+   break;
+
+   case StiKalmanTrackFinder::kExtendFail: {
+      cout << " fit failed: " << endl;
+      cout << "      Track extend failed.";
+      int status2 = status1r % 100; // take only status of Fitter
+      int status2r = status1r / 100;
+
+      switch (status2) {
+      case StiKalmanTrackFinder::kExtended: {
+         cout << " Check the code.";
+      }
+      break;
+
+      case StiKalmanTrackFinder::kNotExtended: {
+         cout << " Check the code.";
+      }
+      break;
+
+      case StiKalmanTrackFinder::kRefitInFail:
+      case StiKalmanTrackFinder::kRefitOutFail: {
+         cout << " Track can't be refitted after extension ";
+
+         if (status2 == StiKalmanTrackFinder::kRefitInFail) cout << "inside.";
+         else cout << "outside.";
+
+         int status3 = status2r % 100; // take only status of Fitter
+
+         switch (status3) { // TODO: make information more clear
+         case StiKalmanTrack::kNoErrors: {
+            cout << " Check the code.";
          }
-           break;
-         case StiKalmanTrackFitter::kManyErrors: {
-           cout << " Too many problems with this track.";
+         break;
+
+         case StiKalmanTrack::kRefitFail: {
+            cout << " Refit procedure fail.";
          }
-           break;
-       }
-       cout << endl;
-     }
-       break;
-     case StiKalmanTrackFinder::kExtendFail: {
-       cout << " fit failed: " << endl;
-       cout << "      Track extend failed.";
-       int status2 = status1r%100; // take only status of Fitter
-       int status2r = status1r/100;
-       switch (status2) {
-         case StiKalmanTrackFinder::kExtended: {
-           cout << " Check the code.";
+         break;
+
+         case StiKalmanTrack::kNotEnoughUsed: {
+            cout << " sTNH.getUsed() <= 3 .";
          }
-           break;
-         case StiKalmanTrackFinder::kNotExtended: {
-           cout << " Check the code.";
+         break;
+
+         case StiKalmanTrack::kInNodeNotValid: {
+            cout << " Inner most node is not valid.";
          }
-           break;
-         case StiKalmanTrackFinder::kRefitInFail:
-         case StiKalmanTrackFinder::kRefitOutFail: {
-           cout << " Track can't be refitted after extension ";
-           if (status2 == StiKalmanTrackFinder::kRefitInFail) cout << "inside.";
-           else cout << "outside.";
-
-           int status3 = status2r%100; // take only status of Fitter
-           switch (status3) { // TODO: make information more clear
-             case StiKalmanTrack::kNoErrors: {
-               cout << " Check the code.";
-             }
-               break;
-             case StiKalmanTrack::kRefitFail: {
-               cout << " Refit procedure fail.";
-             }
-               break;
-             case StiKalmanTrack::kNotEnoughUsed: {
-               cout << " sTNH.getUsed() <= 3 .";
-             }
-               break;
-             case StiKalmanTrack::kInNodeNotValid: {
-               cout << " Inner most node is not valid.";
-             }
-               break;
-             case StiKalmanTrack::kBadQA: {
-               cout << " qA is inappropriate.";
-             }
-               break;
-             case StiKalmanTrack::kVertexNodeInvalid: {
-               cout << " Prim node invalid.";
-             }
-               break;
-             case StiKalmanTrack::kNodeNotValid: {
-               cout << " Prim node Chi2 too big.";
-             }
-               break;
-             case StiKalmanTrack::kTooManyDroppedNodes: {
-               cout << " Too many dropped nodes.";
-             }
-               break;
-           }
-           
+         break;
+
+         case StiKalmanTrack::kBadQA: {
+            cout << " qA is inappropriate.";
          }
-           break;
-       }
-       cout << endl;       
-     }
-       break;
-     case StiKalmanTrackFinder::kCheckFail: {
-       cout << " fit failed " << endl;
-       cout << "      Track check failed.";
-       int status2 = status1r%100; // take only status of Fitter
-       switch (status2) {
-         case StiTrackFinderFilter::kNoErrors: {
-           cout << " Check the code.";
+         break;
+
+         case StiKalmanTrack::kVertexNodeInvalid: {
+            cout << " Prim node invalid.";
          }
-           break;
-         case StiTrackFinderFilter::kNoEnoughValidHits: {
-           if (track) cout << " Not enough valid hits in the track: " << track->getPointCount() << " .";
-           else cout << " Not enough valid hits in the track.";
+         break;
+
+         case StiKalmanTrack::kNodeNotValid: {
+            cout << " Prim node Chi2 too big.";
          }
-           break;
-         case StiTrackFinderFilter::kNoEnoughFittedValidHits: {
-           if (track) cout << " Not enough fitted hits in the track: " << track->getFitPointCount() << " .";
-           else cout << " Not enough fitted hits in the track.";
+         break;
+
+         case StiKalmanTrack::kTooManyDroppedNodes: {
+            cout << " Too many dropped nodes.";
          }
-           break;
-         case StiTrackFinderFilter::kWeird: {
-           cout << " Weird track, see StiTrackFinderFilter::accept().";
+         break;
          }
-           break;
-       }
-       cout << endl;
-     }
-       break;
+
+      }
+      break;
+      }
+
+      cout << endl;
+   }
+   break;
+
+   case StiKalmanTrackFinder::kCheckFail: {
+      cout << " fit failed " << endl;
+      cout << "      Track check failed.";
+      int status2 = status1r % 100; // take only status of Fitter
+
+      switch (status2) {
+      case StiTrackFinderFilter::kNoErrors: {
+         cout << " Check the code.";
+      }
+      break;
+
+      case StiTrackFinderFilter::kNoEnoughValidHits: {
+         if (track) cout << " Not enough valid hits in the track: " << track->getPointCount() << " .";
+         else cout << " Not enough valid hits in the track.";
+      }
+      break;
+
+      case StiTrackFinderFilter::kNoEnoughFittedValidHits: {
+         if (track) cout << " Not enough fitted hits in the track: " << track->getFitPointCount() << " .";
+         else cout << " Not enough fitted hits in the track.";
+      }
+      break;
+
+      case StiTrackFinderFilter::kWeird: {
+         cout << " Weird track, see StiTrackFinderFilter::accept().";
+      }
+      break;
+      }
+
+      cout << endl;
+   }
+   break;
    } // switch
 } // void StiKalmanTrackFinder::PrintFitStatus(const int status, const StiKalmanTrack* track)
 #endif /* DO_TPCCATRACKER */
diff --git a/Sti/StiKalmanTrackFinder.h b/Sti/StiKalmanTrackFinder.h
index 4ea4f62..ad7406d 100644
--- a/Sti/StiKalmanTrackFinder.h
+++ b/Sti/StiKalmanTrackFinder.h
@@ -1,11 +1,11 @@
 ///\File StiKalmanTrackFinder.h
-///\Author Claude A Pruneau (Wayne State U) 
+///\Author Claude A Pruneau (Wayne State U)
 #ifndef StiKalmanTrackFinder_H_INCLUDED
 #define StiKalmanTrackFinder_H_INCLUDED
 #include "Sti/StiTrackFinder.h"
 #include "Sti/Base/Named.h"
 #include "Sti/Base/Described.h"
-#ifdef DO_TPCCATRACKER 
+#ifdef DO_TPCCATRACKER
 class StiTPCCATrackerInterface;
 #endif /* DO_TPCCATRACKER */
 class TStopwatch;
@@ -22,124 +22,124 @@ class StiKalmanTrackNode;
 template<class Factorized>class Factory;
 
 
-///\class StiKalmanTrackFinder  
+///\class StiKalmanTrackFinder
 ///
-///\author  Claude Pruneau, Wayne State University                        
-///\date March 2001                                                    
+///\author  Claude Pruneau, Wayne State University
+///\date March 2001
 ///
 ///\note The Kalman Filter Code imbedded in this class was given
-///to us gracioulsy by Jouri Belikov from the ALICE       
-///collaboration. i.e. code reproduced with autorization. 
+///to us gracioulsy by Jouri Belikov from the ALICE
+///collaboration. i.e. code reproduced with autorization.
 ///
 class StiKalmanTrackFinder : public StiTrackFinder, public Named, public Described
 {
 public:
-  StiKalmanTrackFinder() {}
-  StiKalmanTrackFinder(StiToolkit *toolkit);
-  virtual ~StiKalmanTrackFinder() {}
-  /// Initialize the finder
-  virtual void initialize();
-  /// Set timing of tracking
-          void setTiming();
-  /// Find all tracks of the currently loaded event
-#ifdef DO_TPCCATRACKER 
-  virtual void findTpcTracks(StiTPCCATrackerInterface &caTrackerInt); 
-#endif /* DO_TPCCATRACKER */  
-  virtual void findAllTracks(); 
-  virtual void findTracks(); 
-  /// Find/extend the given track, in the given direction
-          bool find(StiTrack *track, int direction, double rmin=0);
-  /// Find the next track 
-  virtual StiTrack * findTrack(double rMin=0); 
-  /// Extend seeds to tracks
-  void extendSeeds (double rMin);
-  void extendTracks(double rMin);
-  /// Extend track
-  int extendTrack(StiKalmanTrack *track,double rMin);
-  /// Extent all tracks to the given vertex
-          void extendTracksToVertex(StiHit* vertex);
-          void extendTracksToVertices(const std::vector<StiHit*> &vertices);
-  /// get number of tracks
-  int getNTracks() const ;
-  int getNPrims()  const { return _nPrimTracks;}
-  /// Reset the tracker
-  virtual void reset();
-  virtual void unset(){}
-  
-  /// Clear the tracker
-  virtual void clear();
-  /// Finish the tracker
-  virtual void finish() const;
-  virtual Int_t Fit(StiKalmanTrack *track, Double_t rMin=0);
-  /// Get the track filter currently used by the tracker
-  virtual Filter<StiTrack> * getTrackFilter();
-  /// Get the vertex finder used by this track finder
-  void doInitLayer(int trackingDirection);
-  void doNextDetector();
-  void doFinishLayer();
-  void doFinishTrackSearch();
-  void doNextTrackStep();
-  static void setDebug(int m = 0) {_debug = m;}
-  static int  debug() {return _debug;}
+   StiKalmanTrackFinder() {}
+   StiKalmanTrackFinder(StiToolkit *toolkit);
+   virtual ~StiKalmanTrackFinder() {}
+   /// Initialize the finder
+   virtual void initialize();
+   /// Set timing of tracking
+   void setTiming();
+   /// Find all tracks of the currently loaded event
+#ifdef DO_TPCCATRACKER
+   virtual void findTpcTracks(StiTPCCATrackerInterface &caTrackerInt);
+#endif /* DO_TPCCATRACKER */
+   virtual void findAllTracks();
+   virtual void findTracks();
+   /// Find/extend the given track, in the given direction
+   bool find(StiTrack *track, int direction, double rmin = 0);
+   /// Find the next track
+   virtual StiTrack *findTrack(double rMin = 0);
+   /// Extend seeds to tracks
+   void extendSeeds (double rMin);
+   void extendTracks(double rMin);
+   /// Extend track
+   int extendTrack(StiKalmanTrack *track, double rMin);
+   /// Extent all tracks to the given vertex
+   void extendTracksToVertex(StiHit *vertex);
+   void extendTracksToVertices(const std::vector<StiHit *> &vertices);
+   /// get number of tracks
+   int getNTracks() const ;
+   int getNPrims()  const { return _nPrimTracks;}
+   /// Reset the tracker
+   virtual void reset();
+   virtual void unset() {}
+
+   /// Clear the tracker
+   virtual void clear();
+   /// Finish the tracker
+   virtual void finish() const;
+   virtual Int_t Fit(StiKalmanTrack *track, Double_t rMin = 0);
+   /// Get the track filter currently used by the tracker
+   virtual Filter<StiTrack> *getTrackFilter();
+   /// Get the vertex finder used by this track finder
+   void doInitLayer(int trackingDirection);
+   void doNextDetector();
+   void doFinishLayer();
+   void doFinishTrackSearch();
+   void doNextTrackStep();
+   static void setDebug(int m = 0) {_debug = m;}
+   static int  debug() {return _debug;}
 #ifdef DO_TPCCATRACKER
-  static void PrintFitStatus(const int status, const StiKalmanTrack* track); // print message according to the status value
-#endif /* DO_TPCCATRACKER */  
-  typedef enum{ // type of return value for the Fit() procedure
-    kNoErrors = 0,
-    kApproxFail,
-    kFitFail,
-    kExtendFail,
-    kCheckFail
-  } TFitStatus;
-
-  typedef enum{ // type of return value for the extendTrack() procedure
-    kExtended,
-    kNotExtended,
-    kRefitInFail,
-    kRefitOutFail
-  } TExtendStatus;
-
-  
+   static void PrintFitStatus(const int status, const StiKalmanTrack *track); // print message according to the status value
+#endif /* DO_TPCCATRACKER */
+   typedef enum { // type of return value for the Fit() procedure
+      kNoErrors = 0,
+      kApproxFail,
+      kFitFail,
+      kExtendFail,
+      kCheckFail
+   } TFitStatus;
+
+   typedef enum { // type of return value for the extendTrack() procedure
+      kExtended,
+      kNotExtended,
+      kRefitInFail,
+      kRefitOutFail
+   } TExtendStatus;
+
+
 private:
-class QAFind;
-  void find(StiKalmanTrack *track, int direction,StiKalmanTrackNode *node,QAFind &qa);
-  void nodeQA(StiKalmanTrackNode *node, int position,int active,QAFind &qa);
-  int  compQA(QAFind &qaBest,QAFind &qaTry,double maxChi2);
- 
- protected:
-
-    void printState();
-    StiToolkit                  * _toolkit;
-    Filter<StiTrack>            * _trackFilter;
-    StiTrackFinder              * _trackSeedFinder;
-    Factory<StiKalmanTrackNode> * _trackNodeFactory;
-    StiDetectorContainer        * _detectorContainer;
-    StiHitContainer             * _hitContainer;
-    StiTrackContainer           * _trackContainer;
-    int                           _nPrimTracks;
+   class QAFind;
+   void find(StiKalmanTrack *track, int direction, StiKalmanTrackNode *node, QAFind &qa);
+   void nodeQA(StiKalmanTrackNode *node, int position, int active, QAFind &qa);
+   int  compQA(QAFind &qaBest, QAFind &qaTry, double maxChi2);
+
+protected:
+
+   void printState();
+   StiToolkit                   *_toolkit;
+   Filter<StiTrack>             *_trackFilter;
+   StiTrackFinder               *_trackSeedFinder;
+   Factory<StiKalmanTrackNode> *_trackNodeFactory;
+   StiDetectorContainer         *_detectorContainer;
+   StiHitContainer              *_hitContainer;
+   StiTrackContainer            *_trackContainer;
+   int                           _nPrimTracks;
 private:
-        
-    double    chi2;
-    TStopwatch *mTimg[3]; 	//seeds,traks,prims
-    int         mTrackPerm;	//Count number of permutations
-    int         mEventPerm;	//Count number of permutations
-    int         mUseComb;	//useComb() saved 
-    static int   _debug;
+
+   double    chi2;
+   TStopwatch *mTimg[3]; 	//seeds,traks,prims
+   int         mTrackPerm;	//Count number of permutations
+   int         mEventPerm;	//Count number of permutations
+   int         mUseComb;	//useComb() saved
+   static int   _debug;
 };
 
-inline Filter<StiTrack> * StiKalmanTrackFinder::getTrackFilter() 
+inline Filter<StiTrack> *StiKalmanTrackFinder::getTrackFilter()
 {
-  return _trackFilter;
+   return _trackFilter;
 }
 
 
 class CloserAngle
 {
-  public:
-  CloserAngle(double refAngle);
-  bool operator()(const StiDetector*lhs, const StiDetector* rhs);
- protected:
-  double _refAngle;
+public:
+   CloserAngle(double refAngle);
+   bool operator()(const StiDetector *lhs, const StiDetector *rhs);
+protected:
+   double _refAngle;
 };
 
 #endif
diff --git a/Sti/StiKalmanTrackFitter.cxx b/Sti/StiKalmanTrackFitter.cxx
index 045dd45..2ea933d 100644
--- a/Sti/StiKalmanTrackFitter.cxx
+++ b/Sti/StiKalmanTrackFitter.cxx
@@ -9,101 +9,134 @@ Int_t StiKalmanTrackFitter::_debug = 0;
 /*! Fit given track with helicoical track model.
   <h3>Notes</h3>
 	<ol>
-  <li>The fit is performed along a direction (inside-out||outside-in) prescribed by 
+  <li>The fit is performed along a direction (inside-out||outside-in) prescribed by
       the value of the track flag "FittingDirection".</li>
   <li>In practice, the iteration through track nodes proceeds from first-to-last
       or last-to-first whether "trackingDirection==fitDirection"
-  <li>Use track node methods to do the actual propagation. 
-  <li>Node with no hits are allowed as the evaluation of the track chi2 
+  <li>Use track node methods to do the actual propagation.
+  <li>Node with no hits are allowed as the evaluation of the track chi2
       and updates are performed only if nodes hold a hit.
 	</ol>
 */
-Int_t StiKalmanTrackFitter::fit(StiTrack * stiTrack, Int_t fitDirection) //throw (Exception)
+Int_t StiKalmanTrackFitter::fit(StiTrack *stiTrack, Int_t fitDirection)  //throw (Exception)
 {
-  enum {kMaxNErr=333};
-  static Int_t nCall=0; nCall++;
-  StiKalmanTrackNode::Break(nCall);
-
-  if (debug() > 2) cout << "SKTFitter::fit() -I- Started:"<<endl;
-  StiKalmanTrack * track = dynamic_cast<StiKalmanTrack * >(stiTrack);
-  assert(track); 
-  StiHit * targetHit;
-  StiKalmanTrackNode * targetNode; // parent node
-  const StiDetector * targetDet;  // parent detector
-  
-  StiKTNBidirectionalIterator first;
-  StiKTNBidirectionalIterator last;
-  StiKTNBidirectionalIterator source;
-  Double_t chi2;
-  Int_t status = 0,nerr =0;
-  if (!fitDirection) {
-    first = track->begin();
-    last  = track->end();
-  } else {
-    last  = track->rend();
-    first = track->rbegin();
-  }
-  if (debug()) cout << "StiKalmanTrackFitter::fit direction = "  << fitDirection << endl;
-// 1st count number of accepted already good nodes
-  Int_t nGoodNodes = track->getNNodes(3);
-  if (nGoodNodes<3) 			return kShortTrackBeforeFit;
-
-
-  StiKalmanTrackNode *pNode = 0;
-  Int_t iNode=0; status = 0;
-  for (source=first;source!=last;source++) {
-    if (nerr>kMaxNErr) return nerr;
-    do { //do refit block
-      iNode++;
-      targetNode = &(*source);
-      targetDet = targetNode->getDetector();
-      targetHit = targetNode->getHit();
-      Double_t oldChi2 = targetNode->getChi2(); if(oldChi2){/*debugonly*/};
-      static Int_t myKount=0;myKount++;
-      if (!pNode && !targetNode->isValid()) continue;
-      //begin refit at first hit
-      status = 0;
-      if (pNode) {
-        targetNode->setChi2(1e51);
-	if (targetDet)
-	  status = targetNode->propagate(pNode,targetDet,fitDirection);	// hit
-	else if (targetHit)
-	  status = targetNode->propagate(pNode,targetHit,fitDirection);  // vertex
-	if (status)			{nerr++; continue;}
-      }
-      else  {
-	if (debug()) {
-	  targetNode->ResetComment(::Form("%30s start refit",targetDet->getName().c_str()));
-	  targetNode->PrintpT("S");}
-//        pNode = targetNode;		continue;
-        pNode = targetNode;		
+   enum {kMaxNErr = 333};
+   static Int_t nCall = 0; nCall++;
+   StiKalmanTrackNode::Break(nCall);
+
+   if (debug() > 2) cout << "SKTFitter::fit() -I- Started:" << endl;
+
+   StiKalmanTrack *track = dynamic_cast<StiKalmanTrack * >(stiTrack);
+   assert(track);
+   StiHit *targetHit;
+   StiKalmanTrackNode *targetNode;  // parent node
+   const StiDetector *targetDet;   // parent detector
+
+   StiKTNBidirectionalIterator first;
+   StiKTNBidirectionalIterator last;
+   StiKTNBidirectionalIterator source;
+   Double_t chi2;
+   Int_t status = 0, nerr = 0;
+
+   if (!fitDirection) {
+      first = track->begin();
+      last  = track->end();
+   }
+   else {
+      last  = track->rend();
+      first = track->rbegin();
+   }
+
+   if (debug()) cout << "StiKalmanTrackFitter::fit direction = "  << fitDirection << endl;
+
+   // 1st count number of accepted already good nodes
+   Int_t nGoodNodes = track->getNNodes(3);
+
+   if (nGoodNodes < 3) 			return kShortTrackBeforeFit;
+
+
+   StiKalmanTrackNode *pNode = 0;
+   Int_t iNode = 0; status = 0;
+
+   for (source = first; source != last; source++) {
+      if (nerr > kMaxNErr) return nerr;
+
+      do { //do refit block
+         iNode++;
+         targetNode = &(*source);
+         targetDet = targetNode->getDetector();
+         targetHit = targetNode->getHit();
+
+         Double_t oldChi2 = targetNode->getChi2(); if (oldChi2) {/*debugonly*/};
+
+         static Int_t myKount = 0; myKount++;
+
+         if (!pNode && !targetNode->isValid()) continue;
+
+         //begin refit at first hit
+         status = 0;
+
+         if (pNode) {
+            targetNode->setChi2(1e51);
+
+            if (targetDet)
+               status = targetNode->propagate(pNode, targetDet, fitDirection);	// hit
+            else if (targetHit)
+               status = targetNode->propagate(pNode, targetHit, fitDirection); // vertex
+
+            if (status)			{nerr++; continue;}
+         }
+         else  {
+            if (debug()) {
+               targetNode->ResetComment(::Form("%30s start refit", targetDet->getName().c_str()));
+               targetNode->PrintpT("S");
+            }
+
+            //        pNode = targetNode;		continue;
+            pNode = targetNode;
+         }
+
+         // target node has parameters now but not fitted
+         // if targetNode has hit, get chi2 and update track parameters accordingly
+         do {// Fit
+            targetNode->setChi2(0.);
+
+            if (!targetHit) 		break; //There is no hit.
+
+            assert(targetNode->getHit() == targetHit);
+            StiKalmanTrackNode tryNode = *targetNode;
+            targetNode->setChi2(1e52);
+
+            if (tryNode.nudge(targetHit))	{nerr++; break;}
+
+            chi2 = tryNode.evaluateChi2(targetHit);
+
+            if ((chi2 > StiKalmanTrackFitterParameters::instance()->getMaxChi2()))	{nerr++; break;}	//Chi2 is bad
+
+            status = tryNode.updateNode();
+
+            if (status) 			{nerr++; break;}
+
+            tryNode.setChi2(chi2);
+            {
+               //continue block
+               if (debug()) {cout << Form("%5d ", status); StiKalmanTrackNode::PrintStep();}
+            }//end continue block
+
+            *targetNode = tryNode;
+         }
+         while (0);//end fit block
+
+         pNode = targetNode;
       }
-// target node has parameters now but not fitted
-// if targetNode has hit, get chi2 and update track parameters accordingly
-      do {// Fit
-        targetNode->setChi2(0.);
-        if (!targetHit) 		break; //There is no hit.
-        assert(targetNode->getHit()==targetHit);
-        StiKalmanTrackNode tryNode = *targetNode;
-        targetNode->setChi2(1e52);
-        if (tryNode.nudge(targetHit))	{nerr++; break;}
-	chi2 = tryNode.evaluateChi2(targetHit);
-        if ((chi2>StiKalmanTrackFitterParameters::instance()->getMaxChi2()))	{nerr++; break;}	//Chi2 is bad
-        status = tryNode.updateNode();
-        if (status) 			{nerr++; break;}
-        tryNode.setChi2(chi2);
-	{ //continue block
-	  if (debug()) {cout << Form("%5d ",status); StiKalmanTrackNode::PrintStep();}
-	}//end continue block
-
-        *targetNode=tryNode;
-      }while(0);//end fit block
-      pNode = targetNode;
-    } while(0);//end refit block
-  }//end for of nodes
-  nGoodNodes = track->getNNodes(3);
-  if (nGoodNodes<3) return kShortTrackAfterFit;
-  return (nerr>kMaxNErr)? kManyErrors:0;
+      while (0); //end refit block
+   }//end for of nodes
+
+   nGoodNodes = track->getNNodes(3);
+
+   if (nGoodNodes < 3) return kShortTrackAfterFit;
+
+   return (nerr > kMaxNErr) ? kManyErrors : 0;
 }
 
 /*
@@ -115,7 +148,7 @@ Int_t StiKalmanTrackFitter::fit(StiTrack * stiTrack, Int_t fitDirection) //throw
 	      cout << " FIT != TRACKING --- Original Track" << endl;
 	      StiKTNForwardIterator it2(track->getLastNode());
 	      StiKTNForwardIterator end2 = it2.end();
-	      while (it2!=end2) 
+	      while (it2!=end2)
 		{
 		  const StiKalmanTrackNode& node2 = *it2;
 		  Double_t x_g = node2.x_g();
@@ -125,6 +158,6 @@ Int_t StiKalmanTrackFitter::fit(StiTrack * stiTrack, Int_t fitDirection) //throw
 		  ++it2;
 		}
 	      cout << " report done"<<endl;
-	      throw runtime_error("StiKalmanTrack::fit() -E- [1] targetNode==0"); 
+	      throw runtime_error("StiKalmanTrack::fit() -E- [1] targetNode==0");
 	    }
 */
diff --git a/Sti/StiKalmanTrackFitter.h b/Sti/StiKalmanTrackFitter.h
index f0e06df..e59c41e 100644
--- a/Sti/StiKalmanTrackFitter.h
+++ b/Sti/StiKalmanTrackFitter.h
@@ -5,28 +5,28 @@
 class StiTrack;
 class EditableParameters;
 
-///Class implements a kalman track fitter 
+///Class implements a kalman track fitter
 ///Based on the abstract interface StiTrackFitter
 ///Uses the fitting parameters carried by StiKalmanTrackFitterParameters
 class StiKalmanTrackFitter : public StiTrackFitter, public Named, public Described
 {
- public:
-  
-  StiKalmanTrackFitter() {}
-  virtual ~StiKalmanTrackFitter() {}
-  virtual Int_t fit(StiTrack * track, Int_t direction);
-  static  void setDebug(Int_t m = 0) {_debug = m;}
-  static  Int_t  debug() {return _debug;}
+public:
 
-  typedef enum{ // type of return value for the fit() procedure
-    kNoErrors = 0,
-    kShortTrackBeforeFit,
-    kShortTrackAfterFit,
-    kManyErrors
-  } TFitStatus;
-  
- protected:
-  static  Int_t _debug;
+   StiKalmanTrackFitter() {}
+   virtual ~StiKalmanTrackFitter() {}
+   virtual Int_t fit(StiTrack *track, Int_t direction);
+   static  void setDebug(Int_t m = 0) {_debug = m;}
+   static  Int_t  debug() {return _debug;}
+
+   typedef enum { // type of return value for the fit() procedure
+      kNoErrors = 0,
+      kShortTrackBeforeFit,
+      kShortTrackAfterFit,
+      kManyErrors
+   } TFitStatus;
+
+protected:
+   static  Int_t _debug;
 };
 
 #endif
diff --git a/Sti/StiKalmanTrackNode.cxx b/Sti/StiKalmanTrackNode.cxx
index 6648f43..766b193 100644
--- a/Sti/StiKalmanTrackNode.cxx
+++ b/Sti/StiKalmanTrackNode.cxx
@@ -444,7 +444,7 @@ using namespace std;
 // x[1] = z  position along beam axis
 // x[2] = (Psi)
 // x[3] = C  (local) curvature of the track
-// x[4] = tan(l) 
+// x[4] = tan(l)
 
 static const double kMaxEta = 1.25; // 72 degrees for laser tracks
 static const double kMaxSinEta = sin(kMaxEta);
@@ -452,43 +452,46 @@ static const double kMaxCur = 0.2;
 static const double kFarFromBeam = 10.;
 static const Double_t kMaxZ = 250;
 static const Double_t kMaxR = 250;
-StiNodeStat StiKalmanTrackNode::mgP; 
+StiNodeStat StiKalmanTrackNode::mgP;
 
 
-static const int    idx33[3][3] = {{0,1,3},{1,2,4},{3,4,5}};
-static const int    idx55[5][5] = 
-  {{0,1,3,6,10},{1,2,4,7,11},{3,4,5, 8,12},{6,7, 8, 9,13},{10,11,12,13,14}};
-static const int    idx55tpt[5][5] = 
-  {{0,1,2,3, 4},{1,5,6,7, 8},{2,6,9,10,11},{3,7,10,12,13},{ 4, 8,11,13,14}};
+static const int    idx33[3][3] = {{0, 1, 3}, {1, 2, 4}, {3, 4, 5}};
+static const int    idx55[5][5] =
+{{0, 1, 3, 6, 10}, {1, 2, 4, 7, 11}, {3, 4, 5, 8, 12}, {6, 7, 8, 9, 13}, {10, 11, 12, 13, 14}};
+static const int    idx55tpt[5][5] =
+{{0, 1, 2, 3, 4}, {1, 5, 6, 7, 8}, {2, 6, 9, 10, 11}, {3, 7, 10, 12, 13}, { 4, 8, 11, 13, 14}};
 
-static const int    idx66[6][6] =
-  {{ 0, 1, 3, 6,10,15},{ 1, 2, 4, 7,11,16},{ 3, 4, 5, 8,12,17}
-  ,{ 6, 7, 8, 9,13,18},{10,11,12,13,14,19},{15,16,17,18,19,20}};
+static const int    idx66[6][6] = {
+   { 0, 1, 3, 6, 10, 15}, { 1, 2, 4, 7, 11, 16}, { 3, 4, 5, 8, 12, 17}
+   , { 6, 7, 8, 9, 13, 18}, {10, 11, 12, 13, 14, 19}, {15, 16, 17, 18, 19, 20}
+};
 
 bool StiKalmanTrackNode::useCalculatedHitError = true;
 TString StiKalmanTrackNode::comment("Legend: \tE - extapolation\tM Multiple scattering\tV at Vertex\tB at beam\tR at Radius\tU Updated\n");
-TString StiKalmanTrackNode::commentdEdx(""); 
+TString StiKalmanTrackNode::commentdEdx("");
 //debug vars
 //#define STI_ERROR_TEST
 //#define STI_DERIV_TEST
 #ifdef STI_DERIV_TEST
-int    StiKalmanTrackNode::fDerivTestOn=0;   
+int    StiKalmanTrackNode::fDerivTestOn = 0;
 #endif
 #ifndef STI_DERIV_TEST
-int    StiKalmanTrackNode::fDerivTestOn=-10;   
+int    StiKalmanTrackNode::fDerivTestOn = -10;
 #endif
 
-double StiKalmanTrackNode::fDerivTest[kNPars][kNPars];   
-int gCurrShape=0;
+double StiKalmanTrackNode::fDerivTest[kNPars][kNPars];
+int gCurrShape = 0;
 
 void StiKalmanTrackNode::Break(int kase)
 {
-static int myBreak=-2005;
-if (kase!=myBreak) return;
-  LOG_DEBUG << Form("*** Break(%d) ***",kase)<< endm;
-}		
-/* bit mask for debug printout  
-   0   => 1 - covariance and propagate matrices 
+   static int myBreak = -2005;
+
+   if (kase != myBreak) return;
+
+   LOG_DEBUG << Form("*** Break(%d) ***", kase) << endm;
+}
+/* bit mask for debug printout
+   0   => 1 - covariance and propagate matrices
    1   => 2 - hit associated with the node
    2   => 4 - test matrix manipulation
    3   => 8 - test locate
@@ -498,55 +501,58 @@ int StiKalmanTrackNode::_laser = 0;
 
 //______________________________________________________________________________
 void StiKalmanTrackNode::reset()
-{ 
-static int myCount=0;
-  StiTrackNode::reset();
-  memset(_beg,0,_end-_beg+1);
-  _ext=0; _inf=0;
-  mId = ++myCount; 
-  mHz = 999;
-  Break(mId);
+{
+   static int myCount = 0;
+   StiTrackNode::reset();
+   memset(_beg, 0, _end - _beg + 1);
+   _ext = 0; _inf = 0;
+   mId = ++myCount;
+   mHz = 999;
+   Break(mId);
 }
 //______________________________________________________________________________
 void StiKalmanTrackNode::unset()
-{ 
-  reduce();
-  if (_inf) BFactory::Free(_inf); _inf=0;
+{
+   reduce();
+
+   if (_inf) BFactory::Free(_inf); _inf = 0;
 }
 //______________________________________________________________________________
 void StiKalmanTrackNode::resetError(double fak)
-{ 
-static const double DY=0.3,DZ=0.3,DEta=0.03,DPti=1.,DTan=0.05;
-
-  if (!fak) {
-    mFE.reset();
-    mFE._cYY=DY*DY;
-    mFE._cZZ=DZ*DZ;
-    mFE._cEE=DEta*DEta;
-    mFE._cPP=DPti*DPti;
-    mFE._cTT=DTan*DTan;
-  } else {
-    for (int i=0;i<kNErrs;i++) mFE.A[i] *=fak;
-  }  
-  mPE() = mFE;
+{
+   static const double DY = 0.3, DZ = 0.3, DEta = 0.03, DPti = 1., DTan = 0.05;
+
+   if (!fak) {
+      mFE.reset();
+      mFE._cYY = DY * DY;
+      mFE._cZZ = DZ * DZ;
+      mFE._cEE = DEta * DEta;
+      mFE._cPP = DPti * DPti;
+      mFE._cTT = DTan * DTan;
+   }
+   else {
+      for (int i = 0; i < kNErrs; i++) mFE.A[i] *= fak;
+   }
+
+   mPE() = mFE;
 }
 //_____________________________________________________________
-/// Set the Kalman state of this node to be identical 
+/// Set the Kalman state of this node to be identical
 /// to that of the given node.
 /// This method is useful to initial the state of a node
 /// while propagating a track.
 //______________________________________________________________________________
-void StiKalmanTrackNode::setState(const StiKalmanTrackNode * n)
+void StiKalmanTrackNode::setState(const StiKalmanTrackNode *n)
 {
-  _state   = n->_state;
-  _alpha    = n->_alpha;
-  mFP = n->mFP;
-  mFE = n->mFE;
-  mFP.hz()=0;
-  nullCount = n->nullCount;
-  contiguousHitCount = n->contiguousHitCount;
-  contiguousNullCount = n->contiguousNullCount;
-  setChi2(1e62);  
+   _state   = n->_state;
+   _alpha    = n->_alpha;
+   mFP = n->mFP;
+   mFE = n->mFE;
+   mFP.hz() = 0;
+   nullCount = n->nullCount;
+   contiguousHitCount = n->contiguousHitCount;
+   contiguousNullCount = n->contiguousNullCount;
+   setChi2(1e62);
 }
 
 /**
@@ -558,17 +564,17 @@ void StiKalmanTrackNode::setState(const StiKalmanTrackNode * n)
    double& chi2) : chi2 of the track at this node
 */
 //______________________________________________________________________________
-void StiKalmanTrackNode::get(double& alpha,
-			     double& xRef,
-			     double  x[kNPars], 
-			     double  e[kNErrs], 
-			     double& chi2)
+void StiKalmanTrackNode::get(double &alpha,
+                             double &xRef,
+                             double  x[kNPars],
+                             double  e[kNErrs],
+                             double &chi2)
 {
-  alpha = _alpha;
-  xRef  = getRefPosition();
-  memcpy(x,mFP.P,kNPars*sizeof(mFP.x()));
-  memcpy(e,mFE.A,sizeof(mFE));
-  chi2 = getChi2();
+   alpha = _alpha;
+   xRef  = getRefPosition();
+   memcpy(x, mFP.P, kNPars * sizeof(mFP.x()));
+   memcpy(e, mFE.A, sizeof(mFE));
+   chi2 = getChi2();
 }
 
 //______________________________________________________________________________
@@ -577,39 +583,45 @@ void StiKalmanTrackNode::get(double& alpha,
   Calculate the track transverse momentum in GeV/c based on this node's track parameters.
   <p>
   The momentum is calculated based on the track curvature held by this node. A minimum
-  curvature of 1e-12 is allowed. 
+  curvature of 1e-12 is allowed.
 */
 //______________________________________________________________________________
 double StiKalmanTrackNode::getPt() const
 {
-  return (fabs(mFP.ptin())<1e-3) ? 1e3: 1./fabs(mFP.ptin());
+   return (fabs(mFP.ptin()) < 1e-3) ? 1e3 : 1. / fabs(mFP.ptin());
 }
 //______________________________________________________________________________
 void StiKalmanTrackNode::propagateCurv(const StiKalmanTrackNode *parent)
 {
-   mFP.ptin()=parent->mFP.ptin();
-   mFP.curv()=getHz()*mFP.ptin();
-} 
+   mFP.ptin() = parent->mFP.ptin();
+   mFP.curv() = getHz() * mFP.ptin();
+}
 //______________________________________________________________________________
-/*! Calculate/return the z component of mag field 
+/*! Calculate/return the z component of mag field
   <p>
   Calculate/return the z component of mag field
   <p>
-  Field is calcualated via StarMagField class and cashed. 
+  Field is calcualated via StarMagField class and cashed.
 */
 //______________________________________________________________________________
 double StiKalmanTrackNode::getHz() const
 {
-  
-static const double EC = 2.99792458e-4,ZEROHZ = 2e-6;
-   if (mHz<999) return mHz;
+
+   static const double EC = 2.99792458e-4, ZEROHZ = 2e-6;
+
+   if (mHz < 999) return mHz;
+
    if (! _laser) {
-     double h[3];
-     StarMagField::Instance()->BField(&(getGlobalPoint().x()),h);
-     h[2] = EC*h[2];
-     if (fabs(h[2]) < ZEROHZ) h[2]=0;
-     mHz = h[2];
-   } else mHz = 0;
+      double h[3];
+      StarMagField::Instance()->BField(&(getGlobalPoint().x()), h);
+      h[2] = EC * h[2];
+
+      if (fabs(h[2]) < ZEROHZ) h[2] = 0;
+
+      mHz = h[2];
+   }
+   else mHz = 0;
+
    return mHz;
 }
 //______________________________________________________________________________
@@ -617,7 +629,7 @@ static const double EC = 2.99792458e-4,ZEROHZ = 2e-6;
   <p>
   Calculate the 3-momentum of the track in the local reference frame.
   <P>
-    
+
   <h3>Momentum Representation</h3>
   <TABLE BORDER="0" CELLPADDING="2" CELLSPACING="0" WIDTH="100%">
   <TR>
@@ -644,101 +656,112 @@ static const double EC = 2.99792458e-4,ZEROHZ = 2e-6;
 */
 //______________________________________________________________________________
 void StiKalmanTrackNode::getMomentum(double p[3], double e[6]) const
-{	
-//	keep in mind that _eta == CA
-//	keep in mind that pt == SomeCoef/rho
-enum {jX=0,jY,jZ,jE,jP,jT};
-
-  double pt = getPt();
-  p[0] = pt*mFP._cosCA;
-  p[1] = pt*mFP._sinCA;
-  p[2] = pt*mFP.tanl();
-
-// 		if e==0, error calculation is not needed, then return
-  if (!e) return;
-
-  double F[3][kNPars]; memset(F,0,sizeof(F));
-  double dPtdPi = -pt*pt; if (mFP.ptin()<0) dPtdPi=-dPtdPi;
-  F[jX][jE] = -pt    *mFP._sinCA;
-  F[jX][jP] =  dPtdPi*mFP._cosCA;
-  F[jX][jT] =  0;
-
-  F[jY][jE] =  pt    *mFP._cosCA;
-  F[jY][jP] =  dPtdPi*mFP._sinCA;
-  F[jY][jT] =  0;
-  
-  F[jZ][jE] =  0;
-  F[jZ][jP] =  dPtdPi*mFP.tanl();
-  F[jZ][jT] =  pt;
-  
-  
-  TCL::trasat(F[0],mFE.A,e,3,kNPars);  
+{
+   //	keep in mind that _eta == CA
+   //	keep in mind that pt == SomeCoef/rho
+   enum {jX = 0, jY, jZ, jE, jP, jT};
+
+   double pt = getPt();
+   p[0] = pt * mFP._cosCA;
+   p[1] = pt * mFP._sinCA;
+   p[2] = pt * mFP.tanl();
+
+   // 		if e==0, error calculation is not needed, then return
+   if (!e) return;
+
+   double F[3][kNPars]; memset(F, 0, sizeof(F));
+
+   double dPtdPi = -pt * pt; if (mFP.ptin() < 0) dPtdPi = -dPtdPi;
+
+   F[jX][jE] = -pt    * mFP._sinCA;
+   F[jX][jP] =  dPtdPi * mFP._cosCA;
+   F[jX][jT] =  0;
+
+   F[jY][jE] =  pt    * mFP._cosCA;
+   F[jY][jP] =  dPtdPi * mFP._sinCA;
+   F[jY][jT] =  0;
+
+   F[jZ][jE] =  0;
+   F[jZ][jP] =  dPtdPi * mFP.tanl();
+   F[jZ][jT] =  pt;
+
+
+   TCL::trasat(F[0], mFE.A, e, 3, kNPars);
 }
 //______________________________________________________________________________
 /**
    returns the node information
    double x[6],  : state, for a definition, in radial implementation
                    rad  - radius at start (cm). See also comments
-                   phi  - azimuthal angle  (in rad)      
-                   z    - z-coord. (cm)                 
-                   psi  - azimuthal angle of pT vector (in rads)     
-                   tanl - tan(dip) =pz/pt               
-                   curv - Track curvature (1/cm) 
+                   phi  - azimuthal angle  (in rad)
+                   z    - z-coord. (cm)
+                   psi  - azimuthal angle of pT vector (in rads)
+                   tanl - tan(dip) =pz/pt
+                   curv - Track curvature (1/cm)
    double cc[15] : error matrix of the state "x" rad is fixed
                        code definition adopted here, where:
    PhiPhi;
-   ZPhi     ,ZZ;                       
-   TanlPhi  ,TanlZ ,TanlTanl,                 
-   PsiPhi   ,PsiZ  ,PsiTanl , PsiPsi ,           
-   CurvPhi  ,CurvZ ,CurvTanl, CurvPsi, CurvCurv     
+   ZPhi     ,ZZ;
+   TanlPhi  ,TanlZ ,TanlTanl,
+   PsiPhi   ,PsiZ  ,PsiTanl , PsiPsi ,
+   CurvPhi  ,CurvZ ,CurvTanl, CurvPsi, CurvCurv
 
 */
 //______________________________________________________________________________
-void StiKalmanTrackNode::getGlobalRadial(double  x[6],double  e[15])
+void StiKalmanTrackNode::getGlobalRadial(double  x[6], double  e[15])
 {
-  enum {jRad=0,jPhi,jZ,jTan,jPsi,jCur, kX=0,kY,kZ,kE,kC,kT};
-  double alpha,xRef,chi2;
-  double xx[kNPars],ee[kNErrs];
-
-  get(alpha,xRef,xx,ee,chi2);
-  
-  x[jRad] = sqrt(pow(xx[kX],2)+pow(xx[kY],2));
-  x[jPhi] = atan2(xx[kY],xx[kX]) + alpha;
-  x[jZ  ] = xx[kZ];
-  x[jTan] = xx[kT];
-  x[jPsi] = xx[kE] + alpha;
-  x[jCur] = xx[kC];
-  if (!e) return;
-
-  double F[kNErrs][kNErrs]; memset(F,0,sizeof(F));
-  F[jPhi][kX] = -1e5;
-  F[jPhi][kY] =  1e5;
-  if (fabs(xx[kY])>1e-5)  F[jPhi][kX] = -1./(xx[kY]);
-  if (fabs(xx[kX])>1e-5)  F[jPhi][kY] =  1./(xx[kX]);
-  F[jZ][kZ]   = 1.;
-  F[jTan][kT] = 1;
-  F[jPsi][kE] = 1;
-  F[jCur][kC] = 1;
-  memset(e,0,sizeof(*e)*15);
-  for (int k1=0;k1<kNPars;k1++) {
-  for (int k2=0;k2<kNPars;k2++) {
-    double cc = mFE.A[idx66[k1][k2]];    
-    for (int j1=jPhi;j1<= 5;j1++){
-    for (int j2=jPhi;j2<=j1;j2++){
-      e[idx55[j1-1][j2-1]]+= cc*F[j1][k1]*F[j2][k2];
-  }}}}    
-  
+   enum {jRad = 0, jPhi, jZ, jTan, jPsi, jCur, kX = 0, kY, kZ, kE, kC, kT};
+   double alpha, xRef, chi2;
+   double xx[kNPars], ee[kNErrs];
+
+   get(alpha, xRef, xx, ee, chi2);
+
+   x[jRad] = sqrt(pow(xx[kX], 2) + pow(xx[kY], 2));
+   x[jPhi] = atan2(xx[kY], xx[kX]) + alpha;
+   x[jZ  ] = xx[kZ];
+   x[jTan] = xx[kT];
+   x[jPsi] = xx[kE] + alpha;
+   x[jCur] = xx[kC];
+
+   if (!e) return;
+
+   double F[kNErrs][kNErrs]; memset(F, 0, sizeof(F));
+   F[jPhi][kX] = -1e5;
+   F[jPhi][kY] =  1e5;
+
+   if (fabs(xx[kY]) > 1e-5)  F[jPhi][kX] = -1. / (xx[kY]);
+
+   if (fabs(xx[kX]) > 1e-5)  F[jPhi][kY] =  1. / (xx[kX]);
+
+   F[jZ][kZ]   = 1.;
+   F[jTan][kT] = 1;
+   F[jPsi][kE] = 1;
+   F[jCur][kC] = 1;
+   memset(e, 0, sizeof(*e) * 15);
+
+   for (int k1 = 0; k1 < kNPars; k1++) {
+      for (int k2 = 0; k2 < kNPars; k2++) {
+         double cc = mFE.A[idx66[k1][k2]];
+
+         for (int j1 = jPhi; j1 <= 5; j1++) {
+            for (int j2 = jPhi; j2 <= j1; j2++) {
+               e[idx55[j1 - 1][j2 - 1]] += cc * F[j1][k1] * F[j2][k2];
+            }
+         }
+      }
+   }
+
 }
 //______________________________________________________________________________
 /**
    returns the node information in TPT representation
    double x[6],  : state, for a definition, in radial implementation
                    rad  - radius at start (cm). See also comments
-                   phi  - azimuthal angle  (in rad)      
-                   z    - z-coord. (cm)                 
-                   psi  - azimuthal angle of pT vector (in rads)     
-                   tanl - tan(dip) =pz/pt               
-                   q/pt -  
+                   phi  - azimuthal angle  (in rad)
+                   z    - z-coord. (cm)
+                   psi  - azimuthal angle of pT vector (in rads)
+                   tanl - tan(dip) =pz/pt
+                   q/pt -
    double cc[15] : error matrix of the state "x" rad is fixed
                        code definition adopted here, where:
 
@@ -753,7 +776,7 @@ void StiKalmanTrackNode::getGlobalRadial(double  x[6],double  e[15])
 
                        and where phi  = atan2(y0,x0)*(180 deg/pi)
                                  R    = sqrt(x0*x0 + y0*y0)
-                                 q/pt = icharge*invpt; (This is what the 
+                                 q/pt = icharge*invpt; (This is what the
                                         radius of curvature actually
                                         determines)
 PhiPhi PhiZ PhiTan PhiPsi PhiPt
@@ -763,44 +786,46 @@ PhiPhi PhiZ PhiTan PhiPsi PhiPt
 		           PtPt
 */
 //______________________________________________________________________________
-void StiKalmanTrackNode::getGlobalTpt(float  x[6],float  e[15])
+void StiKalmanTrackNode::getGlobalTpt(float  x[6], float  e[15])
 {
-  enum {jRad=0,jPhi,jZ,jTan,jPsi,jCur,jPt=jCur};
-static const double DEG = 180./M_PI;
-static       double fak[6] = {1,0,1,1,DEG,0};
+   enum {jRad = 0, jPhi, jZ, jTan, jPsi, jCur, jPt = jCur};
+   static const double DEG = 180. / M_PI;
+   static       double fak[6] = {1, 0, 1, 1, DEG, 0};
+
+   double xx[6], ee[15];
+   getGlobalRadial(xx, ee);
+   double pt = getPt();
+   fak[jPhi] = DEG * xx[jRad];
+   fak[jPt] = (double(getCharge()) / pt) / xx[jCur];
 
-  double xx[6],ee[15];
-  getGlobalRadial(xx,ee);
-  double pt = getPt();
-  fak[jPhi] = DEG*xx[jRad];
-  fak[jPt] = (double(getCharge())/pt)/xx[jCur];
+   for (int i = 0; i < 6; i++) {x[i] = (float)(fak[i] * xx[i]);}
 
-  for (int i=0;i<6;i++) {x[i] = (float)(fak[i]*xx[i]);}
-  if (!e) return;
+   if (!e) return;
 
-  for (int j1=jPhi;j1<= 5;j1++){
-  for (int j2=jPhi;j2<=j1;j2++){
-    e[idx55tpt[j1-1][j2-1]] = (float)fak[j1]*fak[j2]*ee[idx55[j1-1][j2-1]];
-  }}
+   for (int j1 = jPhi; j1 <= 5; j1++) {
+      for (int j2 = jPhi; j2 <= j1; j2++) {
+         e[idx55tpt[j1 - 1][j2 - 1]] = (float)fak[j1] * fak[j2] * ee[idx55[j1 - 1][j2 - 1]];
+      }
+   }
 
 }
 //______________________________________________________________________________
 double StiKalmanTrackNode::getPhase() const
 {
-  //! This function translates between ITTF helix parameters and
-  //! StHelixModel phi. It is only used to fill StTrackGeometry.
-  //! For a StPhysicalHelix, phi must be transformed by -h*pi/2.
-  return getPsi()-getHelicity()*M_PI/2;
+   //! This function translates between ITTF helix parameters and
+   //! StHelixModel phi. It is only used to fill StTrackGeometry.
+   //! For a StPhysicalHelix, phi must be transformed by -h*pi/2.
+   return getPsi() - getHelicity() * M_PI / 2;
 
 }
 //______________________________________________________________________________
 double StiKalmanTrackNode::getPsi() const
 {
-  return nice(mFP.eta()+_alpha);
+   return nice(mFP.eta() + _alpha);
 }
 
 //______________________________________________________________________________
-/// returns momentum and its error matrix 
+/// returns momentum and its error matrix
 /// in cartesian coordinates in the _global_
 /// ref frame of the experiment
 /// p[0] = px
@@ -816,39 +841,40 @@ double StiKalmanTrackNode::getPsi() const
 
 //______________________________________________________________________________
 void StiKalmanTrackNode::getGlobalMomentum(double p[3], double e[6]) const
-{	
-  // first get p & e in the local ref frame
-  enum {jXX=0,jXY,jYY};
-  
-  getMomentum(p,e);
-  // now rotate the p & e in the global ref frame
-  // for the time being, assume an azimuthal rotation 
-  // by alpha is sufficient.
-  // transformation matrix - needs to be set
-  double px=p[0];
-  double py=p[1];
-  double cosAlpha = cos(_alpha);
-  double sinAlpha = sin(_alpha);
-  p[0] = cosAlpha*px - sinAlpha*py;
-  p[1] = sinAlpha*px + cosAlpha*py;
-  if (e==0) return;
-
-    // original error matrix
-
-  double cXX = e[jXX];
-  double cXY = e[jXY];
-  double cYY = e[jYY];
-  double cc = cosAlpha*cosAlpha;
-  double ss = sinAlpha*sinAlpha;
-  double cs = cosAlpha*sinAlpha;
-  e[jXX] = cc*cXX -   2.*cs*cXY + ss*cYY;
-  e[jYY] = ss*cXX +   2.*cs*cXY + cc*cYY;
-  e[jXY] = cs*cXX + (cc-ss)*cXY - cs*cYY;
+{
+   // first get p & e in the local ref frame
+   enum {jXX = 0, jXY, jYY};
+
+   getMomentum(p, e);
+   // now rotate the p & e in the global ref frame
+   // for the time being, assume an azimuthal rotation
+   // by alpha is sufficient.
+   // transformation matrix - needs to be set
+   double px = p[0];
+   double py = p[1];
+   double cosAlpha = cos(_alpha);
+   double sinAlpha = sin(_alpha);
+   p[0] = cosAlpha * px - sinAlpha * py;
+   p[1] = sinAlpha * px + cosAlpha * py;
+
+   if (e == 0) return;
+
+   // original error matrix
+
+   double cXX = e[jXX];
+   double cXY = e[jXY];
+   double cYY = e[jYY];
+   double cc = cosAlpha * cosAlpha;
+   double ss = sinAlpha * sinAlpha;
+   double cs = cosAlpha * sinAlpha;
+   e[jXX] = cc * cXX -   2.*cs * cXY + ss * cYY;
+   e[jYY] = ss * cXX +   2.*cs * cXY + cc * cYY;
+   e[jXY] = cs * cXX + (cc - ss) * cXY - cs * cYY;
 }
 
 
 //______________________________________________________________________________
-/*! Steering routine that propagates the track encapsulated by the given node "pNode" to the given detector "tDet". 
+/*! Steering routine that propagates the track encapsulated by the given node "pNode" to the given detector "tDet".
 	<p>
 	The propagation involves the following steps.
  <OL>
@@ -863,59 +889,72 @@ void StiKalmanTrackNode::getGlobalMomentum(double p[3], double e[6]) const
  <p>Currently, propagate can handle kPlanar and kCylindrical geometries only. An exception is thrown if other geometry shape are used.
 */
 //______________________________________________________________________________
-int StiKalmanTrackNode::propagate(StiKalmanTrackNode *pNode, 
-				  const StiDetector * tDet,int dir)
+int StiKalmanTrackNode::propagate(StiKalmanTrackNode *pNode,
+                                  const StiDetector *tDet, int dir)
 {
-static int nCall=0; nCall++;
-Break(nCall);
-  int position = 0;
-  setState(pNode);
-  setDetector(tDet);
-  if (debug()) ResetComment(::Form("%30s ",tDet->getName().c_str()));
-
-  StiPlacement * place = tDet->getPlacement();
-//double nLayerRadius  = place->getLayerRadius ();
-  double nNormalRadius = place->getNormalRadius();
-
-  StiShape * sh = tDet->getShape();
-  int shapeCode = sh->getShapeCode();
-  double endVal,dAlpha;
-  switch (shapeCode) {
-
-  case kPlanar: endVal = nNormalRadius;
-    { //flat volume
-      dAlpha = place->getNormalRefAngle();
-      dAlpha = nice(dAlpha - _alpha);
-      // bail out if the rotation fails...
-      position = rotate(dAlpha);
-      if (position) 			return -10;
-    }
-    					break;
-  case kDisk:  							
-  case kCylindrical: endVal = nNormalRadius;
-    {
-      double xy[4];
-      position = cylCross(endVal,&mFP._cosCA,mFP.curv(),xy);
-      if (position) 			return -11;
-      dAlpha = atan2(xy[1],xy[0]);
-      position = rotate(dAlpha);
-      if (position) 			return -11;
-    }
-   					break;
-  default: assert(0);
-  }
-
-  position = propagate(endVal,shapeCode,dir); 
-
-  if (position>kEdgeZplus || position<0) return position;
-  propagateError();
-  if (debug() & 8) { PrintpT("E");}
-
-  // Multiple scattering
-  if (StiKalmanTrackFinderParameters::instance()->mcsCalculated() && getHz())  
-    propagateMCS(pNode,tDet);
-  if (debug() & 8) { PrintpT("M");}
-  return position;
+   static int nCall = 0; nCall++;
+   Break(nCall);
+   int position = 0;
+   setState(pNode);
+   setDetector(tDet);
+
+   if (debug()) ResetComment(::Form("%30s ", tDet->getName().c_str()));
+
+   StiPlacement *place = tDet->getPlacement();
+   //double nLayerRadius  = place->getLayerRadius ();
+   double nNormalRadius = place->getNormalRadius();
+
+   StiShape *sh = tDet->getShape();
+   int shapeCode = sh->getShapeCode();
+   double endVal, dAlpha;
+
+   switch (shapeCode) {
+
+   case kPlanar: endVal = nNormalRadius;
+      {
+         //flat volume
+         dAlpha = place->getNormalRefAngle();
+         dAlpha = nice(dAlpha - _alpha);
+         // bail out if the rotation fails...
+         position = rotate(dAlpha);
+
+         if (position) 			return -10;
+      }
+      break;
+
+   case kDisk:
+   case kCylindrical: endVal = nNormalRadius;
+      {
+         double xy[4];
+         position = cylCross(endVal, &mFP._cosCA, mFP.curv(), xy);
+
+         if (position) 			return -11;
+
+         dAlpha = atan2(xy[1], xy[0]);
+         position = rotate(dAlpha);
+
+         if (position) 			return -11;
+      }
+      break;
+
+   default: assert(0);
+   }
+
+   position = propagate(endVal, shapeCode, dir);
+
+   if (position > kEdgeZplus || position < 0) return position;
+
+   propagateError();
+
+   if (debug() & 8) { PrintpT("E");}
+
+   // Multiple scattering
+   if (StiKalmanTrackFinderParameters::instance()->mcsCalculated() && getHz())
+      propagateMCS(pNode, tDet);
+
+   if (debug() & 8) { PrintpT("M");}
+
+   return position;
 }
 
 //______________________________________________________________________________
@@ -929,244 +968,293 @@ Break(nCall);
  return true when the propagation is successfull and false otherwise.
 <p>
 */
-bool StiKalmanTrackNode::propagate(const StiKalmanTrackNode *parentNode, StiHit * vertex,int dir)
+bool StiKalmanTrackNode::propagate(const StiKalmanTrackNode *parentNode, StiHit *vertex, int dir)
 {
-static int nCall=0; nCall++;
-Break(nCall);
-  
-  setState(parentNode);
-  TCircle tc(&mFP.x(),&mFP._cosCA,mFP.curv());
-  double xy[2]; xy[0]=vertex->x(),xy[1]=vertex->y();
-  double s = tc.Path(xy); tc.Move(s);
-  double ang = atan2(tc.Dir()[1],tc.Dir()[0]);
-  vertex->rotate(ang);
-  rotate(ang);
-  if (debug()) ResetComment(::Form("Vtx:%8.3f %8.3f %8.3f",vertex->x(),vertex->y(),vertex->z()));
-  if (propagate(vertex->x(),kPlanar,dir))    return false; // track does not reach vertex "plane"
-  propagateError();
-  if (debug() & 8) { PrintpT("V");}
-  setHit(vertex);
-  setDetector(0);
-  return true;
+   static int nCall = 0; nCall++;
+   Break(nCall);
+
+   setState(parentNode);
+   TCircle tc(&mFP.x(), &mFP._cosCA, mFP.curv());
+   double xy[2]; xy[0] = vertex->x(), xy[1] = vertex->y();
+   double s = tc.Path(xy); tc.Move(s);
+   double ang = atan2(tc.Dir()[1], tc.Dir()[0]);
+   vertex->rotate(ang);
+   rotate(ang);
+
+   if (debug()) ResetComment(::Form("Vtx:%8.3f %8.3f %8.3f", vertex->x(), vertex->y(), vertex->z()));
+
+   if (propagate(vertex->x(), kPlanar, dir))    return false; // track does not reach vertex "plane"
+
+   propagateError();
+
+   if (debug() & 8) { PrintpT("V");}
+
+   setHit(vertex);
+   setDetector(0);
+   return true;
 }
 
 //______________________________________________________________________________
 ///Propagate track from the given node to the beam line with x==0.
 ///Set the hit and detector pointers to null to manifest this is an extrapolation
-bool StiKalmanTrackNode::propagateToBeam(const StiKalmanTrackNode *parentNode,int dir)
+bool StiKalmanTrackNode::propagateToBeam(const StiKalmanTrackNode *parentNode, int dir)
 {
-  setState(parentNode);
-  if (debug()) {
-    if (parentNode->getDetector()) 
-      ResetComment(::Form("%30s ",parentNode->getDetector()->getName().c_str()));
-    else ResetComment("Unknown Detector");
-  }
-  if (propagate(0., kPlanar,dir) < 0) return false; // track does not reach vertex "plane"
-  propagateError();
-  if (debug() & 8) { PrintpT("B");}
-  setHit(0);
-  setDetector(0);
-  return true;
+   setState(parentNode);
+
+   if (debug()) {
+      if (parentNode->getDetector())
+         ResetComment(::Form("%30s ", parentNode->getDetector()->getName().c_str()));
+      else ResetComment("Unknown Detector");
+   }
+
+   if (propagate(0., kPlanar, dir) < 0) return false; // track does not reach vertex "plane"
+
+   propagateError();
+
+   if (debug() & 8) { PrintpT("B");}
+
+   setHit(0);
+   setDetector(0);
+   return true;
 }
 
 //______________________________________________________________________________
 ///Extrapolate the track defined by the given node to the given radius.
 ///Return a negative value if the operation is impossible.
-int StiKalmanTrackNode::propagateToRadius(StiKalmanTrackNode *pNode, double radius,int dir)
+int StiKalmanTrackNode::propagateToRadius(StiKalmanTrackNode *pNode, double radius, int dir)
 {
-  int position = 0;
-  setState(pNode);
-  if (debug()) ResetComment(::Form("%30s ",pNode->getDetector()->getName().c_str()));
-  position = propagate(radius,kCylindrical,dir);
-  if (position<0) return position;
-  propagateError();
-  if (debug() & 8) { PrintpT("R");}
-  _detector = 0;
-  return position;
+   int position = 0;
+   setState(pNode);
+
+   if (debug()) ResetComment(::Form("%30s ", pNode->getDetector()->getName().c_str()));
+
+   position = propagate(radius, kCylindrical, dir);
+
+   if (position < 0) return position;
+
+   propagateError();
+
+   if (debug() & 8) { PrintpT("R");}
+
+   _detector = 0;
+   return position;
 }
 
 
 //______________________________________________________________________________
-/*! Work method used to perform the tranport of "this" node from 
-  its current "_x" position to the given position "xk". 
+/*! Work method used to perform the tranport of "this" node from
+  its current "_x" position to the given position "xk".
   Returns -1 if the propagation cannot be carried out, i.e.
-  if the track curvature is such it cannot reach the desired 
+  if the track curvature is such it cannot reach the desired
   location.
   option == 0 Planar
   option == 1 Cylinder
  */
 //______________________________________________________________________________
-int  StiKalmanTrackNode::propagate(double xk, int option,int dir)
+int  StiKalmanTrackNode::propagate(double xk, int option, int dir)
 {
-  static int nCalls=0;
-  nCalls++;
-  assert(fDerivTestOn!=-10 || _state==kTNRotEnd ||_state>=kTNReady);
-  _state = kTNProBeg;
-//  numeDeriv(xk,1,option,dir);
-  mgP.x1=mFP.x();  mgP.y1=mFP.y(); mgP.cosCA1 =mFP._cosCA; mgP.sinCA1 =mFP._sinCA;
-  double rho = mFP.curv();
-  mgP.x2 = xk;
-
-  mgP.dx=mgP.x2-mgP.x1;  
-  double test = (dir)? mgP.dx:-mgP.dx;  
-//   	if track is coming back stop tracking
-//VP  if (test<0) return -3; //Unfortunatelly correct order not garanteed
-
-  double dsin = mFP.curv()*mgP.dx;
-  mgP.sinCA2=mgP.sinCA1 + dsin; 
-//	Orientation is bad. Fit is non reliable
-  if (fabs(mgP.sinCA2)>kMaxSinEta) 				return -4;
-  mgP.cosCA2   = ::sqrt((1.-mgP.sinCA2)*(1.+mgP.sinCA2));
-//	Check what sign of cosCA2 must be
-  test = (2*dir-1)*mgP.dx*mgP.cosCA1;
-  if (test<0) mgP.cosCA2 = -mgP.cosCA2;
-
-  int nIt = (mgP.cosCA2 <0)? 2:1;
-  int ians = 0;
-  StiNodePars save = mFP;
-  for (int iIt=0; iIt<nIt; iIt++) {//try 2 cases, +ve and -ve cosCA
-    ians = -1;
-    mFP = save;
-    mgP.cosCA2 = (!iIt)? fabs(mgP.cosCA2):-fabs(mgP.cosCA2);
-    mgP.sumSin   = mgP.sinCA1+mgP.sinCA2;
-    mgP.sumCos   = mgP.cosCA1+mgP.cosCA2;
-    if (fabs(mgP.sumCos)<1e-6) continue;
-    mgP.dy = mgP.dx*(mgP.sumSin/mgP.sumCos);
-    mgP.y2 = mgP.y1+mgP.dy;
-
-
-    mgP.dl0 = mgP.cosCA1*mgP.dx+mgP.sinCA1*mgP.dy;
-    double sind = mgP.dl0*rho;
-  
-    if (fabs(dsin) < 0.02 ) { //tiny angle
-      mgP.dl = mgP.dl0*(1.+sind*sind/6);
-      
-    } else {
-      double cosd = mgP.cosCA2*mgP.cosCA1+mgP.sinCA2*mgP.sinCA1;
-      mgP.dl = atan2(sind,cosd)/rho;
-    }
-
-    mFP.z() += mgP.dl*mFP.tanl();
-    mFP.y() = mgP.y2;
-    mFP.eta() = nice(mFP.eta()+rho*mgP.dl);  					/*VP*/
-    mFP.x()       = mgP.x2;
-    mFP._sinCA   = mgP.sinCA2;
-    mFP._cosCA   = mgP.cosCA2;
-    ians = locate();
-    if (ians<=kEdgeZplus && ians>=0) break;
-  }
-  if (ians>kEdgeZplus || ians<0) 		return ians;
-  if (mFP.x()> kFarFromBeam) {
-    if (fabs(mFP.eta())>kMaxEta) 		return kEnded;
-    if (mFP.x()*mgP.cosCA2+mFP.y()*mgP.sinCA2<=0)	return kEnded; 
-  }
-  mFP.hz()      = getHz();
-  if (fabs(mFP.hz()) > 1e-10) 	{ mFP.curv() = mFP.hz()*mFP.ptin();}
-  else 				{ mFP.curv() = 1e-6 ;}
-
-  mPP() = mFP;
-  _state = kTNProEnd;
-  return ians;
+   static int nCalls = 0;
+   nCalls++;
+   assert(fDerivTestOn != -10 || _state == kTNRotEnd || _state >= kTNReady);
+   _state = kTNProBeg;
+   //  numeDeriv(xk,1,option,dir);
+   mgP.x1 = mFP.x();  mgP.y1 = mFP.y(); mgP.cosCA1 = mFP._cosCA; mgP.sinCA1 = mFP._sinCA;
+   double rho = mFP.curv();
+   mgP.x2 = xk;
+
+   mgP.dx = mgP.x2 - mgP.x1;
+   double test = (dir) ? mgP.dx : -mgP.dx;
+   //   	if track is coming back stop tracking
+   //VP  if (test<0) return -3; //Unfortunatelly correct order not garanteed
+
+   double dsin = mFP.curv() * mgP.dx;
+   mgP.sinCA2 = mgP.sinCA1 + dsin;
+
+   //	Orientation is bad. Fit is non reliable
+   if (fabs(mgP.sinCA2) > kMaxSinEta) 				return -4;
+
+   mgP.cosCA2   = ::sqrt((1. - mgP.sinCA2) * (1. + mgP.sinCA2));
+   //	Check what sign of cosCA2 must be
+   test = (2 * dir - 1) * mgP.dx * mgP.cosCA1;
+
+   if (test < 0) mgP.cosCA2 = -mgP.cosCA2;
+
+   int nIt = (mgP.cosCA2 < 0) ? 2 : 1;
+   int ians = 0;
+   StiNodePars save = mFP;
+
+   for (int iIt = 0; iIt < nIt; iIt++) { //try 2 cases, +ve and -ve cosCA
+      ians = -1;
+      mFP = save;
+      mgP.cosCA2 = (!iIt) ? fabs(mgP.cosCA2) : -fabs(mgP.cosCA2);
+      mgP.sumSin   = mgP.sinCA1 + mgP.sinCA2;
+      mgP.sumCos   = mgP.cosCA1 + mgP.cosCA2;
+
+      if (fabs(mgP.sumCos) < 1e-6) continue;
+
+      mgP.dy = mgP.dx * (mgP.sumSin / mgP.sumCos);
+      mgP.y2 = mgP.y1 + mgP.dy;
+
+
+      mgP.dl0 = mgP.cosCA1 * mgP.dx + mgP.sinCA1 * mgP.dy;
+      double sind = mgP.dl0 * rho;
+
+      if (fabs(dsin) < 0.02 ) { //tiny angle
+         mgP.dl = mgP.dl0 * (1. + sind * sind / 6);
+
+      }
+      else {
+         double cosd = mgP.cosCA2 * mgP.cosCA1 + mgP.sinCA2 * mgP.sinCA1;
+         mgP.dl = atan2(sind, cosd) / rho;
+      }
+
+      mFP.z() += mgP.dl * mFP.tanl();
+      mFP.y() = mgP.y2;
+      mFP.eta() = nice(mFP.eta() + rho * mgP.dl);  					/*VP*/
+      mFP.x()       = mgP.x2;
+      mFP._sinCA   = mgP.sinCA2;
+      mFP._cosCA   = mgP.cosCA2;
+      ians = locate();
+
+      if (ians <= kEdgeZplus && ians >= 0) break;
+   }
+
+   if (ians > kEdgeZplus || ians < 0) 		return ians;
+
+   if (mFP.x() > kFarFromBeam) {
+      if (fabs(mFP.eta()) > kMaxEta) 		return kEnded;
+
+      if (mFP.x()*mgP.cosCA2 + mFP.y()*mgP.sinCA2 <= 0)	return kEnded;
+   }
+
+   mFP.hz()      = getHz();
+
+   if (fabs(mFP.hz()) > 1e-10) 	{ mFP.curv() = mFP.hz() * mFP.ptin();}
+   else 				{ mFP.curv() = 1e-6 ;}
+
+   mPP() = mFP;
+   _state = kTNProEnd;
+   return ians;
 }
 
 //______________________________________________________________________________
 int StiKalmanTrackNode::nudge(StiHit *hitp)
 {
-  StiHit *hit = hitp;
-  if (!hit) hit = getHit();
-  double deltaX = 0;
-  if (hit) { deltaX = hit->x()-mFP.x();}
-  else     { if (_detector) deltaX = _detector->getPlacement()->getNormalRadius()-mFP.x();}
-  if(fabs(deltaX)>5)		return -1;
-  if (fabs(deltaX) <1.e-3) 	return  0;
-  double deltaS = mFP.curv()*(deltaX);
-  double sCA2 = mFP._sinCA + deltaS;
-  if (fabs(sCA2)>0.99) 		return -2;
-  double cCA2,deltaY,deltaL,sind;
-  if (fabs(deltaS) < 1e-3 && fabs(mFP.eta())<1) { //Small angle approx
-    cCA2= mFP._cosCA - mFP._sinCA/mFP._cosCA*deltaS;
-    if (cCA2> 1) cCA2= 1;
-    if (cCA2<-1) cCA2=-1;
-    deltaY = deltaX*(mFP._sinCA+sCA2)/(mFP._cosCA+cCA2);
-    deltaL = deltaX*mFP._cosCA + deltaY*mFP._sinCA;
-    sind = deltaL*mFP.curv();
-    deltaL = deltaL*(1.+sind*sind/6);
-  } else {
-    cCA2= sqrt((1.-sCA2)*(1.+sCA2));
-    if (mFP._cosCA <0) cCA2 = -cCA2;
-    deltaY = deltaX*(mFP._sinCA+sCA2)/(mFP._cosCA+cCA2);
-    deltaL = deltaX*mFP._cosCA + deltaY*mFP._sinCA;
-    sind = deltaL*mFP.curv();
-    deltaL = asin(sind)/mFP.curv();
-  }
-  double deltaZ = mFP.tanl()*(deltaL);
-  mFP._sinCA    = mgP.sinCA2 = sCA2;
-  mFP._cosCA    = mgP.cosCA2 = cCA2;
-  mgP.sumSin   = mgP.sinCA1+mgP.sinCA2;
-  mgP.sumCos   = mgP.cosCA1+mgP.cosCA2;
-  mFP.x()   += deltaX;
-  mFP.y()   += deltaY;
-  mFP.z()   += deltaZ;
-  mFP.eta() += deltaL*mFP.curv();
-  mgP.dx   += deltaX;
-  mgP.dy   += deltaY;
-  mgP.dl0  += deltaL;
-  mgP.dl   += deltaL;
-
-
-//  assert(fabs(mFP._sinCA) <  1.);
-  if (fabs(mFP._sinCA)>=1) {
-    LOG_DEBUG << Form("StiKalmanTrackNode::nudge WRONG WRONG WRONG sinCA=%g",mFP._sinCA)
-    << endm;          
-    mFP.print();
-    return -13;
-  }
-  assert(fabs(mFP._cosCA) <= 1.);
-  mPP() = mFP;
-  return 0;
+   StiHit *hit = hitp;
+
+   if (!hit) hit = getHit();
+
+   double deltaX = 0;
+
+   if (hit) { deltaX = hit->x() - mFP.x();}
+   else     { if (_detector) deltaX = _detector->getPlacement()->getNormalRadius() - mFP.x();}
+
+   if (fabs(deltaX) > 5)		return -1;
+
+   if (fabs(deltaX) < 1.e-3) 	return  0;
+
+   double deltaS = mFP.curv() * (deltaX);
+   double sCA2 = mFP._sinCA + deltaS;
+
+   if (fabs(sCA2) > 0.99) 		return -2;
+
+   double cCA2, deltaY, deltaL, sind;
+
+   if (fabs(deltaS) < 1e-3 && fabs(mFP.eta()) < 1) { //Small angle approx
+      cCA2 = mFP._cosCA - mFP._sinCA / mFP._cosCA * deltaS;
+
+      if (cCA2 > 1) cCA2 = 1;
+
+      if (cCA2 < -1) cCA2 = -1;
+
+      deltaY = deltaX * (mFP._sinCA + sCA2) / (mFP._cosCA + cCA2);
+      deltaL = deltaX * mFP._cosCA + deltaY * mFP._sinCA;
+      sind = deltaL * mFP.curv();
+      deltaL = deltaL * (1. + sind * sind / 6);
+   }
+   else {
+      cCA2 = sqrt((1. - sCA2) * (1. + sCA2));
+
+      if (mFP._cosCA < 0) cCA2 = -cCA2;
+
+      deltaY = deltaX * (mFP._sinCA + sCA2) / (mFP._cosCA + cCA2);
+      deltaL = deltaX * mFP._cosCA + deltaY * mFP._sinCA;
+      sind = deltaL * mFP.curv();
+      deltaL = asin(sind) / mFP.curv();
+   }
+
+   double deltaZ = mFP.tanl() * (deltaL);
+   mFP._sinCA    = mgP.sinCA2 = sCA2;
+   mFP._cosCA    = mgP.cosCA2 = cCA2;
+   mgP.sumSin   = mgP.sinCA1 + mgP.sinCA2;
+   mgP.sumCos   = mgP.cosCA1 + mgP.cosCA2;
+   mFP.x()   += deltaX;
+   mFP.y()   += deltaY;
+   mFP.z()   += deltaZ;
+   mFP.eta() += deltaL * mFP.curv();
+   mgP.dx   += deltaX;
+   mgP.dy   += deltaY;
+   mgP.dl0  += deltaL;
+   mgP.dl   += deltaL;
+
+
+   //  assert(fabs(mFP._sinCA) <  1.);
+   if (fabs(mFP._sinCA) >= 1) {
+      LOG_DEBUG << Form("StiKalmanTrackNode::nudge WRONG WRONG WRONG sinCA=%g", mFP._sinCA)
+                << endm;
+      mFP.print();
+      return -13;
+   }
+
+   assert(fabs(mFP._cosCA) <= 1.);
+   mPP() = mFP;
+   return 0;
 }
 //______________________________________________________________________________
-/// Make propagation matrix 
+/// Make propagation matrix
 /// \note This method must be called ONLY after a call to the propagate method.
 void StiKalmanTrackNode::propagateMtx()
-{  
-//  	fYE == dY/dEta
-  double fYE= mgP.dx*(1.+mgP.cosCA1*mgP.cosCA2+mgP.sinCA1*mgP.sinCA2)/(mgP.sumCos*mgP.cosCA2);
-//	fEC == dEta/dRho
-  double  fEC = mgP.dx/mgP.cosCA2;
-//	fYC == dY/dRho
-  double fYC=(mgP.dy*mgP.sinCA2+mgP.dx*mgP.cosCA2)/mgP.sumCos*fEC;
-// 	fZC == dZ/dRho
-  double dang = mgP.dl*mFP.curv();
-  double C2LDX = mgP.dl*mgP.dl*(
-                   0.5*mgP.sinCA2*pow((1+pow(dang/2,2)*sinX(dang/2)),2) +
-                   mgP.cosCA2*dang*sinX(dang));
-
-  double fZC = mFP.tanl()*C2LDX/mgP.cosCA2;
-//	fZE == dZ/dEta
-  double dLdEta = mgP.dy/mgP.cosCA2;
-  double fZE =  mFP.tanl()*dLdEta;
-
-//  	fZT == dZ/dTanL; 
-  double fZT= mgP.dl; 
-  double hz = getHz(); fEC *=hz; fYC*=hz; fZC*=hz;
-
-  double ca =1, sa=0;
-  if (mMtx().A[0][0]) { ca = mMtx().A[0][0]+1.;sa = mMtx().A[0][1];}
-  mMtx().reset();
-//  X related derivatives
-  mMtx().A[0][0] = -1;
-  mMtx().A[1][0] = -mgP.sinCA2/mgP.cosCA2; 
-  mMtx().A[2][0] = -mFP.tanl() /mgP.cosCA2;
-  mMtx().A[3][0] = -mFP.curv() /mgP.cosCA2;
-
-  mMtx().A[1][3]=fYE; mMtx().A[1][4]=fYC; mMtx().A[2][3]=fZE;
-  mMtx().A[2][4]=fZC; mMtx().A[2][5]=fZT; mMtx().A[3][4]=fEC;
-  if (sa) {
-    double fYX = mMtx().A[1][0]; 
-    mMtx().A[1][0] = fYX*ca-sa;
-    mMtx().A[1][1] = fYX*sa+ca-1;
-  }
+{
+   //  	fYE == dY/dEta
+   double fYE = mgP.dx * (1. + mgP.cosCA1 * mgP.cosCA2 + mgP.sinCA1 * mgP.sinCA2) / (mgP.sumCos * mgP.cosCA2);
+   //	fEC == dEta/dRho
+   double  fEC = mgP.dx / mgP.cosCA2;
+   //	fYC == dY/dRho
+   double fYC = (mgP.dy * mgP.sinCA2 + mgP.dx * mgP.cosCA2) / mgP.sumCos * fEC;
+   // 	fZC == dZ/dRho
+   double dang = mgP.dl * mFP.curv();
+   double C2LDX = mgP.dl * mgP.dl * (
+                     0.5 * mgP.sinCA2 * pow((1 + pow(dang / 2, 2) * sinX(dang / 2)), 2) +
+                     mgP.cosCA2 * dang * sinX(dang));
+
+   double fZC = mFP.tanl() * C2LDX / mgP.cosCA2;
+   //	fZE == dZ/dEta
+   double dLdEta = mgP.dy / mgP.cosCA2;
+   double fZE =  mFP.tanl() * dLdEta;
+
+   //  	fZT == dZ/dTanL;
+   double fZT = mgP.dl;
+   double hz = getHz(); fEC *= hz; fYC *= hz; fZC *= hz;
+
+   double ca = 1, sa = 0;
+
+   if (mMtx().A[0][0]) { ca = mMtx().A[0][0] + 1.; sa = mMtx().A[0][1];}
+
+   mMtx().reset();
+   //  X related derivatives
+   mMtx().A[0][0] = -1;
+   mMtx().A[1][0] = -mgP.sinCA2 / mgP.cosCA2;
+   mMtx().A[2][0] = -mFP.tanl() / mgP.cosCA2;
+   mMtx().A[3][0] = -mFP.curv() / mgP.cosCA2;
+
+   mMtx().A[1][3] = fYE; mMtx().A[1][4] = fYC; mMtx().A[2][3] = fZE;
+   mMtx().A[2][4] = fZC; mMtx().A[2][5] = fZT; mMtx().A[3][4] = fEC;
+
+   if (sa) {
+      double fYX = mMtx().A[1][0];
+      mMtx().A[1][0] = fYX * ca - sa;
+      mMtx().A[1][1] = fYX * sa + ca - 1;
+   }
 }
 
 
@@ -1175,59 +1263,64 @@ void StiKalmanTrackNode::propagateMtx()
 /// Propagate the track error matrix
 /// \note This method must be called ONLY after a call to the propagate method.
 void StiKalmanTrackNode::propagateError()
-{  
-  static int nCall=0; nCall++;
-  Break(nCall);
-  assert(fDerivTestOn!=-10 || _state==kTNProEnd);
-  
-  if (debug() & 1) 
-    {
+{
+   static int nCall = 0; nCall++;
+   Break(nCall);
+   assert(fDerivTestOn != -10 || _state == kTNProEnd);
+
+   if (debug() & 1) {
       LOG_DEBUG << "Prior Error:"
-	   << "cYY:"<<mFE._cYY<<endm;
-	   LOG_DEBUG << "cZY:"<<mFE._cZY<<" cZZ:"<<mFE._cZZ<<endm;
-      LOG_DEBUG << "cEY:"<<mFE._cEY<<" cEZ:"<<mFE._cEZ<<endm;
-      LOG_DEBUG << "cPY:"<<mFE._cPY<<" cPZ:"<<mFE._cPZ<<endm;
-      LOG_DEBUG << "cTY:"<<mFE._cTY<<" cTZ:"<<mFE._cTZ<<endm;
-    }
-  propagateMtx();
-  errPropag6(mFE.A,mMtx().A,kNPars);
-  int smallErr = !(mFE._cYY>1e-20 && mFE._cZZ>1e-20 && mFE._cEE>1e-20 && mFE._cTT>1.e-20);
-  if (smallErr) {
-    LOG_INFO << Form("***SmallErr: cYY=%g cZZ=%g cEE=%g cCC=%g cTT=%g"
-          ,mFE._cYY,mFE._cZZ,mFE._cEE,mFE._cPP,mFE._cTT) << endm;
-    assert(mFE._cYY>0 && mFE._cZZ>0 && mFE._cEE>0 && mFE._cPP>=0 && mFE._cTT>0);
-  }
-  assert(fabs(mFE._cXX)<1.e-6);
-  assert(mFE._cYY*mFE._cZZ-mFE._cZY*mFE._cZY>0);
-  mFE._cXX = mFE._cYX= mFE._cZX = mFE._cEX = mFE._cPX = mFE._cTX = 0;
-  mFE.recov();
-  mFE.check("StiKalmanTrackNode::propagateError");
+                << "cYY:" << mFE._cYY << endm;
+      LOG_DEBUG << "cZY:" << mFE._cZY << " cZZ:" << mFE._cZZ << endm;
+      LOG_DEBUG << "cEY:" << mFE._cEY << " cEZ:" << mFE._cEZ << endm;
+      LOG_DEBUG << "cPY:" << mFE._cPY << " cPZ:" << mFE._cPZ << endm;
+      LOG_DEBUG << "cTY:" << mFE._cTY << " cTZ:" << mFE._cTZ << endm;
+   }
+
+   propagateMtx();
+   errPropag6(mFE.A, mMtx().A, kNPars);
+   int smallErr = !(mFE._cYY > 1e-20 && mFE._cZZ > 1e-20 && mFE._cEE > 1e-20 && mFE._cTT > 1.e-20);
+
+   if (smallErr) {
+      LOG_INFO << Form("***SmallErr: cYY=%g cZZ=%g cEE=%g cCC=%g cTT=%g"
+                       , mFE._cYY, mFE._cZZ, mFE._cEE, mFE._cPP, mFE._cTT) << endm;
+      assert(mFE._cYY > 0 && mFE._cZZ > 0 && mFE._cEE > 0 && mFE._cPP >= 0 && mFE._cTT > 0);
+   }
+
+   assert(fabs(mFE._cXX) < 1.e-6);
+   assert(mFE._cYY * mFE._cZZ - mFE._cZY * mFE._cZY > 0);
+   mFE._cXX = mFE._cYX = mFE._cZX = mFE._cEX = mFE._cPX = mFE._cTX = 0;
+   mFE.recov();
+   mFE.check("StiKalmanTrackNode::propagateError");
 
 #ifdef Sti_DEBUG
-  if (debug() & 4) {
-    PrPP(propagateError,C);
-    TRMatrix F(kNPars,kNPars,f[0]); PrPP(propagateError,F);
-    // C^k-1_k = F_k * C_k-1 * F_kT + Q_k
-    C = TRSymMatrix(F,TRArray::kAxSxAT,C); PrPP(propagateError,C);
-    TRSymMatrix C1(kNPars,mFE.A);   PrPP(propagateError,C1);
-    C1.Verify(C);//,1e-7,2);
-  }
+
+   if (debug() & 4) {
+      PrPP(propagateError, C);
+      TRMatrix F(kNPars, kNPars, f[0]); PrPP(propagateError, F);
+      // C^k-1_k = F_k * C_k-1 * F_kT + Q_k
+      C = TRSymMatrix(F, TRArray::kAxSxAT, C); PrPP(propagateError, C);
+      TRSymMatrix C1(kNPars, mFE.A);   PrPP(propagateError, C1);
+      C1.Verify(C);//,1e-7,2);
+   }
+
 #endif
-  if (debug() & 1) 
-    {
+
+   if (debug() & 1) {
       LOG_DEBUG << "Post Error:"
-	   << "cYY:"<<mFE._cYY<<endm;
-	   LOG_DEBUG << "cZY:"<<mFE._cZY<<" cZZ:"<<mFE._cZZ<<endm;
-	   LOG_DEBUG << "cEY:"<<mFE._cEY<<" cEZ:"<<mFE._cEZ<<endm;
-	   LOG_DEBUG << "cCY:"<<mFE._cPY<<" cCZ:"<<mFE._cPZ<<endm;
-	   LOG_DEBUG << "cTY:"<<mFE._cTY<<" cTZ:"<<mFE._cTZ<<endm;
-    }
-// now set hiterrors
+                << "cYY:" << mFE._cYY << endm;
+      LOG_DEBUG << "cZY:" << mFE._cZY << " cZZ:" << mFE._cZZ << endm;
+      LOG_DEBUG << "cEY:" << mFE._cEY << " cEZ:" << mFE._cEZ << endm;
+      LOG_DEBUG << "cCY:" << mFE._cPY << " cCZ:" << mFE._cPZ << endm;
+      LOG_DEBUG << "cTY:" << mFE._cTY << " cTZ:" << mFE._cTZ << endm;
+   }
+
+   // now set hiterrors
    if (_hit) setHitErrors();
 
-// set state node is ready
-  mPE() = mFE;
-  _state = kTNReady;
+   // set state node is ready
+   mPE() = mFE;
+   _state = kTNReady;
 }
 
 //______________________________________________________________________________
@@ -1241,43 +1334,47 @@ void StiKalmanTrackNode::propagateError()
  */
 
 /*!Calulates length between center of this node and provided node, which
-  is assumed to be on the same helix. Have to use global coords, since 
+  is assumed to be on the same helix. Have to use global coords, since
   nodes may not be in the same detector volume.
 
   \returns (double) length
 */
 //delta(mgP.dx,dy,dz) = here - there
-double StiKalmanTrackNode::pathLToNode(const StiKalmanTrackNode * const oNode)
+double StiKalmanTrackNode::pathLToNode(const StiKalmanTrackNode *const oNode)
 {
-  const StThreeVector<double> delta = 
-    getGlobalPoint() - oNode->getGlobalPoint();
-  double R = getCurvature();
-  // s = 2c * asin( t/(2c)); t=::sqrt(mgP.dx^2+dy^2+dz^2)
-  return length(delta, R);
+   const StThreeVector<double> delta =
+      getGlobalPoint() - oNode->getGlobalPoint();
+   double R = getCurvature();
+   // s = 2c * asin( t/(2c)); t=::sqrt(mgP.dx^2+dy^2+dz^2)
+   return length(delta, R);
 }
 
 //______________________________________________________________________________
-inline double StiKalmanTrackNode::length(const StThreeVector<double>& delta, double curv)
+inline double StiKalmanTrackNode::length(const StThreeVector<double> &delta, double curv)
 {
-  
-  double m = delta.perp();
-  double as = 0.5*m*curv;
-  if (TMath::Abs(as) > 1) {
-    cout << "StiKalmanTrackNode::length m = " << m << " curv = " << curv << " as = " << as << " illegal. reset to 1" << endl;
-    as = 1;
-  }
-  double lxy=0;
-  if (fabs(as)<0.01) { lxy = m*(1.+as*as/24);}
-  else               { lxy = 2.*asin(as)/curv;}
-  return sqrt(lxy*lxy+delta.z()*delta.z());
+
+   double m = delta.perp();
+   double as = 0.5 * m * curv;
+
+   if (TMath::Abs(as) > 1) {
+      cout << "StiKalmanTrackNode::length m = " << m << " curv = " << curv << " as = " << as << " illegal. reset to 1" << endl;
+      as = 1;
+   }
+
+   double lxy = 0;
+
+   if (fabs(as) < 0.01) { lxy = m * (1. + as * as / 24);}
+   else               { lxy = 2.*asin(as) / curv;}
+
+   return sqrt(lxy * lxy + delta.z() * delta.z());
 }
 
 //______________________________________________________________________________
 /*! Calculate the increment of chi2 caused by the addition of this node to the track.
   <p>
-  Uses the track extrapolation to "_x", and hit position to evaluate and return the 
+  Uses the track extrapolation to "_x", and hit position to evaluate and return the
   increment to the track chi2.
-  The chi2 is not stored internally in this node. 
+  The chi2 is not stored internally in this node.
   <p>
   <h3>Notes</h3>
   <ol>
@@ -1286,69 +1383,82 @@ inline double StiKalmanTrackNode::length(const StThreeVector<double>& delta, dou
   <li>Throws an exception if numerical problems arise.</li>
   </ol>
 */
-double StiKalmanTrackNode::evaluateChi2(const StiHit * hit) 
+double StiKalmanTrackNode::evaluateChi2(const StiHit *hit)
 {
-  double r00, r01,r11;
-  //If required, recalculate the errors of the detector hits.
-  //Do not attempt this calculation for the main vertex.
-  double dsin =mFP.curv()*(hit->x()-mFP.x());
-  if (fabs(mFP._sinCA+dsin)>0.99   )	return 1e41;
-  if (fabs(mFP.eta())       >kMaxEta) 	return 1e41;
-  if (fabs(mFP.curv())      >kMaxCur)    return 1e41;
-  if (mHrr.hYY>1000*mFE._cYY
-   && mHrr.hZZ>1000*mFE._cZZ)		return 1e41;
-  setHitErrors(hit);
-  r00=mHrr.hYY+mFE._cYY;
-  r01=mHrr.hZY+mFE._cZY;  
-  r11=mHrr.hZZ+mFE._cZZ;
+   double r00, r01, r11;
+   //If required, recalculate the errors of the detector hits.
+   //Do not attempt this calculation for the main vertex.
+   double dsin = mFP.curv() * (hit->x() - mFP.x());
+
+   if (fabs(mFP._sinCA + dsin) > 0.99   )	return 1e41;
+
+   if (fabs(mFP.eta())       > kMaxEta) 	return 1e41;
+
+   if (fabs(mFP.curv())      > kMaxCur)    return 1e41;
+
+   if (mHrr.hYY > 1000 * mFE._cYY
+         && mHrr.hZZ > 1000 * mFE._cZZ)		return 1e41;
+
+   setHitErrors(hit);
+   r00 = mHrr.hYY + mFE._cYY;
+   r01 = mHrr.hZY + mFE._cZY;
+   r11 = mHrr.hZZ + mFE._cZZ;
 
 #ifdef Sti_DEBUG
-  TRSymMatrix R(2,
-		r00,
-		r01, r11);
+   TRSymMatrix R(2,
+                 r00,
+                 r01, r11);
 #endif
-  _det=r00*r11 - r01*r01;
-  if (_det<r00*r11*1.e-5) {
-    LOG_DEBUG << Form("StiKalmanTrackNode::evalChi2 *** zero determinant %g",_det)<< endm;
-    return 1e60;
-  }
-  double tmp=r00; r00=r11; r11=tmp; r01=-r01;  
-  double deltaX = hit->x()-mFP.x();
-  double deltaL = deltaX/mFP._cosCA;
-  double deltaY = mFP._sinCA *deltaL;
-  double deltaZ = mFP.tanl()  *deltaL;
-  double dyt=(mFP.y()-hit->y()) + deltaY;
-  double dzt=(mFP.z()-hit->z()) + deltaZ;
-  double cc= (dyt*r00*dyt + 2*r01*dyt*dzt + dzt*r11*dzt)/_det;
+   _det = r00 * r11 - r01 * r01;
+
+   if (_det < r00 * r11 * 1.e-5) {
+      LOG_DEBUG << Form("StiKalmanTrackNode::evalChi2 *** zero determinant %g", _det) << endm;
+      return 1e60;
+   }
+
+   double tmp = r00; r00 = r11; r11 = tmp; r01 = -r01;
+   double deltaX = hit->x() - mFP.x();
+   double deltaL = deltaX / mFP._cosCA;
+   double deltaY = mFP._sinCA * deltaL;
+   double deltaZ = mFP.tanl()  * deltaL;
+   double dyt = (mFP.y() - hit->y()) + deltaY;
+   double dzt = (mFP.z() - hit->z()) + deltaZ;
+   double cc = (dyt * r00 * dyt + 2 * r01 * dyt * dzt + dzt * r11 * dzt) / _det;
 
 #ifdef Sti_DEBUG
-  if (debug() & 4) {
-    TRSymMatrix G(R,TRArray::kInverted);
-    TRVector r(2,hit->y()-mFP.y(),hit->z()-mFP.z());
-    Double_t chisq = G.Product(r,TRArray::kATxSxA);
-    Double_t diff = chisq - cc;
-    Double_t sum  = chisq + cc;
-    if (diff > 1e-7 || (sum > 2. && (2 * diff ) / sum > 1e-7)) {
-      LOG_DEBUG << "Failed:\t" << chisq << "\t" << cc << "\tdiff\t" << diff << endm;
-    }
-  }
+
+   if (debug() & 4) {
+      TRSymMatrix G(R, TRArray::kInverted);
+      TRVector r(2, hit->y() - mFP.y(), hit->z() - mFP.z());
+      Double_t chisq = G.Product(r, TRArray::kATxSxA);
+      Double_t diff = chisq - cc;
+      Double_t sum  = chisq + cc;
+
+      if (diff > 1e-7 || (sum > 2. && (2 * diff ) / sum > 1e-7)) {
+         LOG_DEBUG << "Failed:\t" << chisq << "\t" << cc << "\tdiff\t" << diff << endm;
+      }
+   }
+
 #endif
-  if (debug() & 8) {comment += Form(" chi2 = %6.2f",cc);}
-  return cc;
+
+   if (debug() & 8) {comment += Form(" chi2 = %6.2f", cc);}
+
+   return cc;
 }
 //______________________________________________________________________________
 int StiKalmanTrackNode::isEnded() const
 {
 
-   if(fabs(mFP.eta() )<=kMaxEta) return 0;
-   return 1;   
-}		
+   if (fabs(mFP.eta() ) <= kMaxEta) return 0;
+
+   return 1;
+}
 //______________________________________________________________________________
 int StiKalmanTrackNode::isDca() const
 {
-   return (fabs(mFP.x())<=0);   
-}		
-		
+   return (fabs(mFP.x()) <= 0);
+}
+
 //______________________________________________________________________________
 /*! Calculate the effect of MCS on the track error matrix.
   <p>
@@ -1358,129 +1468,139 @@ int StiKalmanTrackNode::isDca() const
   is delegated to the function "mcs2". The calculation of energy loss is done
   by the function eloss.
  */
-void StiKalmanTrackNode::propagateMCS(StiKalmanTrackNode * previousNode, const StiDetector * tDet)
-{  
-  propagateCurv(previousNode);
-  double pt = getPt();
+void StiKalmanTrackNode::propagateMCS(StiKalmanTrackNode *previousNode, const StiDetector *tDet)
+{
+   propagateCurv(previousNode);
+   double pt = getPt();
 #if 1
-  if (pt>=1e3) {
-    mPP() = mFP; mPE() = mFE;
-    return;
-  }
+
+   if (pt >= 1e3) {
+      mPP() = mFP; mPE() = mFE;
+      return;
+   }
+
 #endif
-  double relRadThickness;
-  // Half path length in previous node
-  double pL1,pL2,pL3,d1,d2,d3,dxEloss=0;
-  pL1=previousNode->pathlength()/2.;
-  // Half path length in this node
-  pL3=pathlength()/2.;
-  // Gap path length
-  pL2= pathLToNode(previousNode);
-  if (pL1<0) pL1=0;
-  if (pL2<0) pL2=0;
-  if (pL3<0) pL3=0;
-  double x0p =-1;
-  double x0Gas=-1;
-  double x0=-1;
-  d1    = previousNode->getDensity();
-  x0p   = previousNode->getX0();
-  d3    = tDet->getMaterial()->getDensity();
-  x0    = tDet->getMaterial()->getX0();
-
-
-  if (pL2> (pL1+pL3)) 
-    {
-      pL2=pL2-pL1-pL3;
-      if (mgP.dx>0)
-				{
-					x0Gas = tDet->getGas()->getX0();
-					d2    = tDet->getGas()->getDensity();
-				}
-      else
-				{
-					x0Gas = previousNode->getGasX0(); 
-					d2    = previousNode->getGasDensity();
-				}
+   double relRadThickness;
+   // Half path length in previous node
+   double pL1, pL2, pL3, d1, d2, d3, dxEloss = 0;
+   pL1 = previousNode->pathlength() / 2.;
+   // Half path length in this node
+   pL3 = pathlength() / 2.;
+   // Gap path length
+   pL2 = pathLToNode(previousNode);
+
+   if (pL1 < 0) pL1 = 0;
+
+   if (pL2 < 0) pL2 = 0;
+
+   if (pL3 < 0) pL3 = 0;
+
+   double x0p = -1;
+   double x0Gas = -1;
+   double x0 = -1;
+   d1    = previousNode->getDensity();
+   x0p   = previousNode->getX0();
+   d3    = tDet->getMaterial()->getDensity();
+   x0    = tDet->getMaterial()->getX0();
+
+
+   if (pL2 > (pL1 + pL3)) {
+      pL2 = pL2 - pL1 - pL3;
+
+      if (mgP.dx > 0) {
+         x0Gas = tDet->getGas()->getX0();
+         d2    = tDet->getGas()->getDensity();
+      }
+      else {
+         x0Gas = previousNode->getGasX0();
+         d2    = previousNode->getGasDensity();
+      }
+
       relRadThickness = 0.;
       dxEloss = 0;
-      if (x0p>0.) 
-	{
-	  relRadThickness += pL1/x0p;
-	  dxEloss += d1*pL1;
-	}
-      if (x0Gas>0.)
-				{
-					relRadThickness += pL2/x0Gas;
-					dxEloss += d2*pL2;
-				}
-      if (x0>0.)
-				{
-					relRadThickness += pL3/x0;
-					dxEloss += d3*pL3;
-				}
-    }
-  else 
-    {
-      relRadThickness = 0.; 
+
+      if (x0p > 0.) {
+         relRadThickness += pL1 / x0p;
+         dxEloss += d1 * pL1;
+      }
+
+      if (x0Gas > 0.) {
+         relRadThickness += pL2 / x0Gas;
+         dxEloss += d2 * pL2;
+      }
+
+      if (x0 > 0.) {
+         relRadThickness += pL3 / x0;
+         dxEloss += d3 * pL3;
+      }
+   }
+   else {
+      relRadThickness = 0.;
       dxEloss = 0;
-      if (x0p>0.) 
-				{
-					relRadThickness += pL1/x0p;
-					dxEloss += d1*pL1;
-				}
-      if (x0>0.)
-				{
-					relRadThickness += pL3/x0;
-					dxEloss += d3*pL3;
-				}
-    }
-  if (pt > 0.350 && TMath::Abs(getHz()) < 1e-3) pt = 0.350;
-  double p2=(1.+mFP.tanl()*mFP.tanl())*pt*pt;
-  double m=StiKalmanTrackFinderParameters::instance()->massHypothesis();
-  double m2=m*m;
-  double e2=p2+m2;
-  double beta2=p2/e2;
-  //cout << " m2:"<<m2<<" p2:"<<p2<<" beta2:"<<beta2;
-  double theta2=mcs2(relRadThickness,beta2,p2);
-  //cout << " theta2:"<<theta2;
- double pti = mFP.ptin(), tanl = mFP.tanl(); 
-
- double cos2Li = (1.+ tanl*tanl);  // 1/cos(lamda)**2
- 
- mFE._cEE += cos2Li 		*theta2;
- mFE._cPP += tanl*tanl*pti*pti	*theta2;
- mFE._cTP += pti*tanl*cos2Li	*theta2;
- mFE._cTT += cos2Li*cos2Li	*theta2;
+
+      if (x0p > 0.) {
+         relRadThickness += pL1 / x0p;
+         dxEloss += d1 * pL1;
+      }
+
+      if (x0 > 0.) {
+         relRadThickness += pL3 / x0;
+         dxEloss += d3 * pL3;
+      }
+   }
+
+   if (pt > 0.350 && TMath::Abs(getHz()) < 1e-3) pt = 0.350;
+
+   double p2 = (1. + mFP.tanl() * mFP.tanl()) * pt * pt;
+   double m = StiKalmanTrackFinderParameters::instance()->massHypothesis();
+   double m2 = m * m;
+   double e2 = p2 + m2;
+   double beta2 = p2 / e2;
+   //cout << " m2:"<<m2<<" p2:"<<p2<<" beta2:"<<beta2;
+   double theta2 = mcs2(relRadThickness, beta2, p2);
+   //cout << " theta2:"<<theta2;
+   double pti = mFP.ptin(), tanl = mFP.tanl();
+
+   double cos2Li = (1. + tanl * tanl); // 1/cos(lamda)**2
+
+   mFE._cEE += cos2Li 		* theta2;
+   mFE._cPP += tanl * tanl * pti * pti	* theta2;
+   mFE._cTP += pti * tanl * cos2Li	* theta2;
+   mFE._cTT += cos2Li * cos2Li	* theta2;
 
 #ifdef STI_ERROR_TEST
-  testError(mFE.A,1);
+   testError(mFE.A, 1);
 #endif // STI_ERROR_TEST
-  double dE=0;
-  double sign = (mgP.dx>0)? 1:-1;
-
-//  const static double I2Ar = (15.8*18) * (15.8*18) * 1e-18; // GeV**2
-  StiElossCalculator * calculator = tDet->getElossCalculator();
-  double eloss = calculator->calculate(1.,m, beta2);
-  dE = sign*dxEloss*eloss;
-  if (TMath::Abs(dE)>0)
-    {
+   double dE = 0;
+   double sign = (mgP.dx > 0) ? 1 : -1;
+
+   //  const static double I2Ar = (15.8*18) * (15.8*18) * 1e-18; // GeV**2
+   StiElossCalculator *calculator = tDet->getElossCalculator();
+   double eloss = calculator->calculate(1., m, beta2);
+   dE = sign * dxEloss * eloss;
+
+   if (TMath::Abs(dE) > 0) {
       if (debug()) {
-	commentdEdx  = Form("%6.3g cm(%5.2f) %6.3g keV %6.3f GeV",mgP.dx,100*relRadThickness,1e6*dE,TMath::Sqrt(e2)-m); 
+         commentdEdx  = Form("%6.3g cm(%5.2f) %6.3g keV %6.3f GeV", mgP.dx, 100 * relRadThickness, 1e6 * dE, TMath::Sqrt(e2) - m);
       }
-      double correction =1. + ::sqrt(e2)*dE/p2;
-      if (correction>1.1) correction = 1.1;
-      else if (correction<0.9) correction = 0.9;
-      mFP.curv() = mFP.curv()*correction;
-      mFP.ptin() = mFP.ptin()*correction;
-    }
-    mPP() = mFP; mPE() = mFE;
+
+      double correction = 1. + ::sqrt(e2) * dE / p2;
+
+      if (correction > 1.1) correction = 1.1;
+      else if (correction < 0.9) correction = 0.9;
+
+      mFP.curv() = mFP.curv() * correction;
+      mFP.ptin() = mFP.ptin() * correction;
+   }
+
+   mPP() = mFP; mPE() = mFE;
 
 }
 
 //______________________________________________________________________________
 /*! Update the track parameters using this node.
   <p>
-  This method uses the hit contained by node to update the track 
+  This method uses the hit contained by node to update the track
   parameters contained by this node and thus complete the propagation
   of this track to the location x=_x.
   <p>
@@ -1498,173 +1618,198 @@ void StiKalmanTrackNode::propagateMCS(StiKalmanTrackNode * previousNode, const S
   </ol>
 */
 //______________________________________________________________________________
-int StiKalmanTrackNode::updateNode() 
+int StiKalmanTrackNode::updateNode()
 {
-static int nCall=0; nCall++;
-  assert(fDerivTestOn!=-10 || _state>=kTNReady);
-  _state = kTNFitBeg;
+   static int nCall = 0; nCall++;
+   assert(fDerivTestOn != -10 || _state >= kTNReady);
+   _state = kTNFitBeg;
 #ifdef STI_ERROR_TEST
-  testError(mFE.A,0);
+   testError(mFE.A, 0);
 #endif //STI_ERROR_TEST
-  assert(mFE._cXX<1e-8);
-  double r00,r01,r11;
-  r00 = mHrr.hYY + mFE._cYY;
-  r01 = mHrr.hZY + mFE._cZY;
-  r11 = mHrr.hZZ + mFE._cZZ;
+   assert(mFE._cXX < 1e-8);
+   double r00, r01, r11;
+   r00 = mHrr.hYY + mFE._cYY;
+   r01 = mHrr.hZY + mFE._cZY;
+   r11 = mHrr.hZZ + mFE._cZZ;
 #ifdef Sti_DEBUG
-  TRSymMatrix V(2,mHrr.hYY,
-		  mHrr.hZY, mHrr.hZZ);  
-  TRSymMatrix R1(2,r00,
-		   r01, r11);
-  static const TRMatrix H(2,5, 1., 0., 0., 0., 0.,
-			       0., 1., 0., 0., 0.);
+   TRSymMatrix V(2, mHrr.hYY,
+                 mHrr.hZY, mHrr.hZZ);
+   TRSymMatrix R1(2, r00,
+                  r01, r11);
+   static const TRMatrix H(2, 5, 1., 0., 0., 0., 0.,
+                           0., 1., 0., 0., 0.);
 #endif
-  _det=r00*r11 - r01*r01;
-  if (!finite(_det) || _det<(r00*r11)*1.e-5) {
-    LOG_DEBUG << Form("StiKalmanTrackNode::updateNode *** zero determinant %g",_det)
-    << endm;
-    return -11;
-  }
-  // inverse matrix
-  double tmp=r00; r00=r11/_det; r11=tmp/_det; r01=-r01/_det;
-  // update error matrix
-  double k00=mFE._cYY*r00+mFE._cZY*r01, k01=mFE._cYY*r01+mFE._cZY*r11;
-  double k10=mFE._cZY*r00+mFE._cZZ*r01, k11=mFE._cZY*r01+mFE._cZZ*r11;
-  double k20=mFE._cEY*r00+mFE._cEZ*r01, k21=mFE._cEY*r01+mFE._cEZ*r11;
-  double k30=mFE._cPY*r00+mFE._cPZ*r01, k31=mFE._cPY*r01+mFE._cPZ*r11;
-  double k40=mFE._cTY*r00+mFE._cTZ*r01, k41=mFE._cTY*r01+mFE._cTZ*r11;
-  double dyt  = getHit()->y() - mFP.y();
-  double dzt  = getHit()->z() - mFP.z();
-  double dp3  = k30*dyt + k31*dzt;
-  double dp2  = k20*dyt + k21*dzt;
-  double dp4  = k40*dyt + k41*dzt;
+   _det = r00 * r11 - r01 * r01;
+
+   if (!finite(_det) || _det < (r00 * r11) * 1.e-5) {
+      LOG_DEBUG << Form("StiKalmanTrackNode::updateNode *** zero determinant %g", _det)
+                << endm;
+      return -11;
+   }
+
+   // inverse matrix
+   double tmp = r00; r00 = r11 / _det; r11 = tmp / _det; r01 = -r01 / _det;
+   // update error matrix
+   double k00 = mFE._cYY * r00 + mFE._cZY * r01, k01 = mFE._cYY * r01 + mFE._cZY * r11;
+   double k10 = mFE._cZY * r00 + mFE._cZZ * r01, k11 = mFE._cZY * r01 + mFE._cZZ * r11;
+   double k20 = mFE._cEY * r00 + mFE._cEZ * r01, k21 = mFE._cEY * r01 + mFE._cEZ * r11;
+   double k30 = mFE._cPY * r00 + mFE._cPZ * r01, k31 = mFE._cPY * r01 + mFE._cPZ * r11;
+   double k40 = mFE._cTY * r00 + mFE._cTZ * r01, k41 = mFE._cTY * r01 + mFE._cTZ * r11;
+   double dyt  = getHit()->y() - mFP.y();
+   double dzt  = getHit()->z() - mFP.z();
+   double dp3  = k30 * dyt + k31 * dzt;
+   double dp2  = k20 * dyt + k21 * dzt;
+   double dp4  = k40 * dyt + k41 * dzt;
 #ifdef Sti_DEBUG
-  double dp0  = k00*dyt + k01*dz;
-  double dp1  = k10*dyt + k11*dz;
-  if (debug() & 4) {
-    PrPP(updateNode,R1);
-    PrPP(updateNode,V);
-  }
-  TRSymMatrix C(kNPars,mFE.A);  
-  TRSymMatrix R(H,TRArray::kAxSxAT,C);
-  R += V;
-  TRSymMatrix G(R,TRArray::kInverted); 
-  if (debug() & 4) {
-    PrPP(updateNode,C);
-    PrPP(updateNode,R);
-    PrPP(updateNode,G);
-  }
-  // K = C * HT * G
-  TRMatrix T(C,TRArray::kSxAT,H); 
-  TRMatrix K(T,TRArray::kAxS,G);  
-  TRMatrix K1(5,2,
-	      k00, k01,
-	      k10, k11,
-	      k20, k21,
-	      k30, k31,
-	      k40, k41);   
-  if (debug() & 4) {
-    PrPP(updateNode,T);
-    PrPP(updateNode,K1);
-    PrPP(updateNode,K);
-    K1.Verify(K);
-  }
-  TRVector dR(2,dyt, dzt);
-  TRVector dP1(5, dp0, dp1, dp2, dp3, dp4);
-  TRVector dP(K,TRArray::kAxB,dR);
-  if (debug() & 4) dP1.Verify(dP);//,1e-7,2);
+   double dp0  = k00 * dyt + k01 * dz;
+   double dp1  = k10 * dyt + k11 * dz;
+
+   if (debug() & 4) {
+      PrPP(updateNode, R1);
+      PrPP(updateNode, V);
+   }
+
+   TRSymMatrix C(kNPars, mFE.A);
+   TRSymMatrix R(H, TRArray::kAxSxAT, C);
+   R += V;
+   TRSymMatrix G(R, TRArray::kInverted);
+
+   if (debug() & 4) {
+      PrPP(updateNode, C);
+      PrPP(updateNode, R);
+      PrPP(updateNode, G);
+   }
+
+   // K = C * HT * G
+   TRMatrix T(C, TRArray::kSxAT, H);
+   TRMatrix K(T, TRArray::kAxS, G);
+   TRMatrix K1(5, 2,
+               k00, k01,
+               k10, k11,
+               k20, k21,
+               k30, k31,
+               k40, k41);
+
+   if (debug() & 4) {
+      PrPP(updateNode, T);
+      PrPP(updateNode, K1);
+      PrPP(updateNode, K);
+      K1.Verify(K);
+   }
+
+   TRVector dR(2, dyt, dzt);
+   TRVector dP1(5, dp0, dp1, dp2, dp3, dp4);
+   TRVector dP(K, TRArray::kAxB, dR);
+
+   if (debug() & 4) dP1.Verify(dP);//,1e-7,2);
+
 #endif
-  double eta  = nice(mFP.eta() + dp2);
-  if (fabs(eta)>kMaxEta) return -14;
-  double pti  = mFP.ptin() + dp3;
-  if (fabs(pti) < 1e-3) pti=1e-3;
-  double cur  = pti*getHz();
-  if (fabs(cur)>kMaxCur) return -16;
-  assert(finite(cur));
-  double tanl = mFP.tanl() + dp4;
-  // update Kalman state
-   double p0 = mFP.y() + k00*dyt + k01*dzt;
-//VP  mFP.y() += k00*dy + k01*dz;
-  if (fabs(p0)>kMaxR) 
-    {
-      LOG_DEBUG << "updateNode()[1] -W- _y:"<<mFP.y()<<" _z:"<<mFP.z()<<endm;
+   double eta  = nice(mFP.eta() + dp2);
+
+   if (fabs(eta) > kMaxEta) return -14;
+
+   double pti  = mFP.ptin() + dp3;
+
+   if (fabs(pti) < 1e-3) pti = 1e-3;
+
+   double cur  = pti * getHz();
+
+   if (fabs(cur) > kMaxCur) return -16;
+
+   assert(finite(cur));
+   double tanl = mFP.tanl() + dp4;
+   // update Kalman state
+   double p0 = mFP.y() + k00 * dyt + k01 * dzt;
+
+   //VP  mFP.y() += k00*dy + k01*dz;
+   if (fabs(p0) > kMaxR) {
+      LOG_DEBUG << "updateNode()[1] -W- _y:" << mFP.y() << " _z:" << mFP.z() << endm;
       return -12;
-    }
-  double p1 = mFP.z() + k10*dyt + k11*dzt;
-  if (fabs(p1)>kMaxZ) 
-    {
-      LOG_DEBUG << "updateNode()[2] -W- _y:"<<mFP.y()<<" _z:"<<mFP.z()<<endm;
+   }
+
+   double p1 = mFP.z() + k10 * dyt + k11 * dzt;
+
+   if (fabs(p1) > kMaxZ) {
+      LOG_DEBUG << "updateNode()[2] -W- _y:" << mFP.y() << " _z:" << mFP.z() << endm;
       return -13;
-    }
-  //mFP.tanl() += k40*dyt + k41*dzt;
-  double sinCA  =  sin(eta);
-  // The following test introduces a track propagation error but happens
-  // only when the track should be aborted so we don't care...
-  mFP.y()  = p0;
-  mFP.z()  = p1;
-  mFP.eta()   = eta;
-  mFP.ptin()  = pti;
-  mFP.curv()  = cur;
-  mFP.tanl()  = tanl;
-  mFP._sinCA = sinCA;
-  mFP._cosCA = ::sqrt((1.-mFP._sinCA)*(1.+mFP._sinCA)); 
-  mFP.hz() = getHz();
-
-// update error matrix
-  double c00=mFE._cYY;                       
-  double c10=mFE._cZY, c11=mFE._cZZ;                 
-  double c20=mFE._cEY, c21=mFE._cEZ;//, c22=mFE._cEE;           
-  double c30=mFE._cPY, c31=mFE._cPZ;//, c32=mFE._cPE, c33=mFE._cPP;     
-  double c40=mFE._cTY, c41=mFE._cTZ;//, c42=mFE._cTE, c43=mFE._cTP, c44=mFE._cTT;
-  mFE._cYY-=k00*c00+k01*c10;
-  mFE._cZY-=k10*c00+k11*c10;mFE._cZZ-=k10*c10+k11*c11;
-  mFE._cEY-=k20*c00+k21*c10;mFE._cEZ-=k20*c10+k21*c11;mFE._cEE-=k20*c20+k21*c21;
-  mFE._cPY-=k30*c00+k31*c10;mFE._cPZ-=k30*c10+k31*c11;mFE._cPE-=k30*c20+k31*c21;mFE._cPP-=k30*c30+k31*c31;
-  mFE._cTY-=k40*c00+k41*c10;mFE._cTZ-=k40*c10+k41*c11;mFE._cTE-=k40*c20+k41*c21;mFE._cTP-=k40*c30+k41*c31;mFE._cTT-=k40*c40+k41*c41;
-
-  if (mFE._cYY >= mHrr.hYY || mFE._cZZ >= mHrr.hZZ) {
-    LOG_DEBUG << Form("StiKalmanTrackNode::updateNode *** _cYY >= hYY || _cZZ >= hZZ %g %g %g %g"
-          ,mFE._cYY,mHrr.hYY,mFE._cZZ,mHrr.hZZ)<< endm;
-    return -14;
-  }
-  if (mFE.check()) return -14;
+   }
+
+   //mFP.tanl() += k40*dyt + k41*dzt;
+   double sinCA  =  sin(eta);
+   // The following test introduces a track propagation error but happens
+   // only when the track should be aborted so we don't care...
+   mFP.y()  = p0;
+   mFP.z()  = p1;
+   mFP.eta()   = eta;
+   mFP.ptin()  = pti;
+   mFP.curv()  = cur;
+   mFP.tanl()  = tanl;
+   mFP._sinCA = sinCA;
+   mFP._cosCA = ::sqrt((1. - mFP._sinCA) * (1. + mFP._sinCA));
+   mFP.hz() = getHz();
+
+   // update error matrix
+   double c00 = mFE._cYY;
+   double c10 = mFE._cZY, c11 = mFE._cZZ;
+   double c20 = mFE._cEY, c21 = mFE._cEZ; //, c22=mFE._cEE;
+   double c30 = mFE._cPY, c31 = mFE._cPZ; //, c32=mFE._cPE, c33=mFE._cPP;
+   double c40 = mFE._cTY, c41 = mFE._cTZ; //, c42=mFE._cTE, c43=mFE._cTP, c44=mFE._cTT;
+   mFE._cYY -= k00 * c00 + k01 * c10;
+   mFE._cZY -= k10 * c00 + k11 * c10; mFE._cZZ -= k10 * c10 + k11 * c11;
+   mFE._cEY -= k20 * c00 + k21 * c10; mFE._cEZ -= k20 * c10 + k21 * c11; mFE._cEE -= k20 * c20 + k21 * c21;
+   mFE._cPY -= k30 * c00 + k31 * c10; mFE._cPZ -= k30 * c10 + k31 * c11; mFE._cPE -= k30 * c20 + k31 * c21; mFE._cPP -= k30 * c30 + k31 * c31;
+   mFE._cTY -= k40 * c00 + k41 * c10; mFE._cTZ -= k40 * c10 + k41 * c11; mFE._cTE -= k40 * c20 + k41 * c21; mFE._cTP -= k40 * c30 + k41 * c31; mFE._cTT -= k40 * c40 + k41 * c41;
+
+   if (mFE._cYY >= mHrr.hYY || mFE._cZZ >= mHrr.hZZ) {
+      LOG_DEBUG << Form("StiKalmanTrackNode::updateNode *** _cYY >= hYY || _cZZ >= hZZ %g %g %g %g"
+                        , mFE._cYY, mHrr.hYY, mFE._cZZ, mHrr.hZZ) << endm;
+      return -14;
+   }
+
+   if (mFE.check()) return -14;
 
 #ifdef Sti_DEBUG
-  TRSymMatrix W(H,TRArray::kATxSxA,G); 
-  TRSymMatrix C0(C);
-  C0 -= TRSymMatrix(C,TRArray::kRxSxR,W);
-  TRSymMatrix C1(kNPars,mFE.A);  
-  if (debug() & 4) {
-    PrPP(updateNode,W); 
-    PrPP(updateNode,C0);
-    PrPP(updateNode,C1);
-    C1.Verify(C0);
-  }
-  //   update of the covariance matrix:
-  //    C_k = (I - K_k * H_k) * C^k-1_k * (I - K_k * H_k)T + K_k * V_k * KT_k
-  // P* C^k-1_k * PT
-  TRMatrix A(K,TRArray::kAxB,H);
-  TRMatrix P(TRArray::kUnit,kNPars);
-  P -= A;
-  TRSymMatrix C2(P,TRArray::kAxSxAT,C); 
-  TRSymMatrix Y(K,TRArray::kAxSxAT,V);  
-  C2 += Y;  
-  if (debug() & 4) {
-    PrPP(updateNode,C2); PrPP(updateNode,Y); PrPP(updateNode,C2);
-    C2.Verify(C0);
-    C2.Verify(C1);
-  }
+   TRSymMatrix W(H, TRArray::kATxSxA, G);
+   TRSymMatrix C0(C);
+   C0 -= TRSymMatrix(C, TRArray::kRxSxR, W);
+   TRSymMatrix C1(kNPars, mFE.A);
+
+   if (debug() & 4) {
+      PrPP(updateNode, W);
+      PrPP(updateNode, C0);
+      PrPP(updateNode, C1);
+      C1.Verify(C0);
+   }
+
+   //   update of the covariance matrix:
+   //    C_k = (I - K_k * H_k) * C^k-1_k * (I - K_k * H_k)T + K_k * V_k * KT_k
+   // P* C^k-1_k * PT
+   TRMatrix A(K, TRArray::kAxB, H);
+   TRMatrix P(TRArray::kUnit, kNPars);
+   P -= A;
+   TRSymMatrix C2(P, TRArray::kAxSxAT, C);
+   TRSymMatrix Y(K, TRArray::kAxSxAT, V);
+   C2 += Y;
+
+   if (debug() & 4) {
+      PrPP(updateNode, C2); PrPP(updateNode, Y); PrPP(updateNode, C2);
+      C2.Verify(C0);
+      C2.Verify(C1);
+   }
+
 #endif
-  if (debug() & 8) PrintpT("U");
-  _state = kTNFitEnd;
-  return 0; 
+
+   if (debug() & 8) PrintpT("U");
+
+   _state = kTNFitEnd;
+   return 0;
 }
 
 //______________________________________________________________________________
 /*! Rotate this node track representation azymuthally by given angle.
   <p>
-  This method rotates by an angle alpha the track representation 
-  held by this node. 
+  This method rotates by an angle alpha the track representation
+  held by this node.
   <h3>Notes</h3>
   <ol>
   <li>The rotation is bound between -M_PI and M_PI.</li>
@@ -1674,256 +1819,290 @@ static int nCall=0; nCall++;
 */
 int StiKalmanTrackNode::rotate (double alpha) //throw ( Exception)
 {
-  assert(fDerivTestOn!=-10 || _state>=kTNReady);
-  mMtx().A[0][0]=0;
-  if (fabs(alpha)<1.e-6) return 0;
-  _state = kTNRotBeg;
-  _alpha += alpha;
-  _alpha = nice(_alpha);
-    //cout << "    new  _alpha:"<< 180.*_alpha/3.1415927<<endl;
-
-  double xt1=mFP.x(); 
-  double yt1=mFP.y(); 
-  mgP.sinCA1 = mFP._sinCA;
-  mgP.cosCA1 = mFP._cosCA;
-  double ca = cos(alpha);
-  double sa = sin(alpha);
-  mFP.x() = xt1*ca + yt1*sa;
-  mFP.y()= -xt1*sa + yt1*ca;
-  mFP._cosCA =  mgP.cosCA1*ca+mgP.sinCA1*sa;
-  mFP._sinCA = -mgP.cosCA1*sa+mgP.sinCA1*ca;
-   double nor = 0.5*(mFP._sinCA*mFP._sinCA+mFP._cosCA*mFP._cosCA +1);
-  mFP._cosCA /= nor;
-  mFP._sinCA /= nor;
-
-  mFP.eta()= nice(mFP.eta()-alpha); /*VP*/
-  mFP._sinCA = sin(mFP.eta());
-  mFP._cosCA = cos(mFP.eta());
-#ifdef Sti_DEBUG  
-  TRSymMatrix C(kNPars,mFE.A);
-  if (debug() & 4) {PrPP(rotate,C);}
+   assert(fDerivTestOn != -10 || _state >= kTNReady);
+   mMtx().A[0][0] = 0;
+
+   if (fabs(alpha) < 1.e-6) return 0;
+
+   _state = kTNRotBeg;
+   _alpha += alpha;
+   _alpha = nice(_alpha);
+   //cout << "    new  _alpha:"<< 180.*_alpha/3.1415927<<endl;
+
+   double xt1 = mFP.x();
+   double yt1 = mFP.y();
+   mgP.sinCA1 = mFP._sinCA;
+   mgP.cosCA1 = mFP._cosCA;
+   double ca = cos(alpha);
+   double sa = sin(alpha);
+   mFP.x() = xt1 * ca + yt1 * sa;
+   mFP.y() = -xt1 * sa + yt1 * ca;
+   mFP._cosCA =  mgP.cosCA1 * ca + mgP.sinCA1 * sa;
+   mFP._sinCA = -mgP.cosCA1 * sa + mgP.sinCA1 * ca;
+   double nor = 0.5 * (mFP._sinCA * mFP._sinCA + mFP._cosCA * mFP._cosCA + 1);
+   mFP._cosCA /= nor;
+   mFP._sinCA /= nor;
+
+   mFP.eta() = nice(mFP.eta() - alpha); /*VP*/
+   mFP._sinCA = sin(mFP.eta());
+   mFP._cosCA = cos(mFP.eta());
+#ifdef Sti_DEBUG
+   TRSymMatrix C(kNPars, mFE.A);
+
+   if (debug() & 4) {PrPP(rotate, C);}
+
 #endif
-//cout << " mFP._sinCA:"<<mFP._sinCA<<endl;
-  assert(fabs(mFP._sinCA)<=1.);
-  assert(fabs(mFP._cosCA)<=1.);
-  memset(mMtx().A,0,sizeof(mMtx()));
-  mMtx().A[0][0]= ca-1;
-  mMtx().A[0][1]= sa;
-  mMtx().A[1][0]=-sa;
-  mMtx().A[1][1]= ca-1;
-
-  _state = kTNRotEnd;
-  mPP() = mFP;
-  return 0;
+   //cout << " mFP._sinCA:"<<mFP._sinCA<<endl;
+   assert(fabs(mFP._sinCA) <= 1.);
+   assert(fabs(mFP._cosCA) <= 1.);
+   memset(mMtx().A, 0, sizeof(mMtx()));
+   mMtx().A[0][0] = ca - 1;
+   mMtx().A[0][1] = sa;
+   mMtx().A[1][0] = -sa;
+   mMtx().A[1][1] = ca - 1;
+
+   _state = kTNRotEnd;
+   mPP() = mFP;
+   return 0;
 }
 
 
 //_____________________________________________________________________________
-/// print to the ostream "os" the parameters of this node 
+/// print to the ostream "os" the parameters of this node
 /// and all its children recursively
-ostream& operator<<(ostream& os, const StiKalmanTrackNode& n)
+ostream &operator<<(ostream &os, const StiKalmanTrackNode &n)
 {
-  const StiDetector *det = n.getDetector();
-  if (det) os  <<"Det:"<<n.getDetector()->getName();
-  else     os << "Det:UNknown";
-  os << " a:" << 180*n._alpha/M_PI<<" degs"
-     << "\tx:" << n.mFP.x()
-     << " p0:" << n.mFP.y() 
-     << " p1:" << n.mFP.z() 
-     << " p2:" << n.mFP.eta() 
-     << " p3:" << n.mFP.ptin() 
-     << " p4:" << n.mFP.tanl()
-     << " c00:" <<n.mFE._cYY<< " c11:"<<n.mFE._cZZ 
-     << " pT:" << n.getPt() << endl;
-  if (n.debug() & 2) {
-    StiHit * hit = n.getHit();
-    if (hit) os << "\thas hit with chi2 = " << n.getChi2()
-		<< " n:"<<n.hitCount
-		<< " null:"<<n.nullCount
-		<< endl<<"\t hit:"<<*hit;
-  }
-  else os << endl;
-  return os;
+   const StiDetector *det = n.getDetector();
+
+   if (det) os  << "Det:" << n.getDetector()->getName();
+   else     os << "Det:UNknown";
+
+   os << " a:" << 180 * n._alpha / M_PI << " degs"
+      << "\tx:" << n.mFP.x()
+      << " p0:" << n.mFP.y()
+      << " p1:" << n.mFP.z()
+      << " p2:" << n.mFP.eta()
+      << " p3:" << n.mFP.ptin()
+      << " p4:" << n.mFP.tanl()
+      << " c00:" << n.mFE._cYY << " c11:" << n.mFE._cZZ
+      << " pT:" << n.getPt() << endl;
+
+   if (n.debug() & 2) {
+      StiHit *hit = n.getHit();
+
+      if (hit) os << "\thas hit with chi2 = " << n.getChi2()
+                     << " n:" << n.hitCount
+                     << " null:" << n.nullCount
+                     << endl << "\t hit:" << *hit;
+   }
+   else os << endl;
+
+   return os;
 }
 
 //______________________________________________________________________________
 double StiKalmanTrackNode::getWindowY()
-{	  
-  const StiDetector * detector = getDetector();
-  const StiTrackingParameters * parameters = detector->getTrackingParameters();
-  double searchWindowScale = parameters->getSearchWindowScale();
-  double minSearchWindow   = parameters->getMinSearchWindow();
-  double maxSearchWindow   = parameters->getMaxSearchWindow();
-
-  const StiHitErrorCalculator * calc = detector->getHitErrorCalculator();
-  double myEyy,myEzz;
-  calc->calculateError(&mFP,myEyy,myEzz);
-  double window = searchWindowScale*::sqrt(mFE._cYY+myEyy);
-  if      (window<minSearchWindow) window = minSearchWindow;
-  else if (window>maxSearchWindow) window = maxSearchWindow;
-  return window;
+{
+   const StiDetector *detector = getDetector();
+   const StiTrackingParameters *parameters = detector->getTrackingParameters();
+   double searchWindowScale = parameters->getSearchWindowScale();
+   double minSearchWindow   = parameters->getMinSearchWindow();
+   double maxSearchWindow   = parameters->getMaxSearchWindow();
+
+   const StiHitErrorCalculator *calc = detector->getHitErrorCalculator();
+   double myEyy, myEzz;
+   calc->calculateError(&mFP, myEyy, myEzz);
+   double window = searchWindowScale*::sqrt(mFE._cYY + myEyy);
+
+   if      (window < minSearchWindow) window = minSearchWindow;
+   else if (window > maxSearchWindow) window = maxSearchWindow;
+
+   return window;
 }
 
 //_____________________________________________________________________________
 double StiKalmanTrackNode::getWindowZ()
-{	 
-  const StiDetector * detector = getDetector();
-  const StiTrackingParameters * parameters = detector->getTrackingParameters();
-  double searchWindowScale = parameters->getSearchWindowScale();
-  double minSearchWindow   = parameters->getMinSearchWindow();
-  double maxSearchWindow   = parameters->getMaxSearchWindow();
-
-  const StiHitErrorCalculator * calc = detector->getHitErrorCalculator();
-  double myEyy,myEzz;
-  calc->calculateError(&mFP,myEyy,myEzz);
-  
-  double window = searchWindowScale*::sqrt(mFE._cZZ+myEzz); 
-  if      (window<minSearchWindow) window = minSearchWindow;
-  else if (window>maxSearchWindow) window = maxSearchWindow;
-  return window;
+{
+   const StiDetector *detector = getDetector();
+   const StiTrackingParameters *parameters = detector->getTrackingParameters();
+   double searchWindowScale = parameters->getSearchWindowScale();
+   double minSearchWindow   = parameters->getMinSearchWindow();
+   double maxSearchWindow   = parameters->getMaxSearchWindow();
+
+   const StiHitErrorCalculator *calc = detector->getHitErrorCalculator();
+   double myEyy, myEzz;
+   calc->calculateError(&mFP, myEyy, myEzz);
+
+   double window = searchWindowScale*::sqrt(mFE._cZZ + myEzz);
+
+   if      (window < minSearchWindow) window = minSearchWindow;
+   else if (window > maxSearchWindow) window = maxSearchWindow;
+
+   return window;
 }
 
 //______________________________________________________________________________
 StThreeVector<double> StiKalmanTrackNode::getHelixCenter() const
 {
-  if (mFP.curv()==0) throw logic_error("StiKalmanTrackNode::getHelixCenter() -F- _curv==0 ");
-  double xt0 = mFP.x()-mFP._sinCA/mFP.curv();   /*VP*/
-  double yt0 = mFP.y()+mFP._cosCA/(mFP.curv());
-  double zt0 = mFP.z()+mFP.tanl()*asin(mFP._sinCA)/mFP.curv();
-  double cosAlpha = cos(_alpha);
-  double sinAlpha = sin(_alpha);
-  return (StThreeVector<double>(cosAlpha*xt0-sinAlpha*yt0,sinAlpha*xt0+cosAlpha*yt0,zt0));
+   if (mFP.curv() == 0) throw logic_error("StiKalmanTrackNode::getHelixCenter() -F- _curv==0 ");
+
+   double xt0 = mFP.x() - mFP._sinCA / mFP.curv(); /*VP*/
+   double yt0 = mFP.y() + mFP._cosCA / (mFP.curv());
+   double zt0 = mFP.z() + mFP.tanl() * asin(mFP._sinCA) / mFP.curv();
+   double cosAlpha = cos(_alpha);
+   double sinAlpha = sin(_alpha);
+   return (StThreeVector<double>(cosAlpha * xt0 - sinAlpha * yt0, sinAlpha * xt0 + cosAlpha * yt0, zt0));
 }
 //______________________________________________________________________________
 int StiKalmanTrackNode::locate()
 {
-  int position;
-  double yOff, yAbsOff, detHW, detHD,edge,innerY, outerY, innerZ, outerZ, zOff, zAbsOff;
-  //fast way out for projections going out of fiducial volume
-  const StiDetector *tDet = getDetector();
-  if (!tDet) return 0;
-  const StiPlacement *place = tDet->getPlacement();
-  const StiShape     *sh    = tDet->getShape();
-  double kNStd = (tDet->isActive() ? 5 : 0 ); // GVB: avoid seeing too much inactive material
-
-  if (fabs(mFP.z())>kMaxZ || fabs(mFP.y())> kMaxR) return -1;
-  
+   int position;
+   double yOff, yAbsOff, detHW, detHD, edge, innerY, outerY, innerZ, outerZ, zOff, zAbsOff;
+   //fast way out for projections going out of fiducial volume
+   const StiDetector *tDet = getDetector();
+
+   if (!tDet) return 0;
+
+   const StiPlacement *place = tDet->getPlacement();
+   const StiShape     *sh    = tDet->getShape();
+
+   double kNStd = (tDet->isActive() ? 5 : 0 ); // GVB: avoid seeing too much inactive material
+
+   if (fabs(mFP.z()) > kMaxZ || fabs(mFP.y()) > kMaxR) return -1;
+
 #ifndef DO_TPCCATRACKER // insensible region on a detector plane
-  edge  = 2.;
-  if (mFP.x()<50.)      edge  = 0.3;
+   edge  = 2.;
+
+   if (mFP.x() < 50.)      edge  = 0.3;
+
 #else /* DO_TPCCATRACKER */
-  edge = 0.;
+   edge = 0.;
 #endif /* !DO_TPCCATRACKER */
-  
-  //YF edge is tolerance when we consider that detector is hit. //  edge = 0; //VP the meaning of edge is not clear
-  Int_t shapeCode  = sh->getShapeCode();
-  switch (shapeCode) {
-  case kDisk:
-  case kCylindrical: // cylinder
-    yOff    = nice(_alpha - place->getLayerAngle());
-    yAbsOff = fabs(yOff);
-    yAbsOff -=kNStd*sqrt((mFE._cXX+mFE._cYY)/(mFP.x()*mFP.x()+mFP.y()*mFP.y()));
-    if (yAbsOff<0) yAbsOff=0;
-    detHW = ((StiCylindricalShape *) sh)->getOpeningAngle()/2.;
-    innerY = outerY = detHW;
-    break;
-  case kPlanar: 
-  default:
-    yOff = mFP.y() - place->getNormalYoffset();
-    yAbsOff = fabs(yOff) - kNStd*sqrt(mFE._cYY);
-    if (yAbsOff<0) yAbsOff=0;
-    detHW = sh->getHalfWidth();
-    innerY = detHW - edge;
-    //outerY = innerY + 2*edge;
-    //outerZ = innerZ + 2*edge;
-    outerY = innerY + edge;
-    break;
-  }
-  zOff = mFP.z() - place->getZcenter();
-  zAbsOff = fabs(zOff);
-  detHD = sh->getHalfDepth();
-  innerZ = detHD - edge;
-  outerZ = innerZ + edge;
-  if (yAbsOff<innerY && zAbsOff<innerZ)
-    position = kHit; 
-  else if (yAbsOff>outerY && (yAbsOff-outerY)>(zAbsOff-outerZ))
-    // outside detector to positive or negative y (phi)
-    // if the track is essentially tangent to the plane, terminate it.
-      position = yOff>0 ? kMissPhiPlus : kMissPhiMinus;
-  else if (zAbsOff>outerZ && (zAbsOff-outerZ)>(yAbsOff-outerY))
-    // outside detector to positive or negative z (west or east)
-    position = zOff>0 ? kMissZplus : kMissZminus;
-  else if ((yAbsOff-innerY)>(zAbsOff-innerZ))
-    // positive or negative phi edge
-    position = yOff>0 ? kEdgePhiPlus : kEdgePhiMinus;
-  else
-    // positive or negative z edge
-    position = zOff>0 ? kEdgeZplus : kEdgeZminus;
-  if (debug()&8) {
-    comment += ::Form("R %8.3f y/z %8.3f/%8.3f", 
-		      mFP.x(), mFP.y(), mFP.z());
-    if (position>kEdgeZplus || position<0)  
-      comment += ::Form(" missed %2d y0/z0 %8.3f/%8.3f dY/dZ %8.3f/%8.3f",
-			position, yOff, zOff, detHW, detHD);
-  }
-  return position;
- }
+
+   //YF edge is tolerance when we consider that detector is hit. //  edge = 0; //VP the meaning of edge is not clear
+   Int_t shapeCode  = sh->getShapeCode();
+
+   switch (shapeCode) {
+   case kDisk:
+   case kCylindrical: // cylinder
+      yOff    = nice(_alpha - place->getLayerAngle());
+      yAbsOff = fabs(yOff);
+      yAbsOff -= kNStd * sqrt((mFE._cXX + mFE._cYY) / (mFP.x() * mFP.x() + mFP.y() * mFP.y()));
+
+      if (yAbsOff < 0) yAbsOff = 0;
+
+      detHW = ((StiCylindricalShape *) sh)->getOpeningAngle() / 2.;
+      innerY = outerY = detHW;
+      break;
+
+   case kPlanar:
+   default:
+      yOff = mFP.y() - place->getNormalYoffset();
+      yAbsOff = fabs(yOff) - kNStd * sqrt(mFE._cYY);
+
+      if (yAbsOff < 0) yAbsOff = 0;
+
+      detHW = sh->getHalfWidth();
+      innerY = detHW - edge;
+      //outerY = innerY + 2*edge;
+      //outerZ = innerZ + 2*edge;
+      outerY = innerY + edge;
+      break;
+   }
+
+   zOff = mFP.z() - place->getZcenter();
+   zAbsOff = fabs(zOff);
+   detHD = sh->getHalfDepth();
+   innerZ = detHD - edge;
+   outerZ = innerZ + edge;
+
+   if (yAbsOff < innerY && zAbsOff < innerZ)
+      position = kHit;
+   else if (yAbsOff > outerY && (yAbsOff - outerY) > (zAbsOff - outerZ))
+      // outside detector to positive or negative y (phi)
+      // if the track is essentially tangent to the plane, terminate it.
+      position = yOff > 0 ? kMissPhiPlus : kMissPhiMinus;
+   else if (zAbsOff > outerZ && (zAbsOff - outerZ) > (yAbsOff - outerY))
+      // outside detector to positive or negative z (west or east)
+      position = zOff > 0 ? kMissZplus : kMissZminus;
+   else if ((yAbsOff - innerY) > (zAbsOff - innerZ))
+      // positive or negative phi edge
+      position = yOff > 0 ? kEdgePhiPlus : kEdgePhiMinus;
+   else
+      // positive or negative z edge
+      position = zOff > 0 ? kEdgeZplus : kEdgeZminus;
+
+   if (debug() & 8) {
+      comment += ::Form("R %8.3f y/z %8.3f/%8.3f",
+                        mFP.x(), mFP.y(), mFP.z());
+
+      if (position > kEdgeZplus || position < 0)
+         comment += ::Form(" missed %2d y0/z0 %8.3f/%8.3f dY/dZ %8.3f/%8.3f",
+                           position, yOff, zOff, detHW, detHD);
+   }
+
+   return position;
+}
 //______________________________________________________________________________
 void StiKalmanTrackNode::initialize(StiHit *h)
 {
-  reset();
-  setHit(h);
-  _detector = h->detector();
-  _alpha   = _detector->getPlacement()->getNormalRefAngle(); 
-  mFP._sinCA = 0.6;
-  mFP._cosCA = 0.8;
-  mFP.x() = h->x();
-  mFP.y() = h->y();
-  mFP.z() = h->z();
-  mFP.hz() = getHz();
-  resetError();
-  mPP() = mFP;
-  setHitErrors();
-  _state = kTNInit;
-  setChi2(0.1);
+   reset();
+   setHit(h);
+   _detector = h->detector();
+   _alpha   = _detector->getPlacement()->getNormalRefAngle();
+   mFP._sinCA = 0.6;
+   mFP._cosCA = 0.8;
+   mFP.x() = h->x();
+   mFP.y() = h->y();
+   mFP.z() = h->z();
+   mFP.hz() = getHz();
+   resetError();
+   mPP() = mFP;
+   setHitErrors();
+   _state = kTNInit;
+   setChi2(0.1);
 }
 //______________________________________________________________________________
 void StiKalmanTrackNode::initialize(StiDetector *d)
 {
-  reset();
-  _detector = d;
-  _alpha   = _detector->getPlacement()->getNormalRefAngle(); 
-  _state = kTNInit;
-  setChi2(1e10);
+   reset();
+   _detector = d;
+   _alpha   = _detector->getPlacement()->getNormalRefAngle();
+   _state = kTNInit;
+   setChi2(1e10);
 }
 //______________________________________________________________________________
 StiKalmanTrackNode::StiKalmanTrackNode(const StiKalmanTrackNode &n)
 {
-   _ext=0; _inf=0 ; *this = n;
+   _ext = 0; _inf = 0 ; *this = n;
 }
 //______________________________________________________________________________
-const StiKalmanTrackNode& StiKalmanTrackNode::operator=(const StiKalmanTrackNode &n)
+const StiKalmanTrackNode &StiKalmanTrackNode::operator=(const StiKalmanTrackNode &n)
 {
-  StiTrackNode::operator=(n);
-  memcpy(_beg,n._beg,_end-_beg+1);
-  if (n._ext) { extend();*_ext = *n._ext;}
-  else        { if(_ext) _ext->reset();  }
-  if (n._inf) { extinf();*_inf = *n._inf;}
-  else        { if(_inf) {BFactory::Free(_inf); _inf=0;}}
-  return *this;
+   StiTrackNode::operator=(n);
+   memcpy(_beg, n._beg, _end - _beg + 1);
+
+   if (n._ext) { extend(); *_ext = *n._ext;}
+   else        { if (_ext) _ext->reset();  }
+
+   if (n._inf) { extinf(); *_inf = *n._inf;}
+   else        { if (_inf) {BFactory::Free(_inf); _inf = 0;}}
+
+   return *this;
 }
 //______________________________________________________________________________
 void StiKalmanTrackNode::setHitErrors(const StiHit *hit)
 {
-  if (!hit) hit = _hit;
-  assert(hit);
-  StiTrackNodeHelper::getHitErrors(hit,&mFP,&mHrr);
+   if (!hit) hit = _hit;
+
+   assert(hit);
+   StiTrackNodeHelper::getHitErrors(hit, &mFP, &mHrr);
 }
 //______________________________________________________________________________
 StiHitErrs StiKalmanTrackNode::getGlobalHitErrs(const StiHit *hit) const
 {
    StiHitErrs hr;
-   StiTrackNodeHelper::getHitErrors(hit,&mFP,&hr);
+   StiTrackNodeHelper::getHitErrors(hit, &mFP, &hr);
    hr.rotate(_alpha);
    return hr;
 }
@@ -1931,354 +2110,444 @@ StiHitErrs StiKalmanTrackNode::getGlobalHitErrs(const StiHit *hit) const
 //______________________________________________________________________________
 int StiKalmanTrackNode::testError(double *emx, int begend)
 {
-// Test and correct error matrix. Output : number of fixes
-// DO NOT IMPROVE weird if() here. This accounts NaN
-
-
-  static int nCall=0; nCall++;
-  static const double dia[6] = { 1000.,1000., 1000.,1000.,1000,1000.};
-  static double emxBeg[kNErrs];
-//return 0;
-  if (!begend) { memcpy(emxBeg,emx,sizeof(emxBeg));}
-  int ians=0,j1,j2,jj;
-  for (j1=0; j1<5;j1++){
-    jj = idx55[j1][j1];
-    if (!(emx[jj]>0)) {;
-      LOG_DEBUG << Form("<StiKalmanTrackNode::testError> Negative diag %g[%d][%d]",emx[jj],j1,j1)
-      << endm;
- 	continue;}
-    if (emx[jj]<=10*dia[j1] )	continue;
-    assert(finite(emx[jj]));
-    LOG_DEBUG << Form("<StiKalmanTrackNode::testError> Huge diag %g[%d][%d]",emx[jj],j1,j1)
-    << endm;
-    				continue;
-//    ians++; emx[jj]=dia[j1];
-//    for (j2=0; j2<5;j2++){if (j1!=j2) emx[idx55[j1][j2]]=0;}
-  }
-  for (j1=0; j1< 5;j1++){
-  for (j2=0; j2<j1;j2++){
-    jj = idx55[j1][j2];
-    assert(finite(emx[jj]));
-    double cormax = emx[idx55[j1][j1]]*emx[idx55[j2][j2]];
-    if (emx[jj]*emx[jj]<cormax) continue;
-    cormax= sqrt(cormax);
-//    ians++;emx[jj]= (emx[jj]<0) ? -cormax:cormax;
-  }}
-  return ians;
+   // Test and correct error matrix. Output : number of fixes
+   // DO NOT IMPROVE weird if() here. This accounts NaN
+
+
+   static int nCall = 0; nCall++;
+   static const double dia[6] = { 1000., 1000., 1000., 1000., 1000, 1000.};
+   static double emxBeg[kNErrs];
+
+   //return 0;
+   if (!begend) { memcpy(emxBeg, emx, sizeof(emxBeg));}
+
+   int ians = 0, j1, j2, jj;
+
+   for (j1 = 0; j1 < 5; j1++) {
+      jj = idx55[j1][j1];
+
+      if (!(emx[jj] > 0)) {
+         ;
+         LOG_DEBUG << Form("<StiKalmanTrackNode::testError> Negative diag %g[%d][%d]", emx[jj], j1, j1)
+                   << endm;
+         continue;
+      }
+
+      if (emx[jj] <= 10 * dia[j1] )	continue;
+
+      assert(finite(emx[jj]));
+      LOG_DEBUG << Form("<StiKalmanTrackNode::testError> Huge diag %g[%d][%d]", emx[jj], j1, j1)
+                << endm;
+      continue;
+      //    ians++; emx[jj]=dia[j1];
+      //    for (j2=0; j2<5;j2++){if (j1!=j2) emx[idx55[j1][j2]]=0;}
+   }
+
+   for (j1 = 0; j1 < 5; j1++) {
+      for (j2 = 0; j2 < j1; j2++) {
+         jj = idx55[j1][j2];
+         assert(finite(emx[jj]));
+         double cormax = emx[idx55[j1][j1]] * emx[idx55[j2][j2]];
+
+         if (emx[jj]*emx[jj] < cormax) continue;
+
+         cormax = sqrt(cormax);
+         //    ians++;emx[jj]= (emx[jj]<0) ? -cormax:cormax;
+      }
+   }
+
+   return ians;
 }
 #endif//0
 //______________________________________________________________________________
-void StiKalmanTrackNode::numeDeriv(double val,int kind,int shape,int dir)
+void StiKalmanTrackNode::numeDeriv(double val, int kind, int shape, int dir)
 {
-   double maxStep[kNPars]={0.1,0.1,0.1,0.01,0.001,0.01};
-   if (fDerivTestOn<0) return;
+   double maxStep[kNPars] = {0.1, 0.1, 0.1, 0.01, 0.001, 0.01};
+
+   if (fDerivTestOn < 0) return;
+
    gCurrShape = shape;
-   fDerivTestOn=-1;
+   fDerivTestOn = -1;
    double save[20];
    StiKalmanTrackNode myNode;
    double *pars = &myNode.mFP.x();
-   int state=0;
+   int state = 0;
    saveStatics(save);
-   if (fabs(mFP.curv())> 0.02) goto FAIL;
+
+   if (fabs(mFP.curv()) > 0.02) goto FAIL;
+
    int ipar;
-   for (ipar=1;ipar<kNPars;ipar++)
-   {
-     for (int is=-1;is<=1;is+=2) {
-       myNode = *this;
-       backStatics(save);
-       double step = 0.1*sqrt((mFE.A)[idx66[ipar][ipar]]);
-       if (step>maxStep[ipar]) step = maxStep[ipar];
-//       if (step>0.1*fabs(pars[ipar])) step = 0.1*pars[ipar];
-//       if (fabs(step)<1.e-7) step = 1.e-7;
-       pars[ipar] +=step*is;
-// 		Update sinCA & cosCA       
-       myNode.mFP._sinCA = sin(myNode.mFP.eta());
-       if (fabs(myNode.mFP._sinCA) > 0.9) goto FAIL;
-       myNode.mFP._cosCA = cos(myNode.mFP.eta());
-       
-       switch (kind) {
-	 case 1: //propagate
-	   state = myNode.propagate(val,shape,dir); break;
-	 case 2: //rotate
-	   state = myNode.rotate(val);break;
-	 default: assert(0);  
-       }  
-       if(state  ) goto FAIL;
-
-       for (int jpar=1;jpar<kNPars;jpar++) {
-	 if (is<0) {
-	   fDerivTest[jpar][ipar]= pars[jpar];
-	 } else      {
-	   double tmp = fDerivTest[jpar][ipar];
-	   fDerivTest[jpar][ipar] = (pars[jpar]-tmp)/(2.*step);
-	   if (ipar==jpar) fDerivTest[jpar][ipar]-=1.;
+
+   for (ipar = 1; ipar < kNPars; ipar++) {
+      for (int is = -1; is <= 1; is += 2) {
+         myNode = *this;
+         backStatics(save);
+         double step = 0.1 * sqrt((mFE.A)[idx66[ipar][ipar]]);
+
+         if (step > maxStep[ipar]) step = maxStep[ipar];
+
+         //       if (step>0.1*fabs(pars[ipar])) step = 0.1*pars[ipar];
+         //       if (fabs(step)<1.e-7) step = 1.e-7;
+         pars[ipar] += step * is;
+         // 		Update sinCA & cosCA
+         myNode.mFP._sinCA = sin(myNode.mFP.eta());
+
+         if (fabs(myNode.mFP._sinCA) > 0.9) goto FAIL;
+
+         myNode.mFP._cosCA = cos(myNode.mFP.eta());
+
+         switch (kind) {
+         case 1: //propagate
+            state = myNode.propagate(val, shape, dir); break;
+
+         case 2: //rotate
+            state = myNode.rotate(val); break;
+
+         default: assert(0);
          }
-       }
-     }
+
+         if (state  ) goto FAIL;
+
+         for (int jpar = 1; jpar < kNPars; jpar++) {
+            if (is < 0) {
+               fDerivTest[jpar][ipar] = pars[jpar];
+            }
+            else      {
+               double tmp = fDerivTest[jpar][ipar];
+               fDerivTest[jpar][ipar] = (pars[jpar] - tmp) / (2.*step);
+
+               if (ipar == jpar) fDerivTest[jpar][ipar] -= 1.;
+            }
+         }
+      }
    }
-   fDerivTestOn=1;backStatics(save);return;
-FAIL: 
-   fDerivTestOn=0;backStatics(save);return;
+
+   fDerivTestOn = 1; backStatics(save); return;
+FAIL:
+   fDerivTestOn = 0; backStatics(save); return;
 }
 //______________________________________________________________________________
 int StiKalmanTrackNode::testDeriv(double *der)
 {
-   if (fDerivTestOn!=1) return 0;
+   if (fDerivTestOn != 1) return 0;
+
    double *num = fDerivTest[0];
    int nerr = 0;
-   for (int i=1;i<kNErrs;i++) {
-     int ipar = i/kNPars;
-     int jpar = i%kNPars;
-     if (ipar==jpar)					continue;
-     if (ipar==0)					continue;
-     if (jpar==0)					continue;
-     double dif = fabs(num[i]-der[i]);
-     if (fabs(dif) <= 1.e-5) 				continue;
-     if (fabs(dif) <= 0.2*0.5*fabs(num[i]+der[i]))	continue;
-     nerr++;
-     LOG_DEBUG << Form("***Wrong deriv [%d][%d] = %g %g %g",ipar,jpar,num[i],der[i],dif)
-     << endm;
-  }
-  fDerivTestOn=0;
-  return nerr;
+
+   for (int i = 1; i < kNErrs; i++) {
+      int ipar = i / kNPars;
+      int jpar = i % kNPars;
+
+      if (ipar == jpar)					continue;
+
+      if (ipar == 0)					continue;
+
+      if (jpar == 0)					continue;
+
+      double dif = fabs(num[i] - der[i]);
+
+      if (fabs(dif) <= 1.e-5) 				continue;
+
+      if (fabs(dif) <= 0.2 * 0.5 * fabs(num[i] + der[i]))	continue;
+
+      nerr++;
+      LOG_DEBUG << Form("***Wrong deriv [%d][%d] = %g %g %g", ipar, jpar, num[i], der[i], dif)
+                << endm;
+   }
+
+   fDerivTestOn = 0;
+   return nerr;
 }
 //______________________________________________________________________________
 void StiKalmanTrackNode::saveStatics(double *sav)
-{  
-  sav[ 0]=mgP.x1;
-  sav[ 1]=mgP.x2; 
-  sav[ 2]=mgP.y1; 
-  sav[ 3]=mgP.y2; 
-  sav[ 5]=mgP.dx; 
-  sav[ 6]=mgP.cosCA1; 
-  sav[ 7]=mgP.sinCA1; 
-  sav[ 8]=mgP.cosCA2; 
-  sav[ 9]=mgP.sinCA2; 
-  sav[10]=mgP.sumSin; 
-  sav[11]=mgP.sumCos; 
-  sav[14]=mgP.dl; 
-  sav[15]=mgP.dl0; 
-  sav[16]=mgP.dy; 
-}  
+{
+   sav[ 0] = mgP.x1;
+   sav[ 1] = mgP.x2;
+   sav[ 2] = mgP.y1;
+   sav[ 3] = mgP.y2;
+   sav[ 5] = mgP.dx;
+   sav[ 6] = mgP.cosCA1;
+   sav[ 7] = mgP.sinCA1;
+   sav[ 8] = mgP.cosCA2;
+   sav[ 9] = mgP.sinCA2;
+   sav[10] = mgP.sumSin;
+   sav[11] = mgP.sumCos;
+   sav[14] = mgP.dl;
+   sav[15] = mgP.dl0;
+   sav[16] = mgP.dy;
+}
 //______________________________________________________________________________
 void StiKalmanTrackNode::backStatics(double *sav)
-{  
-  mgP.x1=             sav[ 0];
-  mgP.x2= 		  sav[ 1]; 
-  mgP.y1= 		  sav[ 2]; 
-  mgP.y2= 		  sav[ 3]; 
-  mgP.dx= 	  sav[ 5]; 
-  mgP.cosCA1= 	  sav[ 6]; 
-  mgP.sinCA1= 	  sav[ 7]; 
-  mgP.cosCA2= 	  sav[ 8]; 
-  mgP.sinCA2= 	  sav[ 9]; 
-  mgP.sumSin= 	  sav[10]; 
-  mgP.sumCos= 	  sav[11]; 
-  mgP.dl=             sav[14];
-  mgP.dl0=            sav[15];
-  mgP.dy=             sav[16];
+{
+   mgP.x1 =             sav[ 0];
+   mgP.x2 = 		  sav[ 1];
+   mgP.y1 = 		  sav[ 2];
+   mgP.y2 = 		  sav[ 3];
+   mgP.dx = 	  sav[ 5];
+   mgP.cosCA1 = 	  sav[ 6];
+   mgP.sinCA1 = 	  sav[ 7];
+   mgP.cosCA2 = 	  sav[ 8];
+   mgP.sinCA2 = 	  sav[ 9];
+   mgP.sumSin = 	  sav[10];
+   mgP.sumCos = 	  sav[11];
+   mgP.dl =             sav[14];
+   mgP.dl0 =            sav[15];
+   mgP.dy =             sav[16];
 }
 //________________________________________________________________________________
-void   StiKalmanTrackNode::PrintpT(const Char_t *opt) const {
-  // opt = "E" extapolation
-  //       "M" Multiple scattering
-  //       "V" at Vertex
-  //       "B" at beam
-  //       "R" at Radius
-  //       "U" Updated
-  //       mFP fit parameters
-  //       mFE fit errors
-  //       _ext->mPP 
-  //       _ext->mPE
-  //       _ext->mMtx
-  Double_t dpTOverpT = 100*TMath::Sqrt(mFE._cPP/(mFP.ptin()*mFP.ptin()));
-  if (dpTOverpT > 9999.9) dpTOverpT = 9999.9;
-  comment += ::Form(" %s pT %8.3f+-%6.1f sy %6.4f",opt,getPt(),dpTOverpT,TMath::Sqrt(mFE._cYY));
+void   StiKalmanTrackNode::PrintpT(const Char_t *opt) const
+{
+   // opt = "E" extapolation
+   //       "M" Multiple scattering
+   //       "V" at Vertex
+   //       "B" at beam
+   //       "R" at Radius
+   //       "U" Updated
+   //       mFP fit parameters
+   //       mFE fit errors
+   //       _ext->mPP
+   //       _ext->mPE
+   //       _ext->mMtx
+   Double_t dpTOverpT = 100 * TMath::Sqrt(mFE._cPP / (mFP.ptin() * mFP.ptin()));
+
+   if (dpTOverpT > 9999.9) dpTOverpT = 9999.9;
+
+   comment += ::Form(" %s pT %8.3f+-%6.1f sy %6.4f", opt, getPt(), dpTOverpT, TMath::Sqrt(mFE._cYY));
 }
 //________________________________________________________________________________
-void StiKalmanTrackNode::PrintStep() {
-  LOG_INFO << comment << "\t" << commentdEdx << endm;
-  ResetComment();
+void StiKalmanTrackNode::PrintStep()
+{
+   LOG_INFO << comment << "\t" << commentdEdx << endm;
+   ResetComment();
 }
 //________________________________________________________________________________
 int   StiKalmanTrackNode::print(const char *opt) const
 {
-static const char *txt = "xyzeptchXYZEPTCH";
-static const char *hhh = "uvwUVW";
-static const char *HHH = "xyzXYZ";
-  if (!opt || !opt[0]) opt = "2xh";
-  StiHit *hit = getHit();
-  if (strchr(opt,'h') && !hit) 	return 0;
-  TString ts;
-  if (!isValid()) ts+="*";
-  if (hit) {ts+=(getChi2()>1e3)? "h":"H";}
-  printf("%p(%s)",(void*)this,ts.Data());
-  if (strchr(opt,'2')) printf("\t%s=%g","ch2",getChi2());
-
-  for (int i=0;txt[i];i++) {
-    if (!strchr(opt,txt[i])) continue;
-    int j = i%8;
-    double val=0,err=0;
-    if (i<=8 || i>11) { //local coord
-      val = mFP[j];
-      int jj = idx66[j][j];
-      err=0;
-      if (j<6) {err = sqrt(fabs(mFE.A[jj])); if (mFE.A[jj]<0) err*= -1;}
-    } else {//global coordinate
-      switch (j) {
-        case 0: val = x_g(); 	break;
-        case 1: val = y_g(); 	break;
-        case 2: val = z_g(); 	break;
-        case 3: val = getPsi();	break;
-    } }
-    printf("\t%c=%g",txt[i],val);
-    if (err) printf("(%6.1g)",err);
-  }//end for i
-
-  for (int i=0;hit && hhh[i];i++) {
-    if (!strchr(opt,hhh[i])) continue;
-    double val=0,err=0;
-    switch(i) {
-      case 0:val = hit->x(); 	break;
-      case 1:val = hit->y(); 	err = ::sqrt(getEyy());break;
-      case 2:val = hit->z(); 	err = ::sqrt(getEzz());break;
-      case 3:val = hit->x_g(); 	break;
-      case 4:val = hit->y_g(); 	break;
-      case 5:val = hit->z_g();	err = ::sqrt(getEzz());break;
-    }
-    printf("\th%c=%g",HHH[i],val);
-    if (err) printf("(%6.1g)",err);
-  }
-  printf("\n");
-  return 1;
-}    
+   static const char *txt = "xyzeptchXYZEPTCH";
+   static const char *hhh = "uvwUVW";
+   static const char *HHH = "xyzXYZ";
+
+   if (!opt || !opt[0]) opt = "2xh";
+
+   StiHit *hit = getHit();
+
+   if (strchr(opt, 'h') && !hit) 	return 0;
+
+   TString ts;
+
+   if (!isValid()) ts += "*";
+
+   if (hit) {ts += (getChi2() > 1e3) ? "h" : "H";}
+
+   printf("%p(%s)", (void *)this, ts.Data());
+
+   if (strchr(opt, '2')) printf("\t%s=%g", "ch2", getChi2());
+
+   for (int i = 0; txt[i]; i++) {
+      if (!strchr(opt, txt[i])) continue;
+
+      int j = i % 8;
+      double val = 0, err = 0;
+
+      if (i <= 8 || i > 11) { //local coord
+         val = mFP[j];
+         int jj = idx66[j][j];
+         err = 0;
+
+         if (j < 6) {err = sqrt(fabs(mFE.A[jj])); if (mFE.A[jj] < 0) err *= -1;}
+      }
+      else {  //global coordinate
+         switch (j) {
+         case 0: val = x_g(); 	break;
+
+         case 1: val = y_g(); 	break;
+
+         case 2: val = z_g(); 	break;
+
+         case 3: val = getPsi();	break;
+         }
+      }
+
+      printf("\t%c=%g", txt[i], val);
+
+      if (err) printf("(%6.1g)", err);
+   }//end for i
+
+   for (int i = 0; hit && hhh[i]; i++) {
+      if (!strchr(opt, hhh[i])) continue;
+
+      double val = 0, err = 0;
+
+      switch (i) {
+      case 0: val = hit->x(); 	break;
+
+      case 1: val = hit->y(); 	err = ::sqrt(getEyy()); break;
+
+      case 2: val = hit->z(); 	err = ::sqrt(getEzz()); break;
+
+      case 3: val = hit->x_g(); 	break;
+
+      case 4: val = hit->y_g(); 	break;
+
+      case 5: val = hit->z_g();	err = ::sqrt(getEzz()); break;
+      }
+
+      printf("\th%c=%g", HHH[i], val);
+
+      if (err) printf("(%6.1g)", err);
+   }
+
+   printf("\n");
+   return 1;
+}
 //________________________________________________________________________________
 StiNodeExt *StiKalmanTrackNode::nodeExtInstance()
-{    
-static StiFactory<StiNodeExt,StiNodeExt> *extFactory=0;
-  if (!extFactory) {
-    extFactory = StiFactory<StiNodeExt,StiNodeExt>::myInstance();
-    extFactory->setMaxIncrementCount(400000);
-    extFactory->setFastDelete();
-  }
-  return extFactory->getInstance();
-}    
+{
+   static StiFactory<StiNodeExt, StiNodeExt> *extFactory = 0;
+
+   if (!extFactory) {
+      extFactory = StiFactory<StiNodeExt, StiNodeExt>::myInstance();
+      extFactory->setMaxIncrementCount(400000);
+      extFactory->setFastDelete();
+   }
+
+   return extFactory->getInstance();
+}
 //________________________________________________________________________________
 StiNodeInf *StiKalmanTrackNode::nodeInfInstance()
-{    
-static StiFactory<StiNodeInf,StiNodeInf> *infFactory=0;
-  if (!infFactory) {
-    infFactory = StiFactory<StiNodeInf,StiNodeInf>::myInstance();
-    infFactory->setMaxIncrementCount(40000);
-    infFactory->setFastDelete();
-  }
-  return infFactory->getInstance();
-}    
+{
+   static StiFactory<StiNodeInf, StiNodeInf> *infFactory = 0;
+
+   if (!infFactory) {
+      infFactory = StiFactory<StiNodeInf, StiNodeInf>::myInstance();
+      infFactory->setMaxIncrementCount(40000);
+      infFactory->setFastDelete();
+   }
+
+   return infFactory->getInstance();
+}
 //________________________________________________________________________________
 void StiKalmanTrackNode::extend()
 {
-  if(_ext) return;
-  _ext =  nodeExtInstance();
+   if (_ext) return;
+
+   _ext =  nodeExtInstance();
 }
 //________________________________________________________________________________
 void StiKalmanTrackNode::extinf()
 {
-  if(_inf) return;
-  _inf =  nodeInfInstance();
+   if (_inf) return;
+
+   _inf =  nodeInfInstance();
 }
 //________________________________________________________________________________
 void StiKalmanTrackNode::saveInfo(int kase)
 {
-  if (kase){};
-  extinf();
-  _inf->mPP = mPP();
-  _inf->mPE = mPE();
-  _inf->mHrr = mHrr;
+   if (kase) {};
+
+   extinf();
+
+   _inf->mPP = mPP();
+
+   _inf->mPE = mPE();
+
+   _inf->mHrr = mHrr;
 }
 
 //________________________________________________________________________________
 void StiKalmanTrackNode::reduce()
 {
-  if(!_ext) return;
-  BFactory::Free(_ext); _ext=0;
+   if (!_ext) return;
+
+   BFactory::Free(_ext); _ext = 0;
 }
 
 
 //________________________________________________________________________________
 StThreeVector<double> StiKalmanTrackNode::getPoint() const
 {
-  return StThreeVector<double>(mFP.x(),mFP.y(),mFP.z());
+   return StThreeVector<double>(mFP.x(), mFP.y(), mFP.z());
 }
 
 //________________________________________________________________________________
 StThreeVector<double> StiKalmanTrackNode::getGlobalPoint() const
 {
-  double ca = cos(_alpha),sa=sin(_alpha);
-  return StThreeVector<double>(ca*mFP.x()-sa*mFP.y(), sa*mFP.x()+ca*mFP.y(), mFP.z());
+   double ca = cos(_alpha), sa = sin(_alpha);
+   return StThreeVector<double>(ca * mFP.x() - sa * mFP.y(), sa * mFP.x() + ca * mFP.y(), mFP.z());
 }
 
 //________________________________________________________________________________
 double StiKalmanTrackNode::x_g() const
 {
-  return cos(_alpha)*mFP.x()-sin(_alpha)*mFP.y();
+   return cos(_alpha) * mFP.x() - sin(_alpha) * mFP.y();
 }
 
 //________________________________________________________________________________
 double StiKalmanTrackNode::y_g() const
 {
-  return sin(_alpha)*mFP.x()+cos(_alpha)*mFP.y();
+   return sin(_alpha) * mFP.x() + cos(_alpha) * mFP.y();
 }
 
 //________________________________________________________________________________
 double StiKalmanTrackNode::z_g() const
 {
-  return mFP.z();
+   return mFP.z();
 }
 
 //________________________________________________________________________________
-void StiKalmanTrackNode::setUntouched() 
+void StiKalmanTrackNode::setUntouched()
 {
-  mUnTouch.set(mPP(),mPE());
+   mUnTouch.set(mPP(), mPE());
 }
 //________________________________________________________________________________
 double StiKalmanTrackNode::getTime() const
 {
-  static const double smax = 1e3; 
-  double time = 0;
-  if (! _laser) {
-    double d = sqrt(mFP.x()*mFP.x()+mFP.y()*mFP.y());
-    double sn = fabs(mFP._cosCA*mFP.y() - mFP._sinCA*mFP.x())/d;
-    if (sn> 0.99) sn =  0.99;
-    if (sn<0.2) {
-      d *= (1.+sn*sn/6);
-    } else {
-      d *= asin(sn)/sn;
-    }
-    d *= sqrt(1.+mFP.tanl()*mFP.tanl());
-    double beta = 1;   
-    double pt = fabs(mFP.ptin());
-    if (pt>0.1) {
-      pt = 1./pt;
-      double p2=(1.+mFP.tanl()*mFP.tanl())*pt*pt;
-      double m=StiKalmanTrackFinderParameters::instance()->massHypothesis();
-      double m2=m*m;
-      double e2=p2+m2;
-      double beta2=p2/e2;
-      beta = TMath::Sqrt(beta2);
-    }
-    time = d/(TMath::Ccgs()*beta*1e-6); // mksec  
-  } else {
-    if (TMath::Abs(mFP.z()) > 20.0) {
-static const double Radius = 197.;
-static const int    nsurf  = 6;
-static const double surf[6] = {-Radius*Radius, 0, 0, 0, 1, 1};
-      double dir[3] = {mFP._cosCA,mFP._sinCA,mFP.tanl()};
-      THelixTrack tc(mFP.P,dir,mFP.curv());
-      double s = tc.Step(smax, surf, nsurf,0,0,1);
-      if (TMath::Abs(s) < smax) 
-	time = TMath::Abs(s)/(TMath::Ccgs()*1e-6); // mksec
-    }
-  }
-  return time;
+   static const double smax = 1e3;
+   double time = 0;
+
+   if (! _laser) {
+      double d = sqrt(mFP.x() * mFP.x() + mFP.y() * mFP.y());
+      double sn = fabs(mFP._cosCA * mFP.y() - mFP._sinCA * mFP.x()) / d;
+
+      if (sn > 0.99) sn =  0.99;
+
+      if (sn < 0.2) {
+         d *= (1. + sn * sn / 6);
+      }
+      else {
+         d *= asin(sn) / sn;
+      }
+
+      d *= sqrt(1. + mFP.tanl() * mFP.tanl());
+      double beta = 1;
+      double pt = fabs(mFP.ptin());
+
+      if (pt > 0.1) {
+         pt = 1. / pt;
+         double p2 = (1. + mFP.tanl() * mFP.tanl()) * pt * pt;
+         double m = StiKalmanTrackFinderParameters::instance()->massHypothesis();
+         double m2 = m * m;
+         double e2 = p2 + m2;
+         double beta2 = p2 / e2;
+         beta = TMath::Sqrt(beta2);
+      }
+
+      time = d / (TMath::Ccgs() * beta * 1e-6); // mksec
+   }
+   else {
+      if (TMath::Abs(mFP.z()) > 20.0) {
+         static const double Radius = 197.;
+         static const int    nsurf  = 6;
+         static const double surf[6] = { -Radius * Radius, 0, 0, 0, 1, 1};
+         double dir[3] = {mFP._cosCA, mFP._sinCA, mFP.tanl()};
+         THelixTrack tc(mFP.P, dir, mFP.curv());
+         double s = tc.Step(smax, surf, nsurf, 0, 0, 1);
+
+         if (TMath::Abs(s) < smax)
+            time = TMath::Abs(s) / (TMath::Ccgs() * 1e-6); // mksec
+      }
+   }
+
+   return time;
 }
 
diff --git a/Sti/StiKalmanTrackNode.h b/Sti/StiKalmanTrackNode.h
index cda4988..3a4cf05 100644
--- a/Sti/StiKalmanTrackNode.h
+++ b/Sti/StiKalmanTrackNode.h
@@ -19,43 +19,46 @@
 class StiDetector;
 class StiMaterial;
 class StiElossCalculator;
-  
+
 typedef enum {
-  kFailed = -1,         // could not find intersection
-  kHit,                                
-  kEdgePhiPlus, kEdgeZminus, kEdgePhiMinus, kEdgeZplus, 
-  kMissPhiPlus, kMissZminus, kMissPhiMinus, kMissZplus,
-  kEnded
+   kFailed = -1,         // could not find intersection
+   kHit,
+   kEdgePhiPlus, kEdgeZminus, kEdgePhiMinus, kEdgeZplus,
+   kMissPhiPlus, kMissZminus, kMissPhiMinus, kMissZplus,
+   kEnded
 } StiIntersection;
-  
-class StiNodeStat {
-public:	
-  StiNodeStat(){reset();}
-void reset(){memset(this,0,sizeof(StiNodeStat));}
-  double dx, dy, dl0, dl;
-  double x1,y1,cosCA1,sinCA1;
-  double x2,y2,cosCA2,sinCA2;
-  double sumSin, sumCos;
+
+class StiNodeStat
+{
+public:
+   StiNodeStat() {reset();}
+   void reset() {memset(this, 0, sizeof(StiNodeStat));}
+   double dx, dy, dl0, dl;
+   double x1, y1, cosCA1, sinCA1;
+   double x2, y2, cosCA2, sinCA2;
+   double sumSin, sumCos;
 };
 
-class StiNodeExt {
+class StiNodeExt
+{
 public:
-void reset(){mPP.reset();mPE.reset();mMtx.reset();}
-void unset(){;}
+   void reset() {mPP.reset(); mPE.reset(); mMtx.reset();}
+   void unset() {;}
 public:
-  StiNodePars mPP; 
-  StiNodeMtx  mMtx;
-  StiNodeErrs mPE;
+   StiNodePars mPP;
+   StiNodeMtx  mMtx;
+   StiNodeErrs mPE;
 };
 
-class StiNodeInf {
+class StiNodeInf
+{
 public:
-void reset(){mPP.reset();mPE.reset();mHrr.reset();}
-void unset(){;}
+   void reset() {mPP.reset(); mPE.reset(); mHrr.reset();}
+   void unset() {;}
 public:
-  StiNodePars mPP; 
-  StiNodeErrs mPE;
-  StiHitErrs  mHrr;
+   StiNodePars mPP;
+   StiNodeErrs mPE;
+   StiHitErrs  mHrr;
 };
 
 
@@ -66,375 +69,389 @@ public:
   Work class used to handle Kalman filter information while
   constructing track nodes.  A node may or may not own a hit
   depending whether it lies on a measurement layer where a hit
-  was found. A node can have 0, 1, or many children. 
-  Nodes are nominally sequenced outside-in i.e. with decreasing 
+  was found. A node can have 0, 1, or many children.
+  Nodes are nominally sequenced outside-in i.e. with decreasing
   radius (or independent variable). The order can however be reversed.
-  In anycase, the order should always be monotonically increasing 
+  In anycase, the order should always be monotonically increasing
   or decreasing.
   \author Claude A Pruneau
 */
-class StiKalmanTrackNode : public StiTrackNode 
+class StiKalmanTrackNode : public StiTrackNode
 {
-friend class StiTrackNodeHelper;
+   friend class StiTrackNodeHelper;
 public:
-  StiKalmanTrackNode(){_inf=0; _ext=0; reset();}
-  StiKalmanTrackNode(const StiKalmanTrackNode &node);
-  virtual ~StiKalmanTrackNode(){reduce();mId=-1;};
-  const StiKalmanTrackNode& operator=(const StiKalmanTrackNode &node);  
-  
-  static double mcs2(double relRadThickness, double beta2, double p2) {return 14.1*14.1*relRadThickness/(beta2*p2*1e6);}
-  /// Resets the node to a "null" un-used state
-  void reset();
-  void unset();
-  /// Resets errors for refit
-  void resetError(double fak=0);
-  /// Initialize this node with the given hit information
-  void initialize(StiHit*h);
-  void initialize(StiDetector *d);
-//void initialize(StiHit*h,double alpha, double eta, double curvature, double tanl);
-  
-  /// Sets the Kalman state of this node equal to that of the given node. 
-  void setState(const StiKalmanTrackNode * node);
-  /// Extract state information from this node.
-  void get(double& alpha, double& xRef, double x[kNPars], double cc[kNErrs], double& chi2);
-
-  /// Extract state information from this node in Radial representation.
-  void getGlobalRadial(double  x[6],double  e[15]);
-
-  /// Extract state information from this node in TPT representation.
-  void getGlobalTpt   (float   x[6],float   e[15]);
-
-  /// Get the charge (sign) of the track at this node
-    int getCharge() const {return (mFP.ptin() > 0) ? -1 : 1;}
-  /// Convenience Method that returns the track momentum at this node
-  StThreeVectorF getMomentumF() const;
-  /// Convenience Method that returns the track momentum at this node
-  /// in global coordinates.
-  StThreeVectorF getGlobalMomentumF() const;
-  StThreeVector<double> getMomentum() const;
-  StThreeVector<double> getGlobalMomentum() const;
-  /// Calculates and returns the momentum and error of the track at this node. The momentum is 
-  /// in the local reference frame of this node.
-  void getMomentum(double p[3], double e[6]=0) const;
-  /// Calculates and returns the tangent of the track pitch angle at this node.
-    double getCurvature() const {return mFP.curv();}
-    void setCurvature(double curvature) {mFP.curv()=curvature;}
-  double getDipAngle() const {return atan(mFP.tanl());}
-  double getTanL() const {return mFP.tanl();}
-  /// Calculates and returns the transverse momentum of the track at this node.
-    double getPt() const;
-  /// Calculates and returns the momentum of the track at this node.
-    double getP() const {return (getPt()*::sqrt(1.+mFP.tanl()*mFP.tanl()));}
-  /// Calculates and returns the Z mag field in the current point.
-  /// units: PGeV = Hz*Radcurv_in_CM
-  double getHz() const;
-  double getField() const {return getHz();}
-  double x_g() const;
-  double y_g() const;
-  double z_g() const;
-  void   getXYZ_g(double *xyz) const;
-  double getX() const 			{ return mFP.x();}
-  double getY() const 			{ return mFP.y();}  
-  double getZ() const 			{ return mFP.z();}
-  double x() const 			{ return mFP.x();}
-  double y() const 			{ return mFP.y();}  
-  double z() const 			{ return mFP.z();}
-  double getRxy() const 		{ return sqrt(mFP.x()*mFP.x()+mFP.y()*mFP.y());}
-  
-  double getEta  () const 		{return mFP.eta();  }
-  double getSin  () const 		{return mFP._sinCA;}
-  double getCos  () const 		{return mFP._cosCA;}
-  double getAlpha() const 		{return _alpha;  }
-  const double *hitErrs() const         {return mHrr.A;  }
-  double getEyy()   const 		{return mHrr.hYY;}
-  double getEzz()   const 		{return mHrr.hZZ;}
-  double getCyy()   const 		{return mFE._cYY;}
-  double getCzz()   const 		{return mFE._cZZ;}
-  double const *getPars()const          {return mFP.P;}
-  double getDiag(int idx)const          {return mFE.A[(idx*(idx+3))/2];}
-  int    getHitCount () const		{return hitCount;}
-  int    getNullCount() const       	{return nullCount;}
-  int    getContigHitCount () const 	{return contiguousHitCount ;}
-  int    getContigNullCount() const 	{return contiguousNullCount;}
-  //const char  &getHitCount () const 		{return hitCount;}
-  //const char  &getNullCount()  const		{return nullCount;}
-  //const char  &getContigHitCount () const 		{return contiguousHitCount ;}
-  //const char  &getContigNullCount() const 		{return contiguousNullCount;}
-  int incHitCount () 		{return ++hitCount;}
-  int incNullCount() 		{return ++nullCount;}
-  int incContigHitCount () {return ++contiguousHitCount ;}
-  int incContigNullCount() {return ++contiguousNullCount;}
-  void setHitCount (char c=0)       { hitCount=c;}
-  void setNullCount(char c=0)       { nullCount=c;}
-  void setContigHitCount (char c=0) { contiguousHitCount=c ;}
-  void setContigNullCount(char c=0) { contiguousNullCount=c;}
-  double getTime() const;
-
-  void   setHitCand(int nhits)		{mHitCand = nhits;}
-  void   setIHitCand(int ihit)		{mIHitCand = ihit;}
-  int    getHitCand()const		{return mHitCand;}
-  int    getIHitCand()const		{return mIHitCand;}
-  static void Break(int kase);
-  static void PrintStep();
-  StThreeVector<double>getPoint() const;
-  StThreeVector<double>getGlobalPoint() const;
-  /// Calculates and returns the momentum and error of the track at this node in global coordinates.
-  void getGlobalMomentum(double p[3], double e[6]=0) const;
-  int  isEnded() const;	
-  int  isDca()   const;	
-  
-  /// Propagates a track encapsulated by the given node "p" to the given detector "tDet".
-  int  propagate(StiKalmanTrackNode *p, const StiDetector * tDet, int dir);	//throw (Exception);
-  
-  /// Propagates a track encapsulated by the given node "p" to the given vertex
-  bool propagate(const StiKalmanTrackNode *p, StiHit * vertex, int dir);
-
-  bool propagateToBeam(const StiKalmanTrackNode *p, int dir);
-  int  propagateToRadius(StiKalmanTrackNode *pNode, double radius,int dir);
-
-  /// Evaluates, stores and returns the dedx associated with this node.
-  /// Possible returned values are:
-  /// > 0 : value of dedx
-  /// -1  : pathlength was invalid or less than "0"
-  /// -2  : no hit is associated with the node.
-  /// -3  : invalid eloss data for this node.
-  double  evaluateDedx();
-  
-  int  locate();
-  int  propagate(double x,int option,int dir);
-  void propagateMtx();
-  void propagateError();
-  void saveInfo(int kase=1);
-const StiNodeInf *getInfo() const 	{return _inf;}
-  int  testError(double *emx,int begend);
-  void numeDeriv(double val,int kind,int shape=0,int dir=0);
-  int  testDeriv(double *der);
-  void propagateMCS(StiKalmanTrackNode * previousNode, const StiDetector * tDet);
-  
-  /// Extrapolate the track parameters to radial position "x"  and return a point global coordinates along
-  /// the track at that point.
-  StThreeVector<double> getPointAt(double xk) const;
-  
-  int nudge(StiHit *hit=0);
-  double evaluateChi2(const StiHit *hit); 
-  int updateNode(); 
-  int rotate(double alpha); 
-  int    getHelicity()const {return (mFP.curv() < 0) ? -1 : 1;}
-  double getPhase()   const;
-  double getPsi()     const;
-  double getWindowY();
-  double getWindowZ();
-  double pitchAngle() const {return atan(mFP.tanl());}
-  double crossAngle() const {return asin(mFP._sinCA);}
-  double sinCrossAngle() const {return mFP._sinCA;}
-  double pathlength() const;
-  double pathLToNode(const StiKalmanTrackNode * const oNode);
-  StThreeVectorD* getLengths(StiKalmanTrackNode *nextNode);
-
-  double length(const StThreeVector<double>& delta, double curv);
-  double getDedx() const;
-  static double nice(double angle);
-  /// Return center of helix circle in global coordinates
-  StThreeVector<double> getHelixCenter() const;
-  void setHitErrors(const StiHit *hit=0);
-  StiHitErrs getGlobalHitErrs(const StiHit *hit) const;
-  friend ostream& operator<<(ostream& os, const StiKalmanTrackNode& n);
-
-  double getX0() const;
-  double getGasX0() const;
-  double getDensity() const;
-  double getGasDensity() const;
-
-  void   extend();
-  void   reduce();
-  static Int_t  debug()           {return _debug;}
-  static void   setDebug(Int_t m) {_debug = m;}
-  static void   SetLaser(Int_t m) {_laser = m;}
-  static Int_t  IsLaser()         {return _laser;}
-  void   PrintpT(const Char_t *opt="") const ;
-  int    getFlipFlop() const 			{return mFlipFlop;}
-  static void   ResetComment(const Char_t *m = "") 	{comment = m; commentdEdx = "";}
-  static const Char_t *Comment() 		{return comment.Data();}
-  /// rotation angle of local coordinates wrt global coordinates
-  int   print(const char *opt) const;
-  
- private:   
-  void   extinf();				//add inf block
-  void static saveStatics(double *sav);
-  void static backStatics(double *sav);
-  static StiNodeExt *nodeExtInstance();
-  static StiNodeInf *nodeInfInstance();
-  void propagateCurv(const StiKalmanTrackNode *parent);
-
-//  Extended members 
- public:
- 
-  const StiNodePars &fitPars() const                  {return mFP; } 
-        StiNodePars &fitPars()                        {return mFP; } 
-  const StiNodeErrs &fitErrs() const                  {return mFE; } 
-        StiNodeErrs &fitErrs()                        {return mFE; } 
-  const StiNodePars &mPP() const                      {return _ext->mPP; } 
-        StiNodePars &mPP()       {if (!_ext) extend(); return _ext->mPP; } 
-  const StiNodeErrs &mPE() const                      {return _ext->mPE; } 
-        StiNodeErrs &mPE()       {if (!_ext) extend(); return _ext->mPE; } 
-  const StiNodeMtx  &mMtx()const                      {return _ext->mMtx;} 
-        StiNodeMtx  &mMtx()      {if (!_ext) extend();return _ext->mMtx;} 
-  const StiNode2Pars &unTouched() const               {return  mUnTouch;} 
-        void         setUntouched();
- protected:   
-
-  char _beg[1];  
-  double _alpha;
-///  Z mag field in units PGev = Hz*Rcm
-  mutable double mHz;
-  StiNodePars mFP; 
-  /// covariance matrix of the track parameters
-  StiNodeErrs  mFE;
-  StiNode2Pars mUnTouch;
-  StiHitErrs   mHrr;
-  char hitCount;
-  char nullCount;
-  char contiguousHitCount;
-  char contiguousNullCount;
-  char mFlipFlop;
-  char mHitCand;
-  char mIHitCand;
-  char   _end[1];
-  StiNodeExt *_ext;
-  StiNodeInf *_inf;
-  static StiNodeStat  mgP;
-  static bool   useCalculatedHitError;
-//  debug variables
-  static int    fDerivTestOn;   
-  static double fDerivTest[kNPars][kNPars];   
-  static int   _debug;
-  static TString comment;
-  static TString commentdEdx;
-  static int   _laser;
+   StiKalmanTrackNode() {_inf = 0; _ext = 0; reset();}
+   StiKalmanTrackNode(const StiKalmanTrackNode &node);
+   virtual ~StiKalmanTrackNode() {reduce(); mId = -1;};
+   const StiKalmanTrackNode &operator=(const StiKalmanTrackNode &node);
+
+   static double mcs2(double relRadThickness, double beta2, double p2) {return 14.1 * 14.1 * relRadThickness / (beta2 * p2 * 1e6);}
+   /// Resets the node to a "null" un-used state
+   void reset();
+   void unset();
+   /// Resets errors for refit
+   void resetError(double fak = 0);
+   /// Initialize this node with the given hit information
+   void initialize(StiHit *h);
+   void initialize(StiDetector *d);
+   //void initialize(StiHit*h,double alpha, double eta, double curvature, double tanl);
+
+   /// Sets the Kalman state of this node equal to that of the given node.
+   void setState(const StiKalmanTrackNode *node);
+   /// Extract state information from this node.
+   void get(double &alpha, double &xRef, double x[kNPars], double cc[kNErrs], double &chi2);
+
+   /// Extract state information from this node in Radial representation.
+   void getGlobalRadial(double  x[6], double  e[15]);
+
+   /// Extract state information from this node in TPT representation.
+   void getGlobalTpt   (float   x[6], float   e[15]);
+
+   /// Get the charge (sign) of the track at this node
+   int getCharge() const {return (mFP.ptin() > 0) ? -1 : 1;}
+   /// Convenience Method that returns the track momentum at this node
+   StThreeVectorF getMomentumF() const;
+   /// Convenience Method that returns the track momentum at this node
+   /// in global coordinates.
+   StThreeVectorF getGlobalMomentumF() const;
+   StThreeVector<double> getMomentum() const;
+   StThreeVector<double> getGlobalMomentum() const;
+   /// Calculates and returns the momentum and error of the track at this node. The momentum is
+   /// in the local reference frame of this node.
+   void getMomentum(double p[3], double e[6] = 0) const;
+   /// Calculates and returns the tangent of the track pitch angle at this node.
+   double getCurvature() const {return mFP.curv();}
+   void setCurvature(double curvature) {mFP.curv() = curvature;}
+   double getDipAngle() const {return atan(mFP.tanl());}
+   double getTanL() const {return mFP.tanl();}
+   /// Calculates and returns the transverse momentum of the track at this node.
+   double getPt() const;
+   /// Calculates and returns the momentum of the track at this node.
+   double getP() const {return (getPt()*::sqrt(1. + mFP.tanl() * mFP.tanl()));}
+   /// Calculates and returns the Z mag field in the current point.
+   /// units: PGeV = Hz*Radcurv_in_CM
+   double getHz() const;
+   double getField() const {return getHz();}
+   double x_g() const;
+   double y_g() const;
+   double z_g() const;
+   void   getXYZ_g(double *xyz) const;
+   double getX() const 			{ return mFP.x();}
+   double getY() const 			{ return mFP.y();}
+   double getZ() const 			{ return mFP.z();}
+   double x() const 			{ return mFP.x();}
+   double y() const 			{ return mFP.y();}
+   double z() const 			{ return mFP.z();}
+   double getRxy() const 		{ return sqrt(mFP.x() * mFP.x() + mFP.y() * mFP.y());}
+
+   double getEta  () const 		{return mFP.eta();  }
+   double getSin  () const 		{return mFP._sinCA;}
+   double getCos  () const 		{return mFP._cosCA;}
+   double getAlpha() const 		{return _alpha;  }
+   const double *hitErrs() const         {return mHrr.A;  }
+   double getEyy()   const 		{return mHrr.hYY;}
+   double getEzz()   const 		{return mHrr.hZZ;}
+   double getCyy()   const 		{return mFE._cYY;}
+   double getCzz()   const 		{return mFE._cZZ;}
+   double const *getPars()const          {return mFP.P;}
+   double getDiag(int idx)const          {return mFE.A[(idx * (idx + 3)) / 2];}
+   int    getHitCount () const		{return hitCount;}
+   int    getNullCount() const       	{return nullCount;}
+   int    getContigHitCount () const 	{return contiguousHitCount ;}
+   int    getContigNullCount() const 	{return contiguousNullCount;}
+   //const char  &getHitCount () const 		{return hitCount;}
+   //const char  &getNullCount()  const		{return nullCount;}
+   //const char  &getContigHitCount () const 		{return contiguousHitCount ;}
+   //const char  &getContigNullCount() const 		{return contiguousNullCount;}
+   int incHitCount () 		{return ++hitCount;}
+   int incNullCount() 		{return ++nullCount;}
+   int incContigHitCount () {return ++contiguousHitCount ;}
+   int incContigNullCount() {return ++contiguousNullCount;}
+   void setHitCount (char c = 0)       { hitCount = c;}
+   void setNullCount(char c = 0)       { nullCount = c;}
+   void setContigHitCount (char c = 0) { contiguousHitCount = c ;}
+   void setContigNullCount(char c = 0) { contiguousNullCount = c;}
+   double getTime() const;
+
+   void   setHitCand(int nhits)		{mHitCand = nhits;}
+   void   setIHitCand(int ihit)		{mIHitCand = ihit;}
+   int    getHitCand()const		{return mHitCand;}
+   int    getIHitCand()const		{return mIHitCand;}
+   static void Break(int kase);
+   static void PrintStep();
+   StThreeVector<double>getPoint() const;
+   StThreeVector<double>getGlobalPoint() const;
+   /// Calculates and returns the momentum and error of the track at this node in global coordinates.
+   void getGlobalMomentum(double p[3], double e[6] = 0) const;
+   int  isEnded() const;
+   int  isDca()   const;
+
+   /// Propagates a track encapsulated by the given node "p" to the given detector "tDet".
+   int  propagate(StiKalmanTrackNode *p, const StiDetector *tDet, int dir);	//throw (Exception);
+
+   /// Propagates a track encapsulated by the given node "p" to the given vertex
+   bool propagate(const StiKalmanTrackNode *p, StiHit *vertex, int dir);
+
+   bool propagateToBeam(const StiKalmanTrackNode *p, int dir);
+   int  propagateToRadius(StiKalmanTrackNode *pNode, double radius, int dir);
+
+   /// Evaluates, stores and returns the dedx associated with this node.
+   /// Possible returned values are:
+   /// > 0 : value of dedx
+   /// -1  : pathlength was invalid or less than "0"
+   /// -2  : no hit is associated with the node.
+   /// -3  : invalid eloss data for this node.
+   double  evaluateDedx();
+
+   int  locate();
+   int  propagate(double x, int option, int dir);
+   void propagateMtx();
+   void propagateError();
+   void saveInfo(int kase = 1);
+   const StiNodeInf *getInfo() const 	{return _inf;}
+   int  testError(double *emx, int begend);
+   void numeDeriv(double val, int kind, int shape = 0, int dir = 0);
+   int  testDeriv(double *der);
+   void propagateMCS(StiKalmanTrackNode *previousNode, const StiDetector *tDet);
+
+   /// Extrapolate the track parameters to radial position "x"  and return a point global coordinates along
+   /// the track at that point.
+   StThreeVector<double> getPointAt(double xk) const;
+
+   int nudge(StiHit *hit = 0);
+   double evaluateChi2(const StiHit *hit);
+   int updateNode();
+   int rotate(double alpha);
+   int    getHelicity()const {return (mFP.curv() < 0) ? -1 : 1;}
+   double getPhase()   const;
+   double getPsi()     const;
+   double getWindowY();
+   double getWindowZ();
+   double pitchAngle() const {return atan(mFP.tanl());}
+   double crossAngle() const {return asin(mFP._sinCA);}
+   double sinCrossAngle() const {return mFP._sinCA;}
+   double pathlength() const;
+   double pathLToNode(const StiKalmanTrackNode *const oNode);
+   StThreeVectorD *getLengths(StiKalmanTrackNode *nextNode);
+
+   double length(const StThreeVector<double> &delta, double curv);
+   double getDedx() const;
+   static double nice(double angle);
+   /// Return center of helix circle in global coordinates
+   StThreeVector<double> getHelixCenter() const;
+   void setHitErrors(const StiHit *hit = 0);
+   StiHitErrs getGlobalHitErrs(const StiHit *hit) const;
+   friend ostream &operator<<(ostream &os, const StiKalmanTrackNode &n);
+
+   double getX0() const;
+   double getGasX0() const;
+   double getDensity() const;
+   double getGasDensity() const;
+
+   void   extend();
+   void   reduce();
+   static Int_t  debug()           {return _debug;}
+   static void   setDebug(Int_t m) {_debug = m;}
+   static void   SetLaser(Int_t m) {_laser = m;}
+   static Int_t  IsLaser()         {return _laser;}
+   void   PrintpT(const Char_t *opt = "") const ;
+   int    getFlipFlop() const 			{return mFlipFlop;}
+   static void   ResetComment(const Char_t *m = "") 	{comment = m; commentdEdx = "";}
+   static const Char_t *Comment() 		{return comment.Data();}
+   /// rotation angle of local coordinates wrt global coordinates
+   int   print(const char *opt) const;
+
+private:
+   void   extinf();				//add inf block
+   void static saveStatics(double *sav);
+   void static backStatics(double *sav);
+   static StiNodeExt *nodeExtInstance();
+   static StiNodeInf *nodeInfInstance();
+   void propagateCurv(const StiKalmanTrackNode *parent);
+
+   //  Extended members
+public:
+
+   const StiNodePars &fitPars() const                  {return mFP; }
+   StiNodePars &fitPars()                        {return mFP; }
+   const StiNodeErrs &fitErrs() const                  {return mFE; }
+   StiNodeErrs &fitErrs()                        {return mFE; }
+   const StiNodePars &mPP() const                      {return _ext->mPP; }
+   StiNodePars &mPP()       {if (!_ext) extend(); return _ext->mPP; }
+   const StiNodeErrs &mPE() const                      {return _ext->mPE; }
+   StiNodeErrs &mPE()       {if (!_ext) extend(); return _ext->mPE; }
+   const StiNodeMtx  &mMtx()const                      {return _ext->mMtx;}
+   StiNodeMtx  &mMtx()      {if (!_ext) extend(); return _ext->mMtx;}
+   const StiNode2Pars &unTouched() const               {return  mUnTouch;}
+   void         setUntouched();
+protected:
+
+   char _beg[1];
+   double _alpha;
+   ///  Z mag field in units PGev = Hz*Rcm
+   mutable double mHz;
+   StiNodePars mFP;
+   /// covariance matrix of the track parameters
+   StiNodeErrs  mFE;
+   StiNode2Pars mUnTouch;
+   StiHitErrs   mHrr;
+   char hitCount;
+   char nullCount;
+   char contiguousHitCount;
+   char contiguousNullCount;
+   char mFlipFlop;
+   char mHitCand;
+   char mIHitCand;
+   char   _end[1];
+   StiNodeExt *_ext;
+   StiNodeInf *_inf;
+   static StiNodeStat  mgP;
+   static bool   useCalculatedHitError;
+   //  debug variables
+   static int    fDerivTestOn;
+   static double fDerivTest[kNPars][kNPars];
+   static int   _debug;
+   static TString comment;
+   static TString commentdEdx;
+   static int   _laser;
 public:
-  int mId;  //for debug only 
+   int mId;  //for debug only
 };
 
 
 inline double StiKalmanTrackNode::nice(double angle)
-{ 
-  if (angle <= -M_PI) angle += 2*M_PI;
-  if (angle >   M_PI) angle -= 2*M_PI;
-  return angle;
+{
+   if (angle <= -M_PI) angle += 2 * M_PI;
+
+   if (angle >   M_PI) angle -= 2 * M_PI;
+
+   return angle;
 }
 
 inline StThreeVector<double> StiKalmanTrackNode::getMomentum() const
 {
-  double pt = getPt();
-  return StThreeVector<double>(pt*mFP._cosCA,pt*mFP._sinCA,pt*mFP.tanl());
+   double pt = getPt();
+   return StThreeVector<double>(pt * mFP._cosCA, pt * mFP._sinCA, pt * mFP.tanl());
 }
 
 inline StThreeVectorF StiKalmanTrackNode::getMomentumF() const
 {
-  double pt = getPt();
-  return StThreeVectorF(pt*mFP._cosCA,pt*mFP._sinCA,pt*mFP.tanl());
+   double pt = getPt();
+   return StThreeVectorF(pt * mFP._cosCA, pt * mFP._sinCA, pt * mFP.tanl());
 }
 
 inline StThreeVector<double> StiKalmanTrackNode::getGlobalMomentum() const
 {
-  StThreeVector<double> p = getMomentum();
-  p.rotateZ(_alpha);
-  return p;
+   StThreeVector<double> p = getMomentum();
+   p.rotateZ(_alpha);
+   return p;
 }
 
 inline StThreeVectorF StiKalmanTrackNode::getGlobalMomentumF() const
 {
-  StThreeVectorF p = getMomentumF();
-  p.rotateZ(_alpha);
-  return p;
+   StThreeVectorF p = getMomentumF();
+   p.rotateZ(_alpha);
+   return p;
 }
 
 
 //stl helper functor
 
-struct StiKTNXLessThan
-{
-    bool operator()(const StiKalmanTrackNode& lhs, const StiKalmanTrackNode& rhs) const;
+struct StiKTNXLessThan {
+   bool operator()(const StiKalmanTrackNode &lhs, const StiKalmanTrackNode &rhs) const;
 };
 
-struct StreamX 
-{
-  void operator()(const StiKalmanTrackNode& node) 
-  {
-    cout <<node.getX()<<endl;
-  }
+struct StreamX {
+   void operator()(const StiKalmanTrackNode &node) {
+      cout << node.getX() << endl;
+   }
 };
 
 ///Calculate and returns pathlength within detector volume
-///associated with this node. Returns 0 if no detector is 
+///associated with this node. Returns 0 if no detector is
 ///associated.
 inline double StiKalmanTrackNode::pathlength() const
 {
-  const StiDetector * det = getDetector();
-  if (!det) return 0.; 
-  double thickness = det->getShape()->getThickness();
-  return (thickness*::sqrt(1.+mFP.tanl()*mFP.tanl())) / mFP._cosCA;
+   const StiDetector *det = getDetector();
+
+   if (!det) return 0.;
+
+   double thickness = det->getShape()->getThickness();
+   return (thickness*::sqrt(1. + mFP.tanl() * mFP.tanl())) / mFP._cosCA;
 }
 
-///Return the radiation length (in cm) of the 
+///Return the radiation length (in cm) of the
 ///the detector volume at this node.
 inline double StiKalmanTrackNode::getX0() const
 {
-  const StiDetector * det = getDetector();
-  if (!det)
-    return 0.;
-  return det->getMaterial()->getX0();
+   const StiDetector *det = getDetector();
+
+   if (!det)
+      return 0.;
+
+   return det->getMaterial()->getX0();
 }
 
 ///Return the radiation length (in cm) of the gas
 ///surrounding the detector volume at this node.
 inline double StiKalmanTrackNode::getGasX0() const
 {
-  const StiDetector * det = getDetector();
-  if (!det)
-    return 0.;
-  return det->getGas()->getX0();
+   const StiDetector *det = getDetector();
+
+   if (!det)
+      return 0.;
+
+   return det->getGas()->getX0();
 }
 
 inline double StiKalmanTrackNode::getDensity() const
 {
-  const StiDetector * det = getDetector();
-  if (!det)
-    return 0.;
-  return det->getMaterial()->getDensity();
+   const StiDetector *det = getDetector();
+
+   if (!det)
+      return 0.;
+
+   return det->getMaterial()->getDensity();
 }
 
 inline double StiKalmanTrackNode::getGasDensity() const
 {
-  const StiDetector * det = getDetector();
-  if (!det)
-    return 0.;
-  return det->getGas()->getDensity();
+   const StiDetector *det = getDetector();
+
+   if (!det)
+      return 0.;
+
+   return det->getGas()->getDensity();
 }
 
 
-inline StThreeVectorD* StiKalmanTrackNode::getLengths(StiKalmanTrackNode* nextNode)
+inline StThreeVectorD *StiKalmanTrackNode::getLengths(StiKalmanTrackNode *nextNode)
 {
-  double x1=pathlength()/2.;
-  double x3=nextNode->pathlength()/2.;
-  double x2=pathLToNode(nextNode);
-  if (x2> (x1+x3)) x2=x2-x1-x3;
-  else x2=0;
-
-  return new StThreeVectorD(x1/getX0(),
-			    x2/getDetector()->getMaterial()->getX0(), 
-			    x3/nextNode->getX0());
+   double x1 = pathlength() / 2.;
+   double x3 = nextNode->pathlength() / 2.;
+   double x2 = pathLToNode(nextNode);
+
+   if (x2 > (x1 + x3)) x2 = x2 - x1 - x3;
+   else x2 = 0;
+
+   return new StThreeVectorD(x1 / getX0(),
+                             x2 / getDetector()->getMaterial()->getX0(),
+                             x3 / nextNode->getX0());
 }
 
 inline double StiKalmanTrackNode::getDedx() const
 {
 
-  StiHit *hit = getHit();
-  if (!hit) return -1;
-  double de=hit->getEloss();
-  double dx=pathlength();
-  if(dx>0 && de>0) return de/dx;
-  return -1;
+   StiHit *hit = getHit();
+
+   if (!hit) return -1;
+
+   double de = hit->getEloss();
+   double dx = pathlength();
+
+   if (dx > 0 && de > 0) return de / dx;
+
+   return -1;
 }
 
 #endif
-- 
1.8.2.GIT


From 8c35cdabe8e9a3ae9df5e71c101ca8e78c1bb9ce Mon Sep 17 00:00:00 2001
From: Dmitri Smirnov <d.s@plexoos.com>
Date: Thu, 24 Apr 2014 17:30:45 -0400
Subject: [PATCH 04/11] Style and cleanup changes

---
 Sti/StiDetector.cxx              |  1 +
 Sti/StiDetectorBuilder.cxx       |  9 +++++++-
 Sti/StiDetectorContainer.cxx     |  2 +-
 Sti/StiDetectorGroup.h           |  3 +++
 Sti/StiDetectorTreeBuilder.h     | 46 +++++++++++++++++-----------------------
 Sti/StiElossCalculator.h         |  2 +-
 Sti/StiGenericDetectorGroup.cxx  |  1 +
 Sti/StiGenericDetectorGroup.h    |  6 +++++-
 Sti/StiKalmanTrackFinder.cxx     | 36 ++++++++++++++++---------------
 Sti/StiKalmanTrackNode.cxx       |  4 +---
 Sti/StiMasterDetectorBuilder.cxx |  8 ++-----
 Sti/StiMaterial.cxx              | 20 ++++++++---------
 12 files changed, 71 insertions(+), 67 deletions(-)

diff --git a/Sti/StiDetector.cxx b/Sti/StiDetector.cxx
index 57ae3dc..6805864 100644
--- a/Sti/StiDetector.cxx
+++ b/Sti/StiDetector.cxx
@@ -14,6 +14,7 @@ StiDetector::StiDetector()
 {
   reset();
 }
+
 void StiDetector::reset()
 {
   setName("");
diff --git a/Sti/StiDetectorBuilder.cxx b/Sti/StiDetectorBuilder.cxx
index af73e6e..8b8fdde 100644
--- a/Sti/StiDetectorBuilder.cxx
+++ b/Sti/StiDetectorBuilder.cxx
@@ -17,7 +17,10 @@
 #include "TVector3.h"
 
 StiDetectorBuilder* StiDetectorBuilder::fCurrentDetectorBuilder = 0;
+
 int StiDetectorBuilder::_debug = 0;
+
+
 StiDetectorBuilder::StiDetectorBuilder(const string & name,bool active, const string & inputFile)
   : Named(name+"Builder"),
     _groupId(-1),
@@ -120,13 +123,17 @@ void StiDetectorBuilder::build(StMaker& source)
 void StiDetectorBuilder::buildDetectors(StMaker& source)
 {}
 //________________________________________________________________________________
-void StiDetectorBuilder::AverageVolume(TGeoPhysicalNode *nodeP) {
+void StiDetectorBuilder::AverageVolume(TGeoPhysicalNode *nodeP)
+{
   if (debug()) {cout << "StiDetectorBuilder::AverageVolume -I TGeoPhysicalNode\t" << nodeP->GetName() << endl;}
+
   TGeoVolume   *volP   = nodeP->GetVolume();
   TGeoMaterial *matP   = volP->GetMaterial(); if (debug()) matP->Print("");
   TGeoShape    *shapeP = nodeP->GetShape();   if (debug()) {cout << "New Shape\t"; StiVMCToolKit::PrintShape(shapeP);}
   TGeoHMatrix  *hmat   = nodeP->GetMatrix();  if (debug()) hmat->Print("");
+
   Double_t PotI = StiVMCToolKit::GetPotI(matP);
+
   StiMaterial *matS = add(new StiMaterial(matP->GetName(),
 						matP->GetZ(),
 						matP->GetA(),
diff --git a/Sti/StiDetectorContainer.cxx b/Sti/StiDetectorContainer.cxx
index 01d89f0..e267b7f 100644
--- a/Sti/StiDetectorContainer.cxx
+++ b/Sti/StiDetectorContainer.cxx
@@ -393,7 +393,7 @@ bool RPhiLessThan::operator()(const StiDetector* lhs, const StiDetector* rhs)
 //VP    return (lhsp->getLayerAngle()<rhsp->getLayerAngle());
   double la = lhsp->getLayerAngle();
   double ra = rhsp->getLayerAngle();
-  if ((la<0) != (ra<0))  { if (la<0) la+=2*M_PI;if (ra<0) ra+=2*M_PI;}
+  if ((la<0) != (ra<0))  { if (la<0) la+=2*M_PI; if (ra<0) ra+=2*M_PI;}
   return (la<ra);
 }
 
diff --git a/Sti/StiDetectorGroup.h b/Sti/StiDetectorGroup.h
index b494478..f301403 100644
--- a/Sti/StiDetectorGroup.h
+++ b/Sti/StiDetectorGroup.h
@@ -9,6 +9,9 @@
 template<class Event,class Detector> class StiHitLoader;
 class StiElossCalculator;
 
+/**
+ * StiDetectorGroup extends the StiGenericDetectorGroup class with an StiHitLoader
+ */
 template<class Event>
 class StiDetectorGroup : public StiGenericDetectorGroup
 {
diff --git a/Sti/StiDetectorTreeBuilder.h b/Sti/StiDetectorTreeBuilder.h
index b3bcfbe..27aedc1 100644
--- a/Sti/StiDetectorTreeBuilder.h
+++ b/Sti/StiDetectorTreeBuilder.h
@@ -3,43 +3,35 @@
 //07/01
 
 /*! \class StiDetectorTreeBuilder
+ 
   StiDetectorTreeBuilder is a utility class that uses objects it gets from two
-  factories
-  to build a full model of the STAR detector material.  StiDetectorTreeBuilder
-  is the
-  class responsible for actually organizing the StiDetector objects into a tree
-  structure.
-  As such, it uses the utility class StiDetectorBuilder to generate StiDetector
-  objects, and
-  then these objects are organized as belonging to an
-  StiCompositeTreeNode<StiDetector>
-  object.  This is all accomplished via the call to build().
+  factories to build a full model of the STAR detector material.
+  StiDetectorTreeBuilder is the class responsible for actually organizing the
+  StiDetector objects into a tree structure. As such, it uses the utility class
+  StiDetectorBuilder to generate StiDetector objects, and then these objects are
+  organized as belonging to an StiCompositeTreeNode<StiDetector> object. This
+  is all accomplished via the call to build().
+
   <p>
-  The general flow of execution is as follows.  First, in the constructor of
+  The general flow of execution is as follows. First, in the constructor of
   StiDetectorTreeBuilder, the member mDetectorBuilder is set to point to an
-  instance
-  of StiCodedDetectorBuilder created on the heap.  Once a call to build() is
-  made, the
-  tree is assembled by looping on detectors that are generated by
-  mDetectorBuilder.  Each
-  detector object returned by the mDetectorBuilder is then hung on the tree by
-  a call to
-  addToTree which calls hangWhere().  By using mDetectorBuilder polymorphically,
-  StiDetectorTreeBuilder becomes extremely flexible.  That is, it does not
-  care how the
-  StiDetector objects are created (e.g., from root macro, data base, or geant).
-  However,
-  to really take advantage of this flexibility one should remove ownership of
+  instance of StiCodedDetectorBuilder created on the heap. Once a call to
+  build() is made, the tree is assembled by looping on detectors that are
+  generated by mDetectorBuilder. Each detector object returned by the
+  mDetectorBuilder is then hung on the tree by a call to addToTree which calls
+  hangWhere(). By using mDetectorBuilder polymorphically, StiDetectorTreeBuilder
+  becomes extremely flexible. That is, it does not care how the StiDetector
+  objects are created (e.g., from root macro, data base, or geant). However, to
+  really take advantage of this flexibility one should remove ownership of
   mDetectorBuilder from StiDetectorTreeBuilder and instead set the polymorphic
-  pointer
-  by hand before a call to build().  This is work to be done.
+  pointer by hand before a call to build(). This is work to be done.
   
   \author M.L. Miller (Yale Software)
   \warning There is <b>some</b> internal protection against build being called
   more then once.  See the documenation for the build() method.
   \warning Member of type StiDetectoBuilder* defaults to
   StiCodedDetectorBuilder.
- */
+*/
 
 /** \example StiDetectorTreeBuilder_ex.cxx
  */
diff --git a/Sti/StiElossCalculator.h b/Sti/StiElossCalculator.h
index 81e98db..27d0a47 100644
--- a/Sti/StiElossCalculator.h
+++ b/Sti/StiElossCalculator.h
@@ -13,7 +13,7 @@
   really important only above 10 GeV/c.
   <p>
   Instances of this class to be created for all relevant scattering materials.
-  The creation of an instance requires one specifies the effective Z/A ratio
+  The creation of an instance requires one to specify the effective Z/A ratio
   as well as the average ionization potential of the material. The effective
   quantities can be calculated by weighing the elemental values by the fractional
   weight of the elements of the mixture. This provides an accurate description
diff --git a/Sti/StiGenericDetectorGroup.cxx b/Sti/StiGenericDetectorGroup.cxx
index 9df42a1..15a8140 100644
--- a/Sti/StiGenericDetectorGroup.cxx
+++ b/Sti/StiGenericDetectorGroup.cxx
@@ -29,6 +29,7 @@ StiGenericDetectorGroup::StiGenericDetectorGroup(const string & name,
 //_____________________________________________________________________________
 StiGenericDetectorGroup::~StiGenericDetectorGroup()
 {
+  // XXX:ds: _elossCalculator is not deleted. Why? Is that an error?
   delete _detectorBuilder;
 }
 //_____________________________________________________________________________
diff --git a/Sti/StiGenericDetectorGroup.h b/Sti/StiGenericDetectorGroup.h
index 0c11d74..3dfdd0b 100644
--- a/Sti/StiGenericDetectorGroup.h
+++ b/Sti/StiGenericDetectorGroup.h
@@ -9,6 +9,10 @@
 class StiDetectorBuilder;
 class StiElossCalculator;
 
+/**
+ * A generic detector group combines a detector builder and an energy loss calculator corresponding
+ * to the material of the volumes built by the detector builder.
+ */
 class StiGenericDetectorGroup  : public Named
 {
    protected:
@@ -23,7 +27,7 @@ class StiGenericDetectorGroup  : public Named
       /// Detector group identifier.
       int _groupId;
   public:
-     virtual void initialize(){} ; // FIXME:  this method must be abstract = 0;
+    virtual void initialize(){} ; // FIXME:  this method must be abstract = 0;
     /// Get a detector builder appropriate for this detector group
     virtual StiDetectorBuilder * getDetectorBuilder();
     virtual void setDetectorBuilder(StiDetectorBuilder* detBuilder);
diff --git a/Sti/StiKalmanTrackFinder.cxx b/Sti/StiKalmanTrackFinder.cxx
index e12a041..cad1964 100644
--- a/Sti/StiKalmanTrackFinder.cxx
+++ b/Sti/StiKalmanTrackFinder.cxx
@@ -587,8 +587,7 @@ bool StiKalmanTrackFinder::find(StiTrack *t, int direction, double rmin) // thro
    return (nnAft > nnBef || lnAft > (lnBef + 0.5));
 }
 //______________________________________________________________________________
-void StiKalmanTrackFinder::find(StiKalmanTrack *track, int direction
-                                , StiKalmanTrackNode *leadNode, QAFind &qa)
+void StiKalmanTrackFinder::find(StiKalmanTrack *track, int direction, StiKalmanTrackNode *leadNode, QAFind &qa)
 {
    static int nCall = 0; nCall++;
    StiKalmanTrackNode::Break(nCall);
@@ -605,10 +604,8 @@ void StiKalmanTrackFinder::find(StiKalmanTrack *track, int direction
 
    if (--mTrackPerm == 0) { mUseComb = 0; }
 
-   StiDetector *tDet = 0;
    int status;
    StiKalmanTrackNode testNode;
-   int position;
    StiHit *stiHit;
    double  leadAngle, leadRadius;
 
@@ -660,11 +657,15 @@ void StiKalmanTrackFinder::find(StiKalmanTrack *track, int direction
 
          //#define PEREV
 
-         //find all relevant detectors to visit.
+         //find all relevant detectors to visit. XXX:ds: Define "relevant"
          sector = (!direction) ? _detectorContainer->beginPhi(rlayer) : _detectorContainer->beginPhi(layer);
 
          for ( ; (!direction) ? sector != _detectorContainer->endPhi(rlayer) : sector != _detectorContainer->endPhi(layer); ++sector) {
             StiDetector *detector = (*sector)->getData();
+
+            //Info("StiKalmanTrackFinder::find", "XXX StiDetector:");
+            //cout << *detector << endl;
+
             double angle  = detector->getPlacement()->getNormalRefAngle();
             double radius = detector->getPlacement()->getNormalRadius();
             assert(radius > 0 && radius < 1000);
@@ -690,10 +691,12 @@ void StiKalmanTrackFinder::find(StiKalmanTrack *track, int direction
                if (radius <= 50 )  OpenAngle = ref1a;
             }
 
+            // The difference between the track vector at the surface (???
+            // XXX: really need to verify this) and the angle normal to the
+            // detector plane
             diff = projAngle - angle;
 
             if (diff >  M_PI) diff -= 2 * M_PI;
-
             if (diff < -M_PI) diff += 2 * M_PI;
 
             if (fabs(diff) > OpenAngle)	continue;
@@ -701,6 +704,7 @@ void StiKalmanTrackFinder::find(StiKalmanTrack *track, int direction
             detectors.push_back(detector);
          }
 
+         // At this point we have collected all "relevant" StiDetectors in the detectors vector
          int nDets = detectors.size();
 
          if (debug() > 2 && nDets == 0) cout << "no detector of interest on this layer" << endl;
@@ -710,7 +714,7 @@ void StiKalmanTrackFinder::find(StiKalmanTrack *track, int direction
          if (nDets > 1) sort(detectors.begin(), detectors.end(), CloserAngle(projAngle) );
 
          for (vector<StiDetector *>::const_iterator d = detectors.begin(); d != detectors.end(); ++d) {
-            tDet = *d;
+            StiDetector *tDet = *d;
 
             if (debug() > 2) {
                cout << endl << "target det:" << *tDet;
@@ -719,9 +723,10 @@ void StiKalmanTrackFinder::find(StiKalmanTrack *track, int direction
             }
 
             //begin tracking here...
-            testNode.reduce(); testNode.reset();
+            testNode.reduce();
+            testNode.reset();
             testNode.setChi2(1e55);
-            position = testNode.propagate(leadNode, tDet, direction);
+            int position = testNode.propagate(leadNode, tDet, direction);
 
             if (position == kEnded) { gLevelOfFind--; return;}
 
@@ -766,7 +771,7 @@ void StiKalmanTrackFinder::find(StiKalmanTrack *track, int direction
                   status = testNode.nudge(stiHit);
                   testNode.setReady();
 
-                  if (status)		continue;
+                  if (status) continue;
 
                   chi2 = testNode.evaluateChi2(stiHit);
 
@@ -790,10 +795,8 @@ void StiKalmanTrackFinder::find(StiKalmanTrack *track, int direction
             else {
                int flg = (testNode.getX() < kRMinTpc) ? mUseComb & 3 : mUseComb >> 2;
 
-               if ((flg & 2) || !nHits) 	nHits++;
-
+               if ((flg & 2) || !nHits) nHits++;
                if ((flg & 1) == 0) 	nHits = 1;
-
             }
 
             QAFind qaBest, qaTry;
@@ -835,8 +838,8 @@ void StiKalmanTrackFinder::find(StiKalmanTrack *track, int direction
 
                int igor = compQA(qaBest, qaTry, maxChi2);
 
-               if (igor < 0)  { leadNode->remove(0);}
-               else         { leadNode->remove(1); qaBest = qaTry;}
+               if (igor < 0) { leadNode->remove(0);}
+               else          { leadNode->remove(1); qaBest = qaTry;}
             }
 
             qa = qaBest; gLevelOfFind--; return;
@@ -853,8 +856,7 @@ void StiKalmanTrackFinder::find(StiKalmanTrack *track, int direction
    return;
 }
 //______________________________________________________________________________
-void StiKalmanTrackFinder::nodeQA(StiKalmanTrackNode *node, int position
-                                  , int active, QAFind &qa)
+void StiKalmanTrackFinder::nodeQA(StiKalmanTrackNode *node, int position, int active, QAFind &qa)
 {
    int maxNullCount           = StiKalmanTrackFinderParameters::instance()->maxNullCount() + 3;
    int maxContiguousNullCount = StiKalmanTrackFinderParameters::instance()->maxContiguousNullCount() + 3;
diff --git a/Sti/StiKalmanTrackNode.cxx b/Sti/StiKalmanTrackNode.cxx
index 766b193..6fc6179 100644
--- a/Sti/StiKalmanTrackNode.cxx
+++ b/Sti/StiKalmanTrackNode.cxx
@@ -1490,9 +1490,7 @@ void StiKalmanTrackNode::propagateMCS(StiKalmanTrackNode *previousNode, const St
    pL2 = pathLToNode(previousNode);
 
    if (pL1 < 0) pL1 = 0;
-
    if (pL2 < 0) pL2 = 0;
-
    if (pL3 < 0) pL3 = 0;
 
    double x0p = -1;
@@ -1581,7 +1579,7 @@ void StiKalmanTrackNode::propagateMCS(StiKalmanTrackNode *previousNode, const St
 
    if (TMath::Abs(dE) > 0) {
       if (debug()) {
-         commentdEdx  = Form("%6.3g cm(%5.2f) %6.3g keV %6.3f GeV", mgP.dx, 100 * relRadThickness, 1e6 * dE, TMath::Sqrt(e2) - m);
+         commentdEdx  = Form("%6.3g cm(%5.2f) %6.3g keV %6.3f GeV", mgP.dx, 100*relRadThickness, 1e6*dE, TMath::Sqrt(e2) - m);
       }
 
       double correction = 1. + ::sqrt(e2) * dE / p2;
diff --git a/Sti/StiMasterDetectorBuilder.cxx b/Sti/StiMasterDetectorBuilder.cxx
index 4da3660..a1d37a0 100644
--- a/Sti/StiMasterDetectorBuilder.cxx
+++ b/Sti/StiMasterDetectorBuilder.cxx
@@ -50,9 +50,7 @@ void StiMasterDetectorBuilder::build(StMaker&source)
   cout << "StiMasterDetectorBuilder::build() -I- Started"<<endl;
   vector<StiDetectorBuilder*>::iterator iter;
   unsigned int nRows=0;
-  for (iter=begin();
-       iter!=end();
-       iter++)
+  for (iter=begin(); iter!=end(); iter++)
     {
       cout << "StiMasterDetectorBuilder::build() -I- Calling Group Builder named:" << (*iter)->getName()<<endl;
       if (!*iter) cout <<"   pointer is corrupted!!!!!!!!!!!!!!!!!!!"<<endl;
@@ -62,9 +60,7 @@ void StiMasterDetectorBuilder::build(StMaker&source)
   cout << "StiMasterDetectorBuilder::build() -I- Will build local array"<<endl;
   setNRows(nRows);
   unsigned int row=0;
-  for (iter=begin();
-       iter!=end();
-       iter++)
+  for (iter=begin(); iter!=end(); iter++)
     {
       cout << "StiMasterDetectorBuilder::build() -I- Builder:"<<(*iter)->getName()<<endl;
       for (unsigned int i=0;i<(*iter)->getNRows();i++)
diff --git a/Sti/StiMaterial.cxx b/Sti/StiMaterial.cxx
index 7917cf3..d5eda86 100644
--- a/Sti/StiMaterial.cxx
+++ b/Sti/StiMaterial.cxx
@@ -11,11 +11,11 @@ StiMaterial::StiMaterial(){
 } // StiMaterial()
 
 StiMaterial::StiMaterial(const string &name,
-			 double z,
-			 double a,
-			 double density,
-			 double radLength,
-			 double ionization)
+                         double z,
+                         double a,
+                         double density,
+                         double radLength,
+                         double ionization)
 {
   set(name,z,a,density,radLength,ionization);
 }
@@ -32,11 +32,11 @@ StiMaterial::~StiMaterial(){
  \param ionization potential in eV.
 */
 void StiMaterial::set(const string& name,
-		      double z,
-		      double a,
-		      double density,
-		      double radLength,
-		      double ionization)
+                      double z,
+                      double a,
+                      double density,
+                      double radLength,
+                      double ionization)
 {
   setName(name);
   _density = density;
-- 
1.8.2.GIT


From b54ea42debcef90f42523b24030a1a46c6f23725 Mon Sep 17 00:00:00 2001
From: Dmitri Smirnov <d.s@plexoos.com>
Date: Tue, 6 May 2014 17:37:59 -0400
Subject: [PATCH 05/11] Uniform improvements in Sti objects output streamers

---
 Sti/StiDetector.cxx  | 13 ++++++++++---
 Sti/StiMaterial.cxx  | 16 ++++++++--------
 Sti/StiPlacement.cxx | 19 ++++++++++---------
 Sti/StiShape.cxx     | 22 +++++++++++++---------
 4 files changed, 41 insertions(+), 29 deletions(-)

diff --git a/Sti/StiDetector.cxx b/Sti/StiDetector.cxx
index 6805864..0414738 100644
--- a/Sti/StiDetector.cxx
+++ b/Sti/StiDetector.cxx
@@ -44,9 +44,16 @@ void StiDetector::copy(StiDetector &detector){
 ostream& operator<<(ostream& os, const StiDetector& d)
 {
     os << "StiDetector:" << endl
-       << d.getName()
-       <<"\tR:"<<d.getPlacement()->getNormalRadius()<<"cm\tA:"
-       <<d.getPlacement()->getNormalRefAngle()<< " radians" << endl;
+       << "\t" << "name: "              << d.getName()         << endl
+       << "\t" << "isOn: "              << d.on                << endl
+       << "\t" << "_groupId: "          << d._groupId          << endl
+       << "\t" << "_key1, _key2: "      << d._key1 << ", " << d._key2 << endl
+       << "\t" << "continuousMedium: "  << d.continuousMedium  << endl
+       << "\t" << "discreteScatterer: " << d.discreteScatterer << endl;
+
+    if (d.gas)
+       os << "gas:" << endl
+          << *d.gas;
 
     if (d.material)
        os << *d.material;
diff --git a/Sti/StiMaterial.cxx b/Sti/StiMaterial.cxx
index d5eda86..6987dbc 100644
--- a/Sti/StiMaterial.cxx
+++ b/Sti/StiMaterial.cxx
@@ -57,13 +57,13 @@ void StiMaterial::set(const string& name,
 ostream& operator<<(ostream& os, const StiMaterial& m)
 {
   os << "StiMaterial:" << endl
-     << "Name:"<< m.getName()
-     << " Density:"<< m.getDensity()<< " g/cm^3"
-     << " RadLength:"<<m.getRadLength()
-     << " EffZ: "<<m.getZ()
-     << " EffA: "<<m.getA()
-     << " EffIoniz: "<<m.getIonization()
-     << endl;
-    
+     << "\t" << "name: "        << m.getName()       << endl
+     << "\t" << "_z: "          << m.getZ()          << endl
+     << "\t" << "_a: "          << m.getA()          << endl
+     << "\t" << "_density: "    << m.getDensity()    << " g/cm^3" << endl
+     << "\t" << "_radLength: "  << m.getRadLength()  << endl
+     << "\t" << "_ionization: " << m.getIonization() << endl
+     << "\t" << "_x0: "         << m.getX0()         << endl;
+
     return os;
 }
diff --git a/Sti/StiPlacement.cxx b/Sti/StiPlacement.cxx
index dddebf5..9e18547 100644
--- a/Sti/StiPlacement.cxx
+++ b/Sti/StiPlacement.cxx
@@ -102,15 +102,16 @@ void StiPlacement::setLayerAngle(float layerAngle)
 ostream& operator<<(ostream& os, const StiPlacement& p)
 {
    os << "StiPlacement:" << endl
-      << "normalRefAngle: " << p.normalRefAngle << " rad, "
-      << "normalRadius: " << p.normalRadius << " cm, "
-      << "normalYoffset: " << p.normalYoffset << " cm" << endl
-      << "centerRefAngle: " << p.centerRefAngle << " rad, "
-      << "centerRadius: "   << p.centerRadius << " cm, "
-      << "centerOrientation: "  << p.centerOrientation << " rad" << endl
-      << "zCenter: " << p.zCenter << " cm, "
-      << "layerRadius: " << p.layerRadius << " cm, "
-      << "_layerAngle: " << p._layerAngle << " rad" << endl;
+      << "\t" << "normalRefAngle: "    << p.normalRefAngle    << " rad" << endl
+      << "\t" << "normalRadius: "      << p.normalRadius      << " cm"  << endl
+      << "\t" << "normalYoffset: "     << p.normalYoffset     << " cm"  << endl
+      << "\t" << "centerRefAngle: "    << p.centerRefAngle    << " rad" << endl
+      << "\t" << "centerRadius: "      << p.centerRadius      << " cm"  << endl
+      << "\t" << "centerOrientation: " << p.centerOrientation << " rad" << endl
+      << "\t" << "zCenter: "           << p.zCenter           << " cm"  << endl
+      << "\t" << "layerRadius: "       << p.layerRadius       << " cm"  << endl
+      << "\t" << "_layerAngle: "       << p._layerAngle       << " rad" << endl
+      << "\t" << "mRegion: "           << p.mRegion           << endl;
 
    return os;
 }
diff --git a/Sti/StiShape.cxx b/Sti/StiShape.cxx
index 1614b4b..2cc5949 100644
--- a/Sti/StiShape.cxx
+++ b/Sti/StiShape.cxx
@@ -1,23 +1,27 @@
 #include "StiCylindricalShape.h"
+#include "StiPlanarShape.h"
 
 
 ostream& operator<<(ostream& os, const StiShape& m)
 {
   os << "StiShape: " << endl
-     << "Name: "<< m.getName()
-     << " ShapeCode: "<< m.getShapeCode()
-     << " HalfDepth (dZ): " << m.getHalfDepth()
-     << " HalfWidth (dY): " << m.getHalfWidth();
+      << "\t" << "name: "              << m.getName()      << endl
+      << "\t" << "_halfDepth (dZ): "   << m.getHalfDepth() << endl
+      << "\t" << "_thickness (2*dX): " << m.getThickness() << endl
+      << "\t" << "shapeCode: "         << m.getShapeCode() << endl;
+
+  if (m.getShapeCode() == kPlanar) {
+    StiPlanarShape *planar = (StiPlanarShape *) &m;
+    os << "\t" << "_halfWidth (dY): " << planar->getHalfWidth() << endl;
+  }
 
   if (m.getShapeCode() == kCylindrical) {
     StiCylindricalShape *cyl = (StiCylindricalShape *) &m;
-    os << " OuterRadius: "<< cyl->getOuterRadius()
-       << " OpeningAngle: "<< cyl->getOpeningAngle();
+    os << "\t" << "_outerRadius: "  << cyl->getOuterRadius()  << endl
+       << "\t" << "_openingAngle: " << cyl->getOpeningAngle() << endl;
   }
 
-  os << " Thickness (2*dX): " << m.getThickness()
-     << " EdgeWidth: " << m.getEdgeWidth()
-     << endl;
+  os << " EdgeWidth: " << m.getEdgeWidth() << endl;
 
   return os;
 }
-- 
1.8.2.GIT


From 2d631c8da13ce70c99d5ae9b8ae25fce6d39038f Mon Sep 17 00:00:00 2001
From: Dmitri Smirnov <d.s@plexoos.com>
Date: Thu, 8 May 2014 15:22:00 -0400
Subject: [PATCH 06/11] Remove unused variables

---
 Sti/StiDetectorBuilder.cxx | 5 +----
 1 file changed, 1 insertion(+), 4 deletions(-)

diff --git a/Sti/StiDetectorBuilder.cxx b/Sti/StiDetectorBuilder.cxx
index 8b8fdde..babc65e 100644
--- a/Sti/StiDetectorBuilder.cxx
+++ b/Sti/StiDetectorBuilder.cxx
@@ -145,7 +145,6 @@ void StiDetectorBuilder::AverageVolume(TGeoPhysicalNode *nodeP)
     new StiElossCalculator(matS->getZOverA(), ionization, matS->getA(), matS->getZ(),matS->getDensity());
   StiShape     *sh     = findShape(volP->GetName());
   Double_t     *xyz    = hmat->GetTranslation();
-  Double_t     *rot    = hmat->GetRotationMatrix();
   Double_t      Phi    = 0;
   //  Double_t xc,yc,zc,rc,rn, nx,ny,nz,yOff;
   StiPlacement *pPlacement = 0;
@@ -223,9 +222,7 @@ void StiDetectorBuilder::AverageVolume(TGeoPhysicalNode *nodeP)
     TVector3 normVec(cos(euler_phi), sin(euler_phi), 0);
     TVector3 normVecPerp(-sin(euler_phi), cos(euler_phi), 0);
 
-    double centerOrient     = centerVec.DeltaPhi(normVec);
-    double centerOrient2    = normVec.DeltaPhi(centerVec);
-    double centerOrientPerp = centerVec.DeltaPhi(normVecPerp);
+    double centerOrient = centerVec.DeltaPhi(normVec);
 
     // First, select the normal vector closest to the central vector
     if ( fabs(centerVec.Dot(normVecPerp)) > fabs(centerVec.Dot(normVec)) )
-- 
1.8.2.GIT


From fb705dcdf634b93037e5b83a3867cc5e0014ee7a Mon Sep 17 00:00:00 2001
From: Dmitri Smirnov <d.s@plexoos.com>
Date: Thu, 8 May 2014 15:24:09 -0400
Subject: [PATCH 07/11] Set volume name based on what was provided by the user.
 It's better be unique

---
 Sti/StiVMCToolKit.cxx | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/Sti/StiVMCToolKit.cxx b/Sti/StiVMCToolKit.cxx
index 06ee109..fe8b044 100644
--- a/Sti/StiVMCToolKit.cxx
+++ b/Sti/StiVMCToolKit.cxx
@@ -884,6 +884,9 @@ TGeoPhysicalNode *StiVMCToolKit::LoopOverNodes(const TGeoNode *nodeT, const Char
     MakeAverageVolume(volT, newshape, newmed, master);
     nodeP = Alignment(nodeT,pathT, volT, newshape, newmed);
     if (nodeP) {
+      // Set a unique name provided by user
+      nodeP->SetName(name);
+
       if (! callback) MakeVolume(nodeP);
       else            callback(nodeP);
     }
-- 
1.8.2.GIT


From 79d5791bd2b4d02986f7004b5b254e3bbb40446b Mon Sep 17 00:00:00 2001
From: Dmitri Smirnov <d.s@plexoos.com>
Date: Mon, 14 Apr 2014 10:55:02 -0400
Subject: [PATCH 08/11] Save Sti detector geometries built by
 StiXXXDetectorBuilder's as drawable objects in root files

---
 Sti/Star/StiStarDetectorBuilder.cxx | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/Sti/Star/StiStarDetectorBuilder.cxx b/Sti/Star/StiStarDetectorBuilder.cxx
index 63f9ea4..02d5797 100644
--- a/Sti/Star/StiStarDetectorBuilder.cxx
+++ b/Sti/Star/StiStarDetectorBuilder.cxx
@@ -10,8 +10,10 @@
 #include "Sti/StiNeverActiveFunctor.h"
 #include "Sti/Star/StiStarDetectorBuilder.h"
 #include "Sti/StiElossCalculator.h"
+#include "StiMaker/StiDetectorVolume.h"
 #include "TMath.h"
 #include "TError.h"
+#include "TFile.h"
 #include "TSystem.h"
 //________________________________________________________________________________
 void StiStarDetectorBuilder::buildDetectors(StMaker&s) {
@@ -19,6 +21,13 @@ void StiStarDetectorBuilder::buildDetectors(StMaker&s) {
   assert(geo);
   useVMCGeometry(); 
   cout << "StiStarDetectorBuilder::buildDetectors() -I- Done" << endl;
+
+  // XXX: Check sti geometry by converting it to drawable root objects
+  TFile fileTmp("sti2rootgeo_bpipe.root", "RECREATE");
+  StiDetectorVolume *stiDetVol = new StiDetectorVolume(*this);
+  stiDetVol->Write();
+  fileTmp.Close();
+  delete stiDetVol;
 }
 //________________________________________________________________________________
 void StiStarDetectorBuilder::useVMCGeometry() {
-- 
1.8.2.GIT


From 7ee986f26f5a6676a54605a9f1148e783137cef6 Mon Sep 17 00:00:00 2001
From: Dmitri Smirnov <d.s@plexoos.com>
Date: Thu, 8 May 2014 15:19:24 -0400
Subject: [PATCH 09/11] my debug

---
 Sti/StiDetectorBuilder.cxx   |  1 +
 Sti/StiKalmanTrackFinder.cxx | 20 +++++++++++---------
 Sti/StiKalmanTrackNode.cxx   |  4 +++-
 Sti/StiVMCToolKit.cxx        |  1 +
 4 files changed, 16 insertions(+), 10 deletions(-)

diff --git a/Sti/StiDetectorBuilder.cxx b/Sti/StiDetectorBuilder.cxx
index babc65e..9f6a4ce 100644
--- a/Sti/StiDetectorBuilder.cxx
+++ b/Sti/StiDetectorBuilder.cxx
@@ -274,6 +274,7 @@ void StiDetectorBuilder::AverageVolume(TGeoPhysicalNode *nodeP)
   Int_t layer = getNRows();
   add(layer,0,pDetector); 
   cout << "StiDetectorBuilder::AverageVolume build detector " << pDetector->getName() << " at layer " << layer << endl;
+  cout << *pDetector;
 }
 ///Returns the number of sectors (or segments) in a the
 ///given row. Sector are expected to be azimuthally
diff --git a/Sti/StiKalmanTrackFinder.cxx b/Sti/StiKalmanTrackFinder.cxx
index cad1964..9a7a29c 100644
--- a/Sti/StiKalmanTrackFinder.cxx
+++ b/Sti/StiKalmanTrackFinder.cxx
@@ -57,7 +57,7 @@ enum {kSeedTimg, kTrakTimg, kPrimTimg};
 enum {kMaxTrackPerm = 10000, kMaxEventPerm = 10000000};
 
 static const double kRMinTpc = 55;
-int StiKalmanTrackFinder::_debug = 0;
+int StiKalmanTrackFinder::_debug = 3;
 ostream &operator<<(ostream &, const StiTrack &);
 int gLevelOfFind = 0;
 //______________________________________________________________________________
@@ -628,18 +628,18 @@ void StiKalmanTrackFinder::find(StiKalmanTrack *track, int direction, StiKalmanT
    double yg = leadNode->y_g();
    double projAngle = atan2(yg, xg);
 
-   if (debug() > 2)cout << "Projection Angle:" << projAngle * 180 / 3.1415 << endl;
+   if (debug() > 2) cout << "Projection Angle:" << projAngle * 180 / 3.1415 << endl;
 
    vector<StiDetectorNode *>::const_iterator layer;
    vector<StiDetectorNode *>::const_reverse_iterator rlayer;
 
    if ((!direction)) {
-      if (debug() > 2) cout << endl << "out-in" << endl;
+      //if (debug() > 2) cout << endl << "out-in" << endl;
 
       rlayer = _detectorContainer->rbeginRadial(leadDet); rlayer++;
    }
    else {
-      if (debug() > 2) cout << endl << "in-out" << endl;
+      //if (debug() > 2) cout << endl << "in-out" << endl;
 
       layer = _detectorContainer->beginRadial(leadDet);    layer++;
    }
@@ -653,7 +653,7 @@ void StiKalmanTrackFinder::find(StiKalmanTrack *track, int direction, StiKalmanT
          vector<StiDetectorNode *>::const_iterator sector;
          vector<StiDetector *> detectors;
 
-         if (debug() > 2) cout << endl << "lead node:" << *leadNode << endl << " lead det:" << *leadDet;
+         //if (debug() > 2) cout << endl << "lead node:" << *leadNode << endl << " lead det:" << *leadDet;
 
          //#define PEREV
 
@@ -717,7 +717,7 @@ void StiKalmanTrackFinder::find(StiKalmanTrack *track, int direction, StiKalmanT
             StiDetector *tDet = *d;
 
             if (debug() > 2) {
-               cout << endl << "target det:" << *tDet;
+               cout << endl << "target det shape:" << *tDet->getShape();
                cout << endl << "lead angle:" << projAngle *radToDeg
                     << " this angle:" << radToDeg*(*d)->getPlacement()->getNormalRefAngle() << endl;
             }
@@ -734,14 +734,16 @@ void StiKalmanTrackFinder::find(StiKalmanTrack *track, int direction, StiKalmanT
 
             if (position < 0 || position > kEdgeZplus) {
                // not reaching this detector layer - stop track
-               if (debug() > 2) cout << "TRACK DOES NOT REACH CURRENT volume" << endl;
-
+               if (debug() > 2) cout << "TRACK DOES NOT REACH CURRENT volume: " << tDet->getName() << endl;
                if (debug() >= 1) StiKalmanTrackNode::PrintStep();
 
                continue; // will try the next available volume on this layer
             }
 
-            if (debug() > 2) cout << "position " << position << "<=kEdgeZplus";
+            if (debug() > 2) {
+               cout << "TRACK DID REACH CURRENT volume: " << tDet->getName() << endl;
+               cout << "position " << position << "<=kEdgeZplus";
+            }
 
             assert(testNode.isValid());
             testNode.setDetector(tDet);
diff --git a/Sti/StiKalmanTrackNode.cxx b/Sti/StiKalmanTrackNode.cxx
index 6fc6179..29660db 100644
--- a/Sti/StiKalmanTrackNode.cxx
+++ b/Sti/StiKalmanTrackNode.cxx
@@ -496,7 +496,7 @@ void StiKalmanTrackNode::Break(int kase)
    2   => 4 - test matrix manipulation
    3   => 8 - test locate
  */
-int StiKalmanTrackNode::_debug = 0;
+int StiKalmanTrackNode::_debug = 1;
 int StiKalmanTrackNode::_laser = 0;
 
 //______________________________________________________________________________
@@ -1577,6 +1577,8 @@ void StiKalmanTrackNode::propagateMCS(StiKalmanTrackNode *previousNode, const St
    double eloss = calculator->calculate(1., m, beta2);
    dE = sign * dxEloss * eloss;
 
+   printf("XXX:ds: dE = sign * dxEloss * eloss: %f = %f * %f * %f * 1e6\n", dE*1e6, sign, dxEloss, eloss);
+
    if (TMath::Abs(dE) > 0) {
       if (debug()) {
          commentdEdx  = Form("%6.3g cm(%5.2f) %6.3g keV %6.3f GeV", mgP.dx, 100*relRadThickness, 1e6*dE, TMath::Sqrt(e2) - m);
diff --git a/Sti/StiVMCToolKit.cxx b/Sti/StiVMCToolKit.cxx
index fe8b044..0fecedd 100644
--- a/Sti/StiVMCToolKit.cxx
+++ b/Sti/StiVMCToolKit.cxx
@@ -814,6 +814,7 @@ TGeoPhysicalNode *StiVMCToolKit::Alignment(const TGeoNode *nodeT, const Char_t *
     for (Int_t i = 0; i < N; i++) {
       TGeoPhysicalNode *nod = dynamic_cast<TGeoPhysicalNode *> (listP->At(i));
       if (nod && TString(nod->GetName()) == TString(pathT)) {
+         cout << "nod name: " << nod->GetName() << endl;
 	nodeP = nod; break;
       }
     }
-- 
1.8.2.GIT


From 943bdd580df26dec02f20f9a2f92804a5900bc79 Mon Sep 17 00:00:00 2001
From: Dmitri Smirnov <d.s@plexoos.com>
Date: Tue, 3 Jun 2014 15:55:08 -0400
Subject: [PATCH 10/11] Added new data member to keep track of track energy
 losses in the node

---
 Sti/StiKalmanTrackNode.cxx | 2 ++
 Sti/StiKalmanTrackNode.h   | 6 ++++++
 2 files changed, 8 insertions(+)

diff --git a/Sti/StiKalmanTrackNode.cxx b/Sti/StiKalmanTrackNode.cxx
index 29660db..7a0b6b8 100644
--- a/Sti/StiKalmanTrackNode.cxx
+++ b/Sti/StiKalmanTrackNode.cxx
@@ -1593,6 +1593,8 @@ void StiKalmanTrackNode::propagateMCS(StiKalmanTrackNode *previousNode, const St
       mFP.ptin() = mFP.ptin() * correction;
    }
 
+   mEnergyLosses = dE*1e6;
+
    mPP() = mFP; mPE() = mFE;
 
 }
diff --git a/Sti/StiKalmanTrackNode.h b/Sti/StiKalmanTrackNode.h
index 3a4cf05..73ecf89 100644
--- a/Sti/StiKalmanTrackNode.h
+++ b/Sti/StiKalmanTrackNode.h
@@ -247,6 +247,7 @@ public:
    double getGasX0() const;
    double getDensity() const;
    double getGasDensity() const;
+   double getEnergyLosses() const;
 
    void   extend();
    void   reduce();
@@ -302,6 +303,7 @@ protected:
    char mFlipFlop;
    char mHitCand;
    char mIHitCand;
+   double mEnergyLosses; ///< Track energy losses in this volume
    char   _end[1];
    StiNodeExt *_ext;
    StiNodeInf *_inf;
@@ -424,6 +426,10 @@ inline double StiKalmanTrackNode::getGasDensity() const
    return det->getGas()->getDensity();
 }
 
+inline double StiKalmanTrackNode::getEnergyLosses() const
+{
+   return mEnergyLosses;
+}
 
 inline StThreeVectorD *StiKalmanTrackNode::getLengths(StiKalmanTrackNode *nextNode)
 {
-- 
1.8.2.GIT


From 0c3b449a9ff7e750718a019c6a730a934152520e Mon Sep 17 00:00:00 2001
From: Dmitri Smirnov <d.s@plexoos.com>
Date: Tue, 3 Jun 2014 16:03:00 -0400
Subject: [PATCH 11/11] Do not use additional margin/edge for HFT volumes. I
 assume that to some extent the projected track error should prevent losses of
 hits in active volumes. This change was not tested properly. I don't know how
 it may affect track reconstruction with SVT

---
 Sti/StiKalmanTrackNode.cxx | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/Sti/StiKalmanTrackNode.cxx b/Sti/StiKalmanTrackNode.cxx
index 7a0b6b8..910eee9 100644
--- a/Sti/StiKalmanTrackNode.cxx
+++ b/Sti/StiKalmanTrackNode.cxx
@@ -1975,7 +1975,7 @@ int StiKalmanTrackNode::locate()
 #ifndef DO_TPCCATRACKER // insensible region on a detector plane
    edge  = 2.;
 
-   if (mFP.x() < 50.)      edge  = 0.3;
+   if (mFP.x() < 50.)      edge  = 0.0;
 
 #else /* DO_TPCCATRACKER */
    edge = 0.;
-- 
1.8.2.GIT

