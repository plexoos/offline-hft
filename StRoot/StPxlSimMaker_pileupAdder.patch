diff -rupN StRoot/StPxlSimMaker/.consign ../StRoot/StPxlSimMaker/.consign
--- StRoot/StPxlSimMaker/.consign	1969-12-31 19:00:00.000000000 -0500
+++ ../StRoot/StPxlSimMaker/.consign	2014-07-03 11:06:32.307009000 -0400
@@ -0,0 +1 @@
+StPxlSimMaker.h:1404263753 - 459795ea10089132faff566fc6a802c3
Binary files StRoot/StPxlSimMaker/doc/PXL_ultimate_sensor_flemming.pdf and ../StRoot/StPxlSimMaker/doc/PXL_ultimate_sensor_flemming.pdf differ
diff -rupN StRoot/StPxlSimMaker/StPxlFastSim.cxx ../StRoot/StPxlSimMaker/StPxlFastSim.cxx
--- StRoot/StPxlSimMaker/StPxlFastSim.cxx	2014-03-13 13:00:19.000000000 -0400
+++ ../StRoot/StPxlSimMaker/StPxlFastSim.cxx	2014-07-02 21:36:31.000000000 -0400
@@ -172,7 +172,7 @@ Int_t StPxlFastSim::addPxlHits(const StM
                tempHit->setSector(iSec + 1);
                tempHit->setLadder(mcPix->ladder());
                tempHit->setSensor(mcPix->sensor());
-               tempHit->setIdTruth(mcPix->parentTrack()->key(), 100);
+               mcPix->parentTrack()? tempHit->setIdTruth(mcPix->parentTrack()->key(), 100): tempHit->setIdTruth(-999);
                tempHit->setDetectorId(kPxlId);
                tempHit->setId(mcPix->key());
                tempHit->setLocalPosition(localPixHitPos[0], localPixHitPos[1], localPixHitPos[2]);
diff -rupN StRoot/StPxlSimMaker/StPxlPileupAdder.cxx ../StRoot/StPxlSimMaker/StPxlPileupAdder.cxx
--- StRoot/StPxlSimMaker/StPxlPileupAdder.cxx	1969-12-31 19:00:00.000000000 -0500
+++ ../StRoot/StPxlSimMaker/StPxlPileupAdder.cxx	2014-07-03 10:55:24.000000000 -0400
@@ -0,0 +1,166 @@
+/*
+ *
+ * Author: M. Mustafa
+ */
+
+#include <stdio.h>
+
+#include "StMessMgr.h"
+#include "Stypes.h"
+#include "Stiostream.h"
+#include "StPxlPileupAdder.h"
+#include "StMcEvent/StMcPxlHitCollection.hh"
+#include "StMcEvent/StMcPxlHit.hh"
+#include "StThreeVectorF.hh"
+
+#include "TString.h"
+#include "TFile.h"
+#include "TTree.h"
+#include "TBranch.h"
+
+#include "TObjectSet.h"
+#include "StPxlDbMaker/StPxlDb.h"
+
+
+StPxlPileupAdder::~StPxlPileupAdder()
+{
+	if(mPxlDb) delete mPxlDb;
+}
+//____________________________________________________________
+Int_t StPxlPileupAdder::init(TString pileupFileName,const TObjectSet* pxlDbDataSet)
+{
+   // run is not used in the current implementation, but might be necessary in the future.
+   LOG_INFO << "StPxlPileupAdder::init()" << endm;
+
+   if(pxlDbDataSet != 0)
+   {
+	   mPxlDb = (StPxlDb *)pxlDbDataSet->GetObject();
+	   if (!mPxlDb)
+	   {
+		   LOG_ERROR << "StPxlFastSim - E - mPxlDb is not available" << endm;
+		   return kStErr;
+	   }
+	   else
+	   {
+		   LOG_INFO << "StPxlFastSim - Using geometry from pxlDB" <<endm;
+	   }
+   }
+   else
+   {
+	   LOG_INFO << "StPxlPileupAdder - PxlDb is not available this will potentially mess up your transformations for vid==0 hits" <<endm;
+   }
+
+   mPileupFile = new TFile(pileupFileName.Data());
+   if(!mPileupFile)
+   {
+	   LOG_ERROR << "StPxlPileupAdder: pileup file not found." << endm;
+	   return kStErr;
+   }
+
+   // set tree addresses
+   mPileupTree = (TTree*)mPileupFile->Get("pileup_tree");
+   mPileupTree->SetBranchAddress("nhits", &nhits, &b_nhits);
+   mPileupTree->SetBranchAddress("x", x, &b_x);
+   mPileupTree->SetBranchAddress("y", y, &b_y);
+   mPileupTree->SetBranchAddress("z", z, &b_z);
+   mPileupTree->SetBranchAddress("xLoc", xLoc, &b_xLoc);
+   mPileupTree->SetBranchAddress("yLoc", yLoc, &b_yLoc);
+   mPileupTree->SetBranchAddress("zLoc", zLoc, &b_zLoc);
+   mPileupTree->SetBranchAddress("px", px, &b_px);
+   mPileupTree->SetBranchAddress("py", py, &b_py);
+   mPileupTree->SetBranchAddress("pz", pz, &b_pz);
+   mPileupTree->SetBranchAddress("de", de, &b_de);
+   mPileupTree->SetBranchAddress("ds", ds, &b_ds);
+   mPileupTree->SetBranchAddress("key", key, &b_key);
+   mPileupTree->SetBranchAddress("vid", vid, &b_vid);
+   mPileupTree->SetBranchAddress("layer", layer, &b_layer);
+
+   return kStOk;
+}
+//____________________________________________________________
+Int_t StPxlPileupAdder::addPxlHits(StMcPxlHitCollection& mcPxlHitCol)
+{
+
+	// tree has one event
+	mPileupTree->GetEntry(0);
+
+	LOG_INFO<<"StPxlPileupAdder: adding "<<nhits<<" pileup hits."<<endm;
+
+	cout<<"Number of hits before adding..."<<mcPxlHitCol.numberOfHits()<<endl;
+
+	for(int i=0;i<nhits;i++)
+	{
+		StThreeVectorF hit_x(xLoc[i],yLoc[i],zLoc[i]);
+		StThreeVectorF hit_p(px[i],py[i],pz[i]);
+
+		//Long64_t volume_id = vid[i] !=0 ? vid[i] : get_vid(i);
+		//Long64_t volume_id = get_vid(i);
+		//if(volume_id) mcPxlHitCol.addHit(new StMcPxlHit(hit_x,hit_p,de[i],ds[i],0,key[i],volume_id));
+	
+		mcPxlHitCol.addHit(new StMcPxlHit(hit_x,hit_p,de[i],ds[i],0,key[i],vid[i]));
+	}
+
+	cout<<"Number of hits after adding..."<<mcPxlHitCol.numberOfHits()<<endl;
+
+   return kStOK;
+}
+//____________________________________________________________
+Long64_t StPxlPileupAdder::get_vid(Int_t i)
+{
+
+	const Double_t globalPos[3] = {x[i],y[i],z[i]};
+	bool found = false;
+	UInt_t sec,lad,sen;
+
+	Float_t min[3] = {0.1,0.1,0.1};
+
+	for(UInt_t iSec=0; iSec < 10; iSec++)
+	{
+		for(UInt_t iLad=0; iLad< 4; iLad++)
+		{
+			for(UInt_t iSen=0; iSen<10; iSen++)
+			{
+				Double_t localPos[3] = {0.,0.,0.};
+
+				TGeoHMatrix* combP = (TGeoHMatrix*)mPxlDb->geoHMatrixSensorOnGlobal(iSec+1,iLad+1,iSen+1);
+				combP->MasterToLocal(globalPos,localPos);
+
+				if(fabs(xLoc[i]-localPos[0])< min[0]
+				&& fabs(yLoc[i]-localPos[1])< min[1]
+				&& fabs(zLoc[i]-localPos[2])< min[2])
+				{
+					sec = iSec+1;
+					lad = iLad+1;
+					sen = iSen+1;
+					min[0] = fabs(xLoc[i]-localPos[0]);
+					min[1] = fabs(yLoc[i]-localPos[1]);
+					min[2] = fabs(zLoc[i]-localPos[2]);
+					
+					found = true;
+					//break;
+				}
+			}
+
+			//if(found) break;
+		}
+		
+		//if(found) break;
+	}
+
+	 //UChar_t sector() const {return mVolumeId/1000000;}
+	 //UChar_t ladder() const {return  (mVolumeId%1000000)/10000;} 
+	 //UChar_t sensor() const {return  (mVolumeId - sector()*1000000 - ladder()*10000)/100;} 
+
+	 Long64_t volume_id = 0;
+	 
+	 if(found)
+	 {
+		 volume_id = sec*1000000;
+		 volume_id += lad*10000;
+		 volume_id += sen*100;
+	 }
+
+	// cout<<globalPos[0]<<" "<<globalPos[1]<<" "<<globalPos[2]<<endl;
+	 cout<<found<<" "<<vid[i]<<" "<<volume_id<<" "<<sec<<" "<<lad<<" "<<sen<<" "<<min[0]<<" "<<min[1]<<" "<<min[2]<<endl;
+	 return volume_id;
+}
diff -rupN StRoot/StPxlSimMaker/StPxlPileupAdder.h ../StRoot/StPxlSimMaker/StPxlPileupAdder.h
--- StRoot/StPxlSimMaker/StPxlPileupAdder.h	1969-12-31 19:00:00.000000000 -0500
+++ ../StRoot/StPxlSimMaker/StPxlPileupAdder.h	2014-07-02 23:10:02.000000000 -0400
@@ -0,0 +1,87 @@
+/*
+ * $Id$
+ *
+ * Author: M. Mustafa
+ *
+ * 
+ **********************************************************
+ * $Log$
+ * Revision 1.2  2014/07/03 19:43:13  mstftsm
+ * Updated in accordance with the nee pileup trees stucture.
+ *
+ *
+ */
+
+/**
+   \class StPxlPileupAdder
+
+   \brief Class to add pile up hits to StMcPxlHitCollection
+
+   THIS IS A HACK THAT IS NOT IN THE OFFICIAL STAR VERSION
+
+   This class conforms to the STAR StMaker standards.
+*/
+
+#ifndef STAR_StPxlPileupAdder
+#define STAR_StPxlPileupAdder
+
+class TString;
+class TBranch;
+class TFile;
+class TTree;
+class StMcPxlHitCollection;
+class TObjectSet;
+class StPxlDb;
+
+const int MAXHIT = 200000;
+
+class StPxlPileupAdder
+{
+ public:
+
+  /*! \brief Constructor */ 
+  StPxlPileupAdder(){}
+
+  /*! \brief This class does not own any hit containers.
+  */
+  ~StPxlPileupAdder();
+
+
+  Int_t init(TString pileupFileName,const TObjectSet*);
+  Int_t addPxlHits(StMcPxlHitCollection&);
+
+  /*! \brief Documentation method. GetCVS can be called from the chain, providing a list
+   *  of all maker versions in use.
+  */
+
+ virtual const char *GetCVS() const
+  {static const char cvs[]=""__DATE__" "__TIME__ ; return cvs;}
+
+ private:
+ StPxlDb* mPxlDb;
+ TFile* mPileupFile;
+ TTree* mPileupTree;
+
+ // pileup tree 
+   Float_t x[MAXHIT], y[MAXHIT], z[MAXHIT], xLoc[MAXHIT], yLoc[MAXHIT], zLoc[MAXHIT],
+	 px[MAXHIT], py[MAXHIT], pz[MAXHIT], de[MAXHIT], ds[MAXHIT];
+   Long64_t key[MAXHIT], vid[MAXHIT];
+   Int_t layer[MAXHIT], nhits;
+
+   TBranch  *b_nhits;   //! 
+   TBranch  *b_x;   //! 
+   TBranch  *b_y;   //! 
+   TBranch  *b_z;   //! 
+   TBranch  *b_xLoc;   //! 
+   TBranch  *b_yLoc;   //! 
+   TBranch  *b_zLoc;   //! 
+   TBranch  *b_px;   //! 
+   TBranch  *b_py;   //! 
+   TBranch  *b_pz;   //! 
+   TBranch  *b_de;   //! 
+   TBranch  *b_ds;   //! 
+   TBranch  *b_key;   //! 
+   TBranch  *b_vid;   //! 
+   TBranch  *b_layer;   //! 
+
+   Long64_t get_vid(Int_t);
+ 
+};
+#endif
diff -rupN StRoot/StPxlSimMaker/StPxlSimMaker.cxx ../StRoot/StPxlSimMaker/StPxlSimMaker.cxx
--- StRoot/StPxlSimMaker/StPxlSimMaker.cxx	2014-06-25 15:21:57.000000000 -0400
+++ ../StRoot/StPxlSimMaker/StPxlSimMaker.cxx	2014-07-02 21:13:57.000000000 -0400
@@ -20,6 +20,8 @@
 #include "StMcEvent/StMcPxlHitCollection.hh"
 #include "StEvent/StPxlHitCollection.h"
 
+#include "StPxlPileupAdder.h"
+
 #include "Stiostream.h"
 #include "StHit.h"
 #include "StEventTypes.h"
@@ -31,12 +33,13 @@
 #include "TGeoMatrix.h"
 
 #include "TObjectSet.h"
+#include "TString.h"
 
 ClassImp(StPxlSimMaker)
 
 using namespace std;
 
-StPxlSimMaker::StPxlSimMaker(const Char_t* name) : StMaker(name) , mPxlSimulator(0), mUseFastSim(kFALSE), mUseDIGMAPSSim(kFALSE) , mUseIdealGeom(kTRUE), mUseDbGeom(kFALSE), mUseRandomSeed(kFALSE)
+StPxlSimMaker::StPxlSimMaker(const Char_t* name) : StMaker(name) , mPxlSimulator(0), mUseFastSim(kFALSE), mUseDIGMAPSSim(kFALSE) , mUseIdealGeom(kTRUE), mUseDbGeom(kFALSE), mUseRandomSeed(kFALSE),mAddPileup(kFALSE)
 {
 }
 //____________________________________________________________
@@ -59,6 +62,12 @@ Int_t StPxlSimMaker::Init()
    //{
    // temporary till DIGMAPS algorithm is added and option added in StMaker
    mUseFastSim = kTRUE;
+
+   if(mAddPileup)
+   {
+	   mPileupAdder = new StPxlPileupAdder();
+   }
+
    mPxlSimulator = new StPxlFastSim("pxlFastSim",mUseRandomSeed);
 
    LOG_INFO << "StPxlSimMaker: using StPxlFastSim " << endm;
@@ -90,6 +99,11 @@ Int_t StPxlSimMaker::InitRun(Int_t RunNo
 	   }
    }
 
+   if(mAddPileup)
+   {
+	   mPileupAdder->init(mPileupFile,pxlDbDataSet);
+   }
+
    return mPxlSimulator->initRun(*hitErrSet, pxlDbDataSet, RunNo);
 }
 //____________________________________________________________
@@ -121,6 +135,12 @@ Int_t StPxlSimMaker::Make()
       return kStOk;
    }
 
+   // add pile up 
+   if(mAddPileup)
+   {
+	   mPileupAdder->addPxlHits(*mcPxlHitCol);
+   }
+
    if (mUseIdealGeom && !gGeoManager) GetDataBase("VmcGeometry");
    if (mUseIdealGeom && !gGeoManager)
    {
diff -rupN StRoot/StPxlSimMaker/StPxlSimMaker.h ../StRoot/StPxlSimMaker/StPxlSimMaker.h
--- StRoot/StPxlSimMaker/StPxlSimMaker.h	2014-03-13 13:00:19.000000000 -0400
+++ ../StRoot/StPxlSimMaker/StPxlSimMaker.h	2014-07-01 21:15:53.000000000 -0400
@@ -37,6 +37,8 @@
 #endif
 
 class StPxlISim;
+class TString;
+class StPxlPileupAdder;
 
 class StPxlSimMaker : public StMaker 
 {
@@ -70,6 +72,10 @@ class StPxlSimMaker : public StMaker 
   void useDbGeom() {mUseDbGeom = kTRUE;}
   void useRandomSeed() {mUseRandomSeed = kTRUE;}
 
+
+  void addPileup(){mAddPileup = kTRUE;}
+  void setPileupFile(TString pileupFile) {mPileupFile = pileupFile;}
+
   /*! \brief Documentation method. GetCVS can be called from the chain, providing a list
    *  of all maker versions in use.
   */
@@ -86,6 +92,10 @@ private:
     Bool_t mUseDbGeom;
     Bool_t mUseRandomSeed;
 
+    TString mPileupFile; // THIS IS A HACK THAT IS NOT IN THE OFFICIAL STAR VERSION
+    Bool_t mAddPileup;
+    StPxlPileupAdder* mPileupAdder;
+
 
   ClassDef(StPxlSimMaker,1)   //StAF chain virtual base class for Makers
 };
